{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Numerical Analysis","text":"<p>The Numerical Analysis Method I have learned in \"Numerical Analysis\" 2022 Fall | Prof. Shu-chih Yang (\u694a \u8212\u829d)</p> <p>\u8072\u660e\uff1a\u6b64 repo \u7d55\u5c0d\u4e0d\u6703\u76c8\u5229\uff0c\u90fd\u662f\u8ab2\u7a0b\u4e0a\u6240\u5b78\u5230\u7684\uff0c\u4e5f\u4e0d\u6703\u60e1\u610f\u50b3\u64ad\uff0c\u4e00\u5207\u90fd\u6703\u4ee5\u6559\u6388\u6307\u5c0e\u70ba\u539f\u5247\u3002</p>"},{"location":"environment_usage/","title":"Enviroment Usage","text":""},{"location":"environment_usage/#create-virtual-environment","title":"Create Virtual Environment\u00b6","text":"<p>With pip vertial environment: python request: <code>3.10.1</code></p>"},{"location":"environment_usage/#for-linuxmacos","title":"For Linux/MacOS","text":"<pre><code>$ pip3 install virtualenv\n$ virtualenv venv --python=python3.10.1\n$ source venv/bin/activate\n$ pip install -r requirements.txt\n$ deactivate\n$ rm -rf venv     # remove the venv\n</code></pre>"},{"location":"environment_usage/#for-windows","title":"For Windows","text":"<pre><code>$ pip install virtualenv\n$ virtualenv venv\n$ venv\\Scripts\\activate\n$ pip install -r requirements.txt\n$ deactivate\n$ rmdir /s venv     # remove the venv\n</code></pre>"},{"location":"assignment/a1/22_fall_a1/","title":"[2022 Fall] Assignment1","text":"In\u00a0[1]: Copied! <pre>import math\n</pre> import math <p>Build the factorial mechanism</p> In\u00a0[2]: Copied! <pre>def factorial(n) :\n    sum = 1\n\n    for i in range(2, n + 1) :\n        sum *= i\n\n    return sum\n</pre> def factorial(n) :     sum = 1      for i in range(2, n + 1) :         sum *= i      return sum <p>Build the error criterion : \u03b5s</p> In\u00a0[3]: Copied! <pre>def countErrorCriterion(n) :\n    errorCriterion = (0.5 * 10 ** (2 - n)) * 100\n\n    return errorCriterion\n</pre> def countErrorCriterion(n) :     errorCriterion = (0.5 * 10 ** (2 - n)) * 100      return errorCriterion <p>Build the approximate estimate of the error : \u03b5a</p> In\u00a0[4]: Copied! <pre>def countApproximateEstimateError(currentApproximation, previousApproximation) :\n    approximateError = currentApproximation - previousApproximation\n\n    if currentApproximation == 0 :    # The first and second value of cosine tylor polynomial is 0.0 and 1.0; therefore we have to pass them.\n        return 999\n    else :\n        approximateEstimateError = abs((approximateError / currentApproximation) * 100)\n\n    return approximateEstimateError\n</pre> def countApproximateEstimateError(currentApproximation, previousApproximation) :     approximateError = currentApproximation - previousApproximation      if currentApproximation == 0 :    # The first and second value of cosine tylor polynomial is 0.0 and 1.0; therefore we have to pass them.         return 999     else :         approximateEstimateError = abs((approximateError / currentApproximation) * 100)      return approximateEstimateError <p>Build the percent relative error : \u03b5t</p> In\u00a0[5]: Copied! <pre>def countPercentRelativeError(trueValue, approximation) :\n    trueError = trueValue - approximation\n    percentRelativeError = (trueError / trueValue) * 100\n\n    return percentRelativeError\n</pre> def countPercentRelativeError(trueValue, approximation) :     trueError = trueValue - approximation     percentRelativeError = (trueError / trueValue) * 100      return percentRelativeError <p>Build cosine tylor polynomial</p> In\u00a0[6]: Copied! <pre>def tylorPolynomial(n, x) :\n    sum = 0\n\n    for i in range(n) : \n        sum = sum + ((-1) ** i * x ** (2 * i)) / factorial(2 * i)\n\n    return float(sum)\n</pre> def tylorPolynomial(n, x) :     sum = 0      for i in range(n) :          sum = sum + ((-1) ** i * x ** (2 * i)) / factorial(2 * i)      return float(sum) <p>Announce the variable.</p> In\u00a0[7]: Copied! <pre>def main():\n\n    PI = math.pi\n    n = 5\n    errorCriterion = countErrorCriterion(n)\n    loopCount = 0\n    currentApproximate = 0.0\n    previousApproximate = 0.0\n    trueValue = math.cos(2 * PI)\n    print(f\"True value of cos(0): {trueValue}.\")\n\n    # print((1.00000000000000 - 0.999978232974615 / 1.00000000000000) * 100)\n    print(f\"The error criterion is: {errorCriterion}, and n = {n}.\\n\\nStart the estimate: \\n\")\n\n    while True :\n        previousApproximate = currentApproximate\n        currentValue = tylorPolynomial(loopCount, 2 * PI)\n        currentApproximate = currentValue\n        approximateEstimateError = countApproximateEstimateError(currentApproximate, previousApproximate)\n        percentRelativeError = countPercentRelativeError(trueValue, currentValue)\n\n        if (approximateEstimateError &lt; errorCriterion) :\n            loopCount += 1\n\n            print(f\"Times: {loopCount}, \\ncurrent value: {currentValue}, \\tapproximate estimate error: {approximateEstimateError} \\tpercent relative error: {percentRelativeError}%.\\n\")\n            print(f\"Here is the error that we accept!!!\")\n            print(f\"Total use {loopCount} times to get the result we want!\")\n\n            break\n        else :\n            loopCount += 1\n\n        print(f\"Times: {loopCount}, \\ncurrent value: {currentValue}, \\tapproximate estimate error: {approximateEstimateError} \\tpercent relative error: {percentRelativeError}%.\")\n</pre> def main():      PI = math.pi     n = 5     errorCriterion = countErrorCriterion(n)     loopCount = 0     currentApproximate = 0.0     previousApproximate = 0.0     trueValue = math.cos(2 * PI)     print(f\"True value of cos(0): {trueValue}.\")      # print((1.00000000000000 - 0.999978232974615 / 1.00000000000000) * 100)     print(f\"The error criterion is: {errorCriterion}, and n = {n}.\\n\\nStart the estimate: \\n\")      while True :         previousApproximate = currentApproximate         currentValue = tylorPolynomial(loopCount, 2 * PI)         currentApproximate = currentValue         approximateEstimateError = countApproximateEstimateError(currentApproximate, previousApproximate)         percentRelativeError = countPercentRelativeError(trueValue, currentValue)          if (approximateEstimateError &lt; errorCriterion) :             loopCount += 1              print(f\"Times: {loopCount}, \\ncurrent value: {currentValue}, \\tapproximate estimate error: {approximateEstimateError} \\tpercent relative error: {percentRelativeError}%.\\n\")             print(f\"Here is the error that we accept!!!\")             print(f\"Total use {loopCount} times to get the result we want!\")              break         else :             loopCount += 1          print(f\"Times: {loopCount}, \\ncurrent value: {currentValue}, \\tapproximate estimate error: {approximateEstimateError} \\tpercent relative error: {percentRelativeError}%.\") In\u00a0[8]: Copied! <pre>if __name__ == '__main__':\n    main()\n</pre> if __name__ == '__main__':     main() <pre>True value of cos(0): 1.0.\nThe error criterion is: 0.05, and n = 5.\n\nStart the estimate: \n\nTimes: 1, \ncurrent value: 0.0, \tapproximate estimate error: 999 \tpercent relative error: 100.0%.\nTimes: 2, \ncurrent value: 1.0, \tapproximate estimate error: 100.0 \tpercent relative error: 0.0%.\nTimes: 3, \ncurrent value: -18.739208802178716, \tapproximate estimate error: 105.33640459720868 \tpercent relative error: 1973.9208802178716%.\nTimes: 4, \ncurrent value: 46.200185220489566, \tapproximate estimate error: 140.560895400627 \tpercent relative error: -4520.018522048957%.\nTimes: 5, \ncurrent value: -39.25663198620415, \tapproximate estimate error: 217.6875928549489 \tpercent relative error: 4025.6631986204147%.\nTimes: 6, \ncurrent value: 20.98800938567249, \tapproximate estimate error: 287.0431409898395 \tpercent relative error: -1998.8009385672492%.\nTimes: 7, \ncurrent value: -5.438247397701897, \tapproximate estimate error: 485.9333320242407 \tpercent relative error: 643.8247397701897%.\nTimes: 8, \ncurrent value: 2.465288973616568, \tapproximate estimate error: 320.59269545687425 \tpercent relative error: -146.5288973616568%.\nTimes: 9, \ncurrent value: 0.7508982625278968, \tapproximate estimate error: 228.31198268020754 \tpercent relative error: 24.91017374721032%.\nTimes: 10, \ncurrent value: 1.0329042309836878, \tapproximate estimate error: 27.302237709610523 \tpercent relative error: -3.2904230983687777%.\nTimes: 11, \ncurrent value: 0.9965213898411421, \tapproximate estimate error: 3.650984465907502 \tpercent relative error: 0.34786101588578644%.\nTimes: 12, \ncurrent value: 1.000301224041822, \tapproximate estimate error: 0.3778695966608076 \tpercent relative error: -0.030122404182209017%.\nTimes: 13, \ncurrent value: 0.999978232974615, \tapproximate estimate error: 0.032299809791492 \tpercent relative error: 0.002176702538503328%.\n\nHere is the error that we accept!!!\nTotal use 13 times to get the result we want!\n</pre>"},{"location":"assignment/a1/22_fall_a1/#2022-fall-assignment1","title":"[2022 Fall] Assignment1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a2/22_fall_a2_q1/","title":"[2022 Fall] Assignment2-1","text":"In\u00a0[1]: Copied! <pre>import math\n\nc = 246886422468.0000\nd = 13579.0000\n\ndef formula(c, d) :\n    return math.sqrt(c ** 2 + d) - c\n\n\nans = formula(c, d)\nprint(\"%.4f\" %(ans))\n\nprint(float((c * c + d)))\n</pre> import math  c = 246886422468.0000 d = 13579.0000  def formula(c, d) :     return math.sqrt(c ** 2 + d) - c   ans = formula(c, d) print(\"%.4f\" %(ans))  print(float((c * c + d))) <pre>0.0000\n6.095290559904778e+22\n</pre>"},{"location":"assignment/a2/22_fall_a2_q1/#2022-fall-assignment2-1","title":"[2022 Fall] Assignment2-1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a2/22_fall_a2_q1/#question-evaluate-the-quantity-sqrtc2-d-c-to-4-correct-significant-figures-where-c-246886422468-and-d-13579","title":"Question: Evaluate the quantity $\\sqrt{(c^2 + d)} -c$ to 4 correct significant figures, where c = 246886422468 and d = 13579.\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q1/#answer","title":"Answer:\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q2/","title":"[2022 Fall] Assignment2-2","text":"In\u00a0[1]: Copied! <pre># The function to convert float type into integer type.\n\nprint(\"The function we convert float type into integer type in python is: int()\\n\")\n\n\"\"\" The example of the python code to convert float type to int type. \"\"\"\n\nprint(\"====== The First Experiment ======\")\n# First we announce the float type number.\nnumberOne = 10.0000000001\n\nprint(f\"The numberOne: {numberOne};\\tType: {type(numberOne).__name__}.\")\n\n# After using the function, it will ignore the value after point.\nnumberOne = int(numberOne)\nprint(f\"The converted numberOne: {numberOne};\\tConverted type: {type(numberOne).__name__}.\")\n\nprint(\"\\n====== The Second Experiment ======\")\n\n# The next we can do another experiment, we announce the second number.\nnumberTwo = 10.9999999999\nprint(f\"The numberTwo: {numberTwo};\\tType: {type(numberTwo).__name__}.\")\n\n# After using the function, it still ignore the value after point.\n# No matter the value after the point. The result is the same.\nnumberTwo = int(numberTwo)\nprint(f\"The converted numberTwo: {numberTwo};\\tConverted type: {type(numberTwo).__name__}.\\n\")\n\nprint(\"====== The conclusion ======\")\nprint(\"Above all, we know that if we use function int() in python, no matter how value after the point, it will be losed.\")\n</pre> # The function to convert float type into integer type.  print(\"The function we convert float type into integer type in python is: int()\\n\")  \"\"\" The example of the python code to convert float type to int type. \"\"\"  print(\"====== The First Experiment ======\") # First we announce the float type number. numberOne = 10.0000000001  print(f\"The numberOne: {numberOne};\\tType: {type(numberOne).__name__}.\")  # After using the function, it will ignore the value after point. numberOne = int(numberOne) print(f\"The converted numberOne: {numberOne};\\tConverted type: {type(numberOne).__name__}.\")  print(\"\\n====== The Second Experiment ======\")  # The next we can do another experiment, we announce the second number. numberTwo = 10.9999999999 print(f\"The numberTwo: {numberTwo};\\tType: {type(numberTwo).__name__}.\")  # After using the function, it still ignore the value after point. # No matter the value after the point. The result is the same. numberTwo = int(numberTwo) print(f\"The converted numberTwo: {numberTwo};\\tConverted type: {type(numberTwo).__name__}.\\n\")  print(\"====== The conclusion ======\") print(\"Above all, we know that if we use function int() in python, no matter how value after the point, it will be losed.\")  <pre>The function we convert float type into integer type in python is: int()\n\n====== The First Experiment ======\nThe numberOne: 10.0000000001;\tType: float.\nThe converted numberOne: 10;\tConverted type: int.\n\n====== The Second Experiment ======\nThe numberTwo: 10.9999999999;\tType: float.\nThe converted numberTwo: 10;\tConverted type: int.\n\n====== The conclusion ======\nAbove all, we know that if we use function int() in python, no matter how value after the point, it will be losed.\n</pre>"},{"location":"assignment/a2/22_fall_a2_q2/#2022-fall-assignment2-2","title":"[2022 Fall] Assignment2-2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a2/22_fall_a2_q2/#question-find-out-the-python-functions-used-to-convert-a-floating-point-number-into-an-integer","title":"Question: Find out the Python functions used to convert a floating point number into an integer.\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q2/#answer","title":"Answer:\u00b6","text":"<p>The function to convert float type into integer type: <code>int()</code></p> <p>we can test two number:</p> <ol> <li>10.0000000001</li> <li>10.9999999999</li> </ol> <p>After using <code>int()</code> function, both turn into 10. Therefore, we get the conclusion that when we use the function to convert the float type into integer type, the value after point will be ignored.</p>"},{"location":"assignment/a2/22_fall_a2_q3/","title":"[2022 Fall] Assignment2-3","text":"<pre>program test_int\nimplicit none\ninteger :: i = 42\ncomplex :: z = (-3.7, 1.0)\nprint *, int(i)\nprint *, int(z), int(z,8)\n\nstop\n  end program\n</pre>"},{"location":"assignment/a2/22_fall_a2_q3/#2022-fall-assignment2-3","title":"[2022 Fall] Assignment2-3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a2/22_fall_a2_q3/#question-what-is-the-difference-between-the-intrinsic-int-and-nint-functions-in-fortran-find-the-corresponding-functions-in-python","title":"Question: What is the difference between the intrinsic <code>INT</code> and <code>NINT</code> functions in Fortran? Find the corresponding functions in Python.\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q3/#answer","title":"Answer:\u00b6","text":"<p>The difference between two function in fortran.</p> <ul> <li><code>INT</code>: convert to integer. In python: int()</li> <li><code>NINT</code>: Round to nearest integer. In python: round()</li> </ul>"},{"location":"assignment/a2/22_fall_a2_q4/","title":"[2022 Fall] Assignment2-4","text":""},{"location":"assignment/a2/22_fall_a2_q4/#2022-fall-assignment2-4","title":"[2022 Fall] Assignment2-4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a2/22_fall_a2_q4/#question-convert-the-following-base-2-numbers-to-base-10","title":"Question: Convert the following base-2 numbers to base-10\u00b6","text":"<ul> <li>1011001</li> <li>110.00101</li> <li>0.01011</li> </ul>"},{"location":"assignment/a2/22_fall_a2_q4/#answer","title":"Answer:\u00b6","text":"base-2 base-10 1011001 89 110.00101 6.15625 0.01011 0.34375"},{"location":"assignment/a2/22_fall_a2_q5/","title":"[2022 Fall] Assignment2-5","text":""},{"location":"assignment/a2/22_fall_a2_q5/#2022-fall-assignment2-5","title":"[2022 Fall] Assignment2-5\u00b6","text":"<p>Course: AP3021</p> <p></p>"},{"location":"assignment/a2/22_fall_a2_q5/#question-compose-your-own-program-based-on-fig-311-and-use-it-to-determine-your-computers-machine-epsilon","title":"Question: Compose your own program based on Fig. 3.11 and use it to determine your computer\u2019s machine epsilon.\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q5/#answer","title":"Answer:\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q6/","title":"[2022 Fall] Assignment2-6","text":""},{"location":"assignment/a2/22_fall_a2_q6/#2022-fall-assignment2-6","title":"[2022 Fall] Assignment2-6\u00b6","text":"<p>Course: AP3021</p> <pre>epsilon = 1\n\nwhile (epsilon + 1 &lt;= 1)\nepsilon /= 2\n\nepsilon *= 2\n</pre>"},{"location":"assignment/a2/22_fall_a2_q6/#question","title":"Question:\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q6/#answer","title":"Answer:\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q7/","title":"[2022 Fall] Assignment2-7","text":"In\u00a0[1]: Copied! <pre># First through the machine eplison. (HW2-5)\n\ndef machineEpsilon() :\n    epsilon = 1.0\n\n    while (epsilon &gt; 0) :\n        xmin = epsilon\n        epsilon = epsilon / 2\n\n    return xmin\n\n\ndef IterMeth(val, es, maxIterator) :\n    iter = 1\n    sol = val\n    ea = 100\n    count = 1\n\n    while True :\n        preSol = sol\n        sol = (sol + (val / sol)) / 2\n        iter = iter + 1\n\n        if sol != 0 :\n            ea = abs((sol - preSol) / sol) * 100      \n\n        if (ea &lt; es or iter &gt;= maxIterator) :\n            break\n\n        print(f\"Times: {count}, Root: {sol :.4f}; Approximate relative error: {ea :.4f}%.\")\n\n        count += 1\n\n    print(\"\\nThe evaluate root:\", sol)\n\n    return sol\n\nprint(\"Machine eplison:\", machineEpsilon())\nprint(\"What the value of \\\"a\\\" we picked up -&gt; 25\\n\")\nprint(\"Start evaluate: \")\n\nIterMeth(25, machineEpsilon(), 100)\n</pre> # First through the machine eplison. (HW2-5)  def machineEpsilon() :     epsilon = 1.0      while (epsilon &gt; 0) :         xmin = epsilon         epsilon = epsilon / 2      return xmin   def IterMeth(val, es, maxIterator) :     iter = 1     sol = val     ea = 100     count = 1      while True :         preSol = sol         sol = (sol + (val / sol)) / 2         iter = iter + 1          if sol != 0 :             ea = abs((sol - preSol) / sol) * 100                if (ea &lt; es or iter &gt;= maxIterator) :             break          print(f\"Times: {count}, Root: {sol :.4f}; Approximate relative error: {ea :.4f}%.\")          count += 1      print(\"\\nThe evaluate root:\", sol)      return sol  print(\"Machine eplison:\", machineEpsilon()) print(\"What the value of \\\"a\\\" we picked up -&gt; 25\\n\") print(\"Start evaluate: \")  IterMeth(25, machineEpsilon(), 100) <pre>Machine eplison: 5e-324\nWhat the value of \"a\" we picked up -&gt; 25\n\nStart evaluate: \nTimes: 1, Root: 13.0000; Approximate relative error: 92.3077%.\nTimes: 2, Root: 7.4615; Approximate relative error: 74.2268%.\nTimes: 3, Root: 5.4060; Approximate relative error: 38.0226%.\nTimes: 4, Root: 5.0152; Approximate relative error: 7.7918%.\nTimes: 5, Root: 5.0000; Approximate relative error: 0.3045%.\nTimes: 6, Root: 5.0000; Approximate relative error: 0.0005%.\nTimes: 7, Root: 5.0000; Approximate relative error: 0.0000%.\n\nThe evaluate root: 5.0\n</pre> Out[1]: <pre>5.0</pre> <pre>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble preAbs(double), machineEpsilon(void), IterMeth(double, double, double);\n\ndouble preAbs(double x) {\nif (x &lt; 0)\nx = -x;\n\nreturn x;\n}\n\ndouble machineEpsilon(void) {\ndouble epsilon = 1.0, xmin;\n\nwhile (epsilon &gt; 0) {\nxmin = epsilon;\nepsilon = epsilon / 2;\n}\n\nreturn xmin;\n}\n\ndouble IterMeth(double val, double es, double maxit) {\ndouble iter = 0.0, sol = val, ea = 100.0, solold;\n\nwhile (1) {\nsolold = sol;\nsol = (sol + val / sol) / 2;\niter += 1.0;\n\nif (sol != 0)\nea = preAbs((sol - solold) / sol) * 100;\n\nprintf(\"%g %g\\n\", sol, ea);\n\nif ((ea &lt;= es) || (iter &gt;= maxit))\nbreak;\n}\n\nreturn sol;\n}\n\nint main() {\ndouble a;\n\nprintf(\"Input a: \");\nscanf(\"%lf\", &amp;a);\nprintf(\"%g\", IterMeth(a, machineEpsilon(), 100));\nprintf(\"\\n\");\n\nreturn 0;\n}\n</pre>"},{"location":"assignment/a2/22_fall_a2_q7/#2022-fall-assignment2-7","title":"[2022 Fall] Assignment2-7\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a2/22_fall_a2_q7/#question-x-dfracx-fracax2-then-find-the-root-of-a","title":"Question: $x = \\dfrac{x + \\frac{a}{x}}{2}$, then find the root of a.\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q7/#answer","title":"Answer:\u00b6","text":""},{"location":"assignment/a2/22_fall_a2_q7/#c-language-version","title":"C Language Version\u00b6","text":""},{"location":"assignment/a3/22_fall_a3/","title":"[2022 Fall] Assignment3","text":"In\u00a0[1]: Copied! <pre># -*-coding: utf-8 -*-\n\n\"\"\"\nCourse: AP3021\nAssignment: 3\nStudent id: 109601003\nName: \u6797\u7fa4\u8cc0\n\"\"\"\n\nimport math\n\n# Build the factorial mechanism \n\ndef factorial(n) :\n    sum = 1\n\n    for i in range(2, n + 1) :\n        sum *= i\n\n    return sum\n\n\n#Build the error criterion : \u03b5s\n\ndef countErrorCriterion(n) :\n    error_criterion = (0.5 * 10 ** (2 - n)) * 100\n\n    return error_criterion\n\n\n# Build the approximate estimate of the error : \u03b5a\n\ndef countApproximateEstimateError(current_approximation, previous_approximation) :\n    approximate_error = current_approximation - previous_approximation\n\n    if current_approximation == 0 :    # The first and second value of cosine tylor polynomial is 0.0 and 1.0; therefore we have to pass them.\n        return 999\n    else :\n        approximate_estimate_error = abs((approximate_error / current_approximation) * 100)\n\n    return approximate_estimate_error\n\n\n# Build the percent relative error : \u03b5t\n\ndef countPercentRelativeError(true_value, approximation) :\n    true_error = true_value - approximation\n    percent_relative_error = (true_error / true_value) * 100\n\n    return percent_relative_error\n\n\n# Count the machine epsilon\n\ndef countMachineEpsilon() :\n    epsilon = 1.0\n\n    while (epsilon &gt; 0) :\n        xmin = epsilon\n        epsilon = epsilon / 2\n\n    return xmin\n\n\n# Build cosine tylor polynomial\n\ndef cosineTylorPolynomial(n, x) :\n    sum = 0\n\n    try :\n        for i in range(n) : \n            sum = sum + ((-1) ** i * x ** (2 * i)) / factorial(2 * i)\n\n        return float(sum)\n    except OverflowError as exception :\n        # print('Its an Overflow error, please enter smaller degree.')\n\n        return float(sum)\n\n\n# Initialize\n\nPI = math.pi\nend_point_times = 500\nmachine_epsilon = countMachineEpsilon()\n\nprint(f\"We found that the epsilon of your machine is {machine_epsilon}.\\n\")\n\ninput_degree = input(\"Please enter the degree you want to count: \")\ninput_degree = int(input_degree)\ndegree_to_radian = input_degree * PI / 180\ntrue_value = math.cos(degree_to_radian)\n\ninput_significant_figures = input(\"Please enter the significant figures: \")\ninput_significant_figures = int(input_significant_figures)\nerror_criterion = countErrorCriterion(input_significant_figures)\n\n\nprint(f\"\\nThe degree you have entered -&gt; {input_degree}\u00b0.\")\nprint(f\"And turn in radian -&gt; {degree_to_radian}.\")\nprint(f\"The stopping criterion -&gt; {error_criterion} %.\")\nprint(f\"The end-point of this program -&gt; {end_point_times} times.\")\nprint(f\"True value of cos({degree_to_radian}) -&gt; {true_value}.\")\n\n\n# main\n\nis_start = str(input(\"\\nReady to show the result?\\n(a) Yes. (b) No.\\n\"))\n\nprint()\nif (is_start == 'a') :\n    print(\"Let's started to run the program.\\n\")\nelif (is_start == 'b') :\n    print(\"We still need to run the program.\\n\")\nelse :\n    print(\"Wrong syntax, please type \\\"a\\\" or \\\"b\\\". However, let's started.\\n\")\n\nloop_count = 0\ncurrent_approximate = 0.0\nprevious_approximate = 0.0\n\n\nwhile True :\n\n    if (loop_count == end_point_times) :\n        print(f\"Total use: {loop_count}. The runtimes are up to the limit!!!\")\n        print(\"We recommend you enter the smaller degree or significant figures!!!\")\n\n        break\n\n    previous_approximate = current_approximate\n    current_value = cosineTylorPolynomial(loop_count, degree_to_radian)\n    current_approximate = current_value\n    approximate_estimate_error = countApproximateEstimateError(current_approximate, previous_approximate)\n    percent_relative_error = countPercentRelativeError(true_value, current_value)\n\n    if (approximate_estimate_error &lt; error_criterion) :\n        loop_count += 1\n\n        print(f\"Total use {loop_count} times to get the result we want!\")\n        print(f\"The current value: {current_value}.\")\n        print(f\"The approximate estimate error: {approximate_estimate_error} %.\")\n        print(f\"The percent relative error: {percent_relative_error} %.\\n\")\n        print(f\"Here is the error that we accept!!!\")\n        \n        break\n    \n    loop_count += 1\n</pre> # -*-coding: utf-8 -*-  \"\"\" Course: AP3021 Assignment: 3 Student id: 109601003 Name: \u6797\u7fa4\u8cc0 \"\"\"  import math  # Build the factorial mechanism   def factorial(n) :     sum = 1      for i in range(2, n + 1) :         sum *= i      return sum   #Build the error criterion : \u03b5s  def countErrorCriterion(n) :     error_criterion = (0.5 * 10 ** (2 - n)) * 100      return error_criterion   # Build the approximate estimate of the error : \u03b5a  def countApproximateEstimateError(current_approximation, previous_approximation) :     approximate_error = current_approximation - previous_approximation      if current_approximation == 0 :    # The first and second value of cosine tylor polynomial is 0.0 and 1.0; therefore we have to pass them.         return 999     else :         approximate_estimate_error = abs((approximate_error / current_approximation) * 100)      return approximate_estimate_error   # Build the percent relative error : \u03b5t  def countPercentRelativeError(true_value, approximation) :     true_error = true_value - approximation     percent_relative_error = (true_error / true_value) * 100      return percent_relative_error   # Count the machine epsilon  def countMachineEpsilon() :     epsilon = 1.0      while (epsilon &gt; 0) :         xmin = epsilon         epsilon = epsilon / 2      return xmin   # Build cosine tylor polynomial  def cosineTylorPolynomial(n, x) :     sum = 0      try :         for i in range(n) :              sum = sum + ((-1) ** i * x ** (2 * i)) / factorial(2 * i)          return float(sum)     except OverflowError as exception :         # print('Its an Overflow error, please enter smaller degree.')          return float(sum)   # Initialize  PI = math.pi end_point_times = 500 machine_epsilon = countMachineEpsilon()  print(f\"We found that the epsilon of your machine is {machine_epsilon}.\\n\")  input_degree = input(\"Please enter the degree you want to count: \") input_degree = int(input_degree) degree_to_radian = input_degree * PI / 180 true_value = math.cos(degree_to_radian)  input_significant_figures = input(\"Please enter the significant figures: \") input_significant_figures = int(input_significant_figures) error_criterion = countErrorCriterion(input_significant_figures)   print(f\"\\nThe degree you have entered -&gt; {input_degree}\u00b0.\") print(f\"And turn in radian -&gt; {degree_to_radian}.\") print(f\"The stopping criterion -&gt; {error_criterion} %.\") print(f\"The end-point of this program -&gt; {end_point_times} times.\") print(f\"True value of cos({degree_to_radian}) -&gt; {true_value}.\")   # main  is_start = str(input(\"\\nReady to show the result?\\n(a) Yes. (b) No.\\n\"))  print() if (is_start == 'a') :     print(\"Let's started to run the program.\\n\") elif (is_start == 'b') :     print(\"We still need to run the program.\\n\") else :     print(\"Wrong syntax, please type \\\"a\\\" or \\\"b\\\". However, let's started.\\n\")  loop_count = 0 current_approximate = 0.0 previous_approximate = 0.0   while True :      if (loop_count == end_point_times) :         print(f\"Total use: {loop_count}. The runtimes are up to the limit!!!\")         print(\"We recommend you enter the smaller degree or significant figures!!!\")          break      previous_approximate = current_approximate     current_value = cosineTylorPolynomial(loop_count, degree_to_radian)     current_approximate = current_value     approximate_estimate_error = countApproximateEstimateError(current_approximate, previous_approximate)     percent_relative_error = countPercentRelativeError(true_value, current_value)      if (approximate_estimate_error &lt; error_criterion) :         loop_count += 1          print(f\"Total use {loop_count} times to get the result we want!\")         print(f\"The current value: {current_value}.\")         print(f\"The approximate estimate error: {approximate_estimate_error} %.\")         print(f\"The percent relative error: {percent_relative_error} %.\\n\")         print(f\"Here is the error that we accept!!!\")                  break          loop_count += 1 <pre>We found that the epsilon of your machine is 5e-324.\n\n</pre> <pre>\n---------------------------------------------------------------------------\nStdinNotImplementedError                  Traceback (most recent call last)\nCell In[1], line 89\n     85 machine_epsilon = countMachineEpsilon()\n     87 print(f\"We found that the epsilon of your machine is {machine_epsilon}.\\n\")\n---&gt; 89 input_degree = input(\"Please enter the degree you want to count: \")\n     90 input_degree = int(input_degree)\n     91 degree_to_radian = input_degree * PI / 180\n\nFile /opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/ipykernel/kernelbase.py:1201, in Kernel.raw_input(self, prompt)\n   1199 if not self._allow_stdin:\n   1200     msg = \"raw_input was called, but this frontend does not support input requests.\"\n-&gt; 1201     raise StdinNotImplementedError(msg)\n   1202 return self._input_request(\n   1203     str(prompt),\n   1204     self._parent_ident[\"shell\"],\n   1205     self.get_parent(\"shell\"),\n   1206     password=False,\n   1207 )\n\nStdinNotImplementedError: raw_input was called, but this frontend does not support input requests.</pre>"},{"location":"assignment/a3/22_fall_a3/#2022-fall-assignment3","title":"[2022 Fall] Assignment3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q1/","title":"[2022 Fall] Assignment4-1","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport math\nimport numpy as np\nimport pandas as pd\nimport os\n</pre> import matplotlib.pyplot as plt import math import numpy as np import pandas as pd import os In\u00a0[2]: Copied! <pre># plot y = sin(x) and y = x^3\n\nx = np.linspace(-10, 10, 500)\ny1 = np.sin(x)\ny2 = x ** 3\n\nplt.plot(x, y1)\nplt.plot(x, y2)\n\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)\n\nplt.title(\"Technique of sin(x) = x^3\")\nplt.grid()\nplt.legend([\"sin(x)\", \"x^3\"], loc =\"lower right\")\nplt.axhline(y = 0, color='k', linestyle='-')\n\n# plt.savefig(\"./src/imgs/A4_1_a-1.png\", dpi=300)\n\nplt.show()\n</pre> # plot y = sin(x) and y = x^3  x = np.linspace(-10, 10, 500) y1 = np.sin(x) y2 = x ** 3  plt.plot(x, y1) plt.plot(x, y2)  plt.xlim(-10, 10) plt.ylim(-10, 10)  plt.title(\"Technique of sin(x) = x^3\") plt.grid() plt.legend([\"sin(x)\", \"x^3\"], loc =\"lower right\") plt.axhline(y = 0, color='k', linestyle='-')  # plt.savefig(\"./src/imgs/A4_1_a-1.png\", dpi=300)  plt.show() In\u00a0[3]: Copied! <pre># plot y = sin(x) - x ^ 3\n# set xl = 0.5; xu = 1.0\n\nx = np.linspace(0.0, 1.0, 500)\ny = np.sin(x) - x ** 3\n\nplt.plot(x, y)\n\nplt.xlim(0.49, 1.01)\nplt.ylim(-0.25, 0.5)\n\nplt.title(\"Technique of y = sin(x) - x^3\")\nplt.grid()\nplt.legend([\"sin(x) - x^3\"], loc =\"upper right\")\nplt.axhline(y = 0, color='k', linestyle='-')\n\n# plt.savefig(\"./src/imgs/A4_1_a-2.png\", dpi=300)\n\nplt.show()\n</pre> # plot y = sin(x) - x ^ 3 # set xl = 0.5; xu = 1.0  x = np.linspace(0.0, 1.0, 500) y = np.sin(x) - x ** 3  plt.plot(x, y)  plt.xlim(0.49, 1.01) plt.ylim(-0.25, 0.5)  plt.title(\"Technique of y = sin(x) - x^3\") plt.grid() plt.legend([\"sin(x) - x^3\"], loc =\"upper right\") plt.axhline(y = 0, color='k', linestyle='-')  # plt.savefig(\"./src/imgs/A4_1_a-2.png\", dpi=300)  plt.show() In\u00a0[4]: Copied! <pre># Bisection Program\n\ndef f(x) :\n    ans = np.sin(x) - x ** 3\n    return ans\n\ndef count_ea(new_x_root, old_x_root) :\n\n    if (old_x_root == -1) : # jump out the first data.\n        return 9999\n    else :\n        ea = abs((new_x_root - old_x_root) / new_x_root)\n        ea = ea * 100   # turn into percent\n    \n    return ea\n\ndef bisection(x_lowwer, x_upper, es, x_root, iter_max) :\n    iter_count = 0\n    \n    while True :\n        last_x_root = x_root\n        x_root = (x_lowwer + x_upper) / 2\n        iter_count += 1\n        ea = count_ea(x_root, last_x_root)\n        temp = f(x_lowwer) * f(x_root)\n\n        if (temp &lt; 0) :\n            x_upper = x_root\n        elif(temp &gt; 0) :\n            x_lowwer = x_root\n        else :\n            ea = 0.0    \n            # return x_root\n\n        print(\"count:\", iter_count, \"root:\", x_root, \"ea:\", ea)\n        \n        if ea &lt; es or iter_count &gt;= iter_max:\n            return x_root\n</pre> # Bisection Program  def f(x) :     ans = np.sin(x) - x ** 3     return ans  def count_ea(new_x_root, old_x_root) :      if (old_x_root == -1) : # jump out the first data.         return 9999     else :         ea = abs((new_x_root - old_x_root) / new_x_root)         ea = ea * 100   # turn into percent          return ea  def bisection(x_lowwer, x_upper, es, x_root, iter_max) :     iter_count = 0          while True :         last_x_root = x_root         x_root = (x_lowwer + x_upper) / 2         iter_count += 1         ea = count_ea(x_root, last_x_root)         temp = f(x_lowwer) * f(x_root)          if (temp &lt; 0) :             x_upper = x_root         elif(temp &gt; 0) :             x_lowwer = x_root         else :             ea = 0.0                 # return x_root          print(\"count:\", iter_count, \"root:\", x_root, \"ea:\", ea)                  if ea &lt; es or iter_count &gt;= iter_max:             return x_root In\u00a0[5]: Copied! <pre>es = 2.0  # 2%\nx_lowwer = 0.5\nx_upper = 1.0\nx_root = -1\niter_max = 500\n\nans = bisection(x_lowwer, x_upper, es, x_root, iter_max)\n\nprint(\"\\nThe approximate ans:\", ans)\n</pre> es = 2.0  # 2% x_lowwer = 0.5 x_upper = 1.0 x_root = -1 iter_max = 500  ans = bisection(x_lowwer, x_upper, es, x_root, iter_max)  print(\"\\nThe approximate ans:\", ans) <pre>count: 1 root: 0.75 ea: 9999\ncount: 2 root: 0.875 ea: 14.285714285714285\ncount: 3 root: 0.9375 ea: 6.666666666666667\ncount: 4 root: 0.90625 ea: 3.4482758620689653\ncount: 5 root: 0.921875 ea: 1.694915254237288\n\nThe approximate ans: 0.921875\n</pre> In\u00a0[6]: Copied! <pre># Also perform an error check by substituting your final answer into the original equation in (b) \n\ndef count_true_error(true_value, approximation) :\n    return true_value - approximation\n\ndef count_et(true_value, approximation) :\n    true_error = true_value - approximation\n    et = (true_error / true_value) * 100\n\n    return et\n\ntrue_value = 0.9286263  # calculator\n\net = count_et(true_value, ans)\nprint(\"True error:\", et)\n</pre> # Also perform an error check by substituting your final answer into the original equation in (b)   def count_true_error(true_value, approximation) :     return true_value - approximation  def count_et(true_value, approximation) :     true_error = true_value - approximation     et = (true_error / true_value) * 100      return et  true_value = 0.9286263  # calculator  et = count_et(true_value, ans) print(\"True error:\", et) <pre>True error: 0.7270201156267075\n</pre>"},{"location":"assignment/a4/22_fall_a4_q1/#2022-fall-assignment4-1","title":"[2022 Fall] Assignment4-1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q1/#4-11","title":"4-1.1:\u00b6","text":"<p>Locate the first nontrivial root of $sin(x) = x^3$ where x is in radians.</p> <ol> <li>Graphical technique (Python)</li> <li>Bisection program (\ud835\udc65\ud835\udc59 = 0.5, \ud835\udc65\ud835\udc62 = 1, \ud835\udc64h\ud835\udc52\ud835\udc5b \ud835\udf00\ud835\udc4e &lt; \ud835\udf00\ud835\udc60 = 2%) (Python)</li> </ol>"},{"location":"assignment/a4/22_fall_a4_q1/#4-12","title":"4-1.2\u00b6","text":"<p>Also perform an error check by substituting your final answer into the original equation in 1-2 (calculate true error \u53ef\u4e0d\u7528\u6253\u7a0b\u5f0f)</p>"},{"location":"assignment/a4/22_fall_a4_q1/#from-the-calculator","title":"from the calculator\u00b6","text":"<p>The root of $y = sin(x) - x^3$ is $\u22120.9286263, 0, 0.9286263$</p> <p></p> <p>And from the previous conduction, true value is $0.9286263$ and the approximation is $0.7421875$.</p> <p>Therefore we get the true percent error is $20.07683822868252\\%$</p>"},{"location":"assignment/a4/22_fall_a4_q2/","title":"[2022 Fall] Assignment4-2","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport math\nimport numpy as np\nimport pandas as pd\nimport os\n</pre> import matplotlib.pyplot as plt import math import numpy as np import pandas as pd import os In\u00a0[2]: Copied! <pre>def f(temperature, osf) :\n    absolute_temperature = temperature + 273.15 # Ta\n\n    ans = ((-8.621949 * 10 ** 11) / absolute_temperature ** 4) \\\n        + ((1.243800  * 10 ** 10) / absolute_temperature ** 3) \\\n        + ((-6.642308 * 10 **  7) / absolute_temperature ** 2) \\\n        + ((1.575701  * 10 **  5) / absolute_temperature)      \\\n        - 139.34411 - math.log(osf)\n    \n    return ans\n</pre> def f(temperature, osf) :     absolute_temperature = temperature + 273.15 # Ta      ans = ((-8.621949 * 10 ** 11) / absolute_temperature ** 4) \\         + ((1.243800  * 10 ** 10) / absolute_temperature ** 3) \\         + ((-6.642308 * 10 **  7) / absolute_temperature ** 2) \\         + ((1.575701  * 10 **  5) / absolute_temperature)      \\         - 139.34411 - math.log(osf)          return ans In\u00a0[3]: Copied! <pre>def count_et(true_value, approximation) :\n    true_error = true_value - approximation\n    et = (true_error / true_value) * 100\n\n    return et\n</pre> def count_et(true_value, approximation) :     true_error = true_value - approximation     et = (true_error / true_value) * 100      return et In\u00a0[4]: Copied! <pre>def count_ea(new_x_root, old_x_root) :\n\n    if (old_x_root == -1) : # jump out the first data.\n        return 9999\n    else :\n        ea = abs((new_x_root - old_x_root) / new_x_root)\n        ea = ea * 100   # turn into percent\n        \n        return ea\n</pre> def count_ea(new_x_root, old_x_root) :      if (old_x_root == -1) : # jump out the first data.         return 9999     else :         ea = abs((new_x_root - old_x_root) / new_x_root)         ea = ea * 100   # turn into percent                  return ea In\u00a0[5]: Copied! <pre>def count_iter_times(x_lowwer, x_upper, Ead) :\n    iter_times = math.log(((x_upper - x_lowwer) / Ead), 2)\n\n    return iter_times\n</pre> def count_iter_times(x_lowwer, x_upper, Ead) :     iter_times = math.log(((x_upper - x_lowwer) / Ead), 2)      return iter_times In\u00a0[6]: Copied! <pre>def bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count) :\n    iter_times = count_iter_times(x_lowwer, x_upper, Ead)\n    print(\"Iterator at least:\", iter_times, \"times.\")\n    x_root = -1\n    \n    while True :\n        last_x_root = x_root\n        x_root = (x_lowwer + x_upper) / 2\n        iter_count += 1\n        temp = f(x_lowwer, osf) * f(x_root, osf)\n        # print(temp)\n\n        if (temp &lt; 0) :\n            x_upper = x_root\n            # print(\"here\")\n        elif(temp &gt; 0) :\n            x_lowwer = x_root\n            # print(\"here2\")\n        else :\n            return x_root\n\n        # how to get the true_value?\n        # true_value = \n\n        # et = (count_et(true_value, x_root))\n\n        ea = count_ea(x_root, last_x_root)\n\n        print(\"count:\", iter_count, \"root:\", x_root, \"ea\", ea)\n        # print(x_lowwer, x_upper)\n        \n        if iter_count &gt;= iter_times or iter_count &gt;= iter_max:\n            temperature = x_root + 273.15\n            \n            print(f\"if the os is {osf}\\nI iterate {iter_count} times\\nThe temperature is {temperature}K\")\n            return x_root\n</pre> def bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count) :     iter_times = count_iter_times(x_lowwer, x_upper, Ead)     print(\"Iterator at least:\", iter_times, \"times.\")     x_root = -1          while True :         last_x_root = x_root         x_root = (x_lowwer + x_upper) / 2         iter_count += 1         temp = f(x_lowwer, osf) * f(x_root, osf)         # print(temp)          if (temp &lt; 0) :             x_upper = x_root             # print(\"here\")         elif(temp &gt; 0) :             x_lowwer = x_root             # print(\"here2\")         else :             return x_root          # how to get the true_value?         # true_value =           # et = (count_et(true_value, x_root))          ea = count_ea(x_root, last_x_root)          print(\"count:\", iter_count, \"root:\", x_root, \"ea\", ea)         # print(x_lowwer, x_upper)                  if iter_count &gt;= iter_times or iter_count &gt;= iter_max:             temperature = x_root + 273.15                          print(f\"if the os is {osf}\\nI iterate {iter_count} times\\nThe temperature is {temperature}K\")             return x_root In\u00a0[7]: Copied! <pre>x_lowwer = 0\nx_upper = 40\nEad = 0.05\nosf = 8\niter_max = 500\niter_count = 0\n\nans = bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count)\n</pre> x_lowwer = 0 x_upper = 40 Ead = 0.05 osf = 8 iter_max = 500 iter_count = 0  ans = bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count) <pre>Iterator at least: 9.643856189774725 times.\ncount: 1 root: 20.0 ea 9999\ncount: 2 root: 30.0 ea 33.33333333333333\ncount: 3 root: 25.0 ea 20.0\ncount: 4 root: 27.5 ea 9.090909090909092\ncount: 5 root: 26.25 ea 4.761904761904762\ncount: 6 root: 26.875 ea 2.3255813953488373\ncount: 7 root: 26.5625 ea 1.1764705882352942\ncount: 8 root: 26.71875 ea 0.5847953216374269\ncount: 9 root: 26.796875 ea 0.2915451895043732\ncount: 10 root: 26.7578125 ea 0.145985401459854\nif the os is 8\nI iterate 10 times\nThe temperature is 299.9078125K\n</pre> In\u00a0[8]: Copied! <pre>x_lowwer = 0\nx_upper = 40\nEad = 0.05\nosf = 10\niter_max = 500\niter_count = 0\n\nprint(\"Osf:\", osf)\nans = bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count)\nprint(ans)\n</pre> x_lowwer = 0 x_upper = 40 Ead = 0.05 osf = 10 iter_max = 500 iter_count = 0  print(\"Osf:\", osf) ans = bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count) print(ans) <pre>Osf: 10\nIterator at least: 9.643856189774725 times.\ncount: 1 root: 20.0 ea 9999\ncount: 2 root: 10.0 ea 100.0\ncount: 3 root: 15.0 ea 33.33333333333333\ncount: 4 root: 17.5 ea 14.285714285714285\ncount: 5 root: 16.25 ea 7.6923076923076925\ncount: 6 root: 15.625 ea 4.0\ncount: 7 root: 15.3125 ea 2.0408163265306123\ncount: 8 root: 15.46875 ea 1.0101010101010102\ncount: 9 root: 15.390625 ea 0.5076142131979695\ncount: 10 root: 15.3515625 ea 0.2544529262086514\nif the os is 10\nI iterate 10 times\nThe temperature is 288.5015625K\n15.3515625\n</pre> In\u00a0[9]: Copied! <pre>x_lowwer = 0\nx_upper = 40\nEad = 0.05\nosf = 12\niter_max = 500\niter_count = 0\n\nprint(\"Osf:\", osf)\nans = bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count)\nprint(ans)\n</pre> x_lowwer = 0 x_upper = 40 Ead = 0.05 osf = 12 iter_max = 500 iter_count = 0  print(\"Osf:\", osf) ans = bisection(x_lowwer, x_upper, Ead, osf, iter_max, iter_count) print(ans) <pre>Osf: 12\nIterator at least: 9.643856189774725 times.\ncount: 1 root: 20.0 ea 9999\ncount: 2 root: 10.0 ea 100.0\ncount: 3 root: 5.0 ea 100.0\ncount: 4 root: 7.5 ea 33.33333333333333\ncount: 5 root: 6.25 ea 20.0\ncount: 6 root: 6.875 ea 9.090909090909092\ncount: 7 root: 7.1875 ea 4.3478260869565215\ncount: 8 root: 7.34375 ea 2.127659574468085\ncount: 9 root: 7.421875 ea 1.0526315789473684\ncount: 10 root: 7.4609375 ea 0.5235602094240838\nif the os is 12\nI iterate 10 times\nThe temperature is 280.6109375K\n7.4609375\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/a4/22_fall_a4_q2/#2022-fall-assignment4-2","title":"[2022 Fall] Assignment4-2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q2/#4-2-1","title":"4-2-1\u00b6","text":"<p>How many bisection iterations would be required to determine temperature to an absolute error of 0.05\u00b0C? (\ud835\udc65\ud835\udc59 = 0\u00b0C, \ud835\udc65\ud835\udc62 = 40\u00b0C)</p> <p></p>"},{"location":"assignment/a4/22_fall_a4_q2/#4-2-2","title":"4-2-2\u00b6","text":"<p>\u5ef6\u7e8c(1). Bisection program. (\ud835\udc42\ud835\udc60\ud835\udc53 = 8, 10, \ud835\udc4e\ud835\udc5b\ud835\udc51 12\ud835\udc5a\ud835\udc54/\ud835\udc3f) (Python) PS : \u6eab\u5ea6\u8acb\u5e36\u7d55\u5c0d\u6eab\u6a19</p>"},{"location":"assignment/a4/22_fall_a4_q2/#osf-8","title":"Osf = 8\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q2/#osf-10","title":"Osf = 10\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q2/#osf-12","title":"Osf = 12\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q3/","title":"[2022 Fall] Assignment4-3","text":"In\u00a0[1]: Copied! <pre>def f(x) :\n    ans = x ** 10 - 1\n\n    return ans\n</pre> def f(x) :     ans = x ** 10 - 1      return ans In\u00a0[2]: Copied! <pre>def count_ea(new_x_root, old_x_root) :\n\n    if (old_x_root == -1) : # jump out the first data.\n        return 9999\n    else :\n        ea = abs((new_x_root - old_x_root) / new_x_root)\n        ea = ea * 100   # turn into percent\n    \n    return ea\n</pre> def count_ea(new_x_root, old_x_root) :      if (old_x_root == -1) : # jump out the first data.         return 9999     else :         ea = abs((new_x_root - old_x_root) / new_x_root)         ea = ea * 100   # turn into percent          return ea In\u00a0[3]: Copied! <pre>def count_et(true_value, approximation) :\n    true_error = true_value - approximation\n    et = abs((true_error / true_value) * 100)\n\n    return et\n</pre> def count_et(true_value, approximation) :     true_error = true_value - approximation     et = abs((true_error / true_value) * 100)      return et In\u00a0[4]: Copied! <pre>def ModFalsePos(x_lowwer, x_upper, x_root, es, iter_max, iter_count_list, ea_list, et_list) :\n    iter_count = 0\n    iter_upper, iter_lowwer = 0, 0\n    lowwer_value = f(x_lowwer)\n    upper_value = f(x_upper)\n\n    while True :\n        last_x_root = x_root\n        x_root = x_upper - upper_value * (x_lowwer - x_upper) / (lowwer_value - upper_value)\n        root_value = f(x_root)\n\n        iter_count += 1\n        iter_count_list.append(iter_count)\n\n        if (x_root != 0) :\n            ea = count_ea(x_root, last_x_root)\n            ea_list.append(ea)\n\n        true_value = 1\n\n        et = count_et(true_value, x_root)\n        et_list.append(et)\n\n        temp = lowwer_value * root_value\n\n        if (temp &lt; 0) :\n            x_upper = x_root\n            upper_value = f(x_upper)\n            iter_upper = 0\n            iter_lowwer += 1\n\n            if (iter_lowwer &gt;= 2) :\n                lowwer_value /= 2\n        elif (temp &gt; 0) :\n            x_lowwer = x_root\n            lowwer_value = f(x_lowwer)\n            iter_lowwer = 0\n            iter_upper += 1\n\n            if (iter_upper &gt;= 2) :\n                upper_value /= 2\n        else :\n            ea = 0.0\n        \n        print(\"count\", iter_count, \"ea\", ea, \"root\", x_root)\n        \n        if (ea &lt; es or iter_count &gt;= iter_max) :\n            return x_root\n</pre> def ModFalsePos(x_lowwer, x_upper, x_root, es, iter_max, iter_count_list, ea_list, et_list) :     iter_count = 0     iter_upper, iter_lowwer = 0, 0     lowwer_value = f(x_lowwer)     upper_value = f(x_upper)      while True :         last_x_root = x_root         x_root = x_upper - upper_value * (x_lowwer - x_upper) / (lowwer_value - upper_value)         root_value = f(x_root)          iter_count += 1         iter_count_list.append(iter_count)          if (x_root != 0) :             ea = count_ea(x_root, last_x_root)             ea_list.append(ea)          true_value = 1          et = count_et(true_value, x_root)         et_list.append(et)          temp = lowwer_value * root_value          if (temp &lt; 0) :             x_upper = x_root             upper_value = f(x_upper)             iter_upper = 0             iter_lowwer += 1              if (iter_lowwer &gt;= 2) :                 lowwer_value /= 2         elif (temp &gt; 0) :             x_lowwer = x_root             lowwer_value = f(x_lowwer)             iter_lowwer = 0             iter_upper += 1              if (iter_upper &gt;= 2) :                 upper_value /= 2         else :             ea = 0.0                  print(\"count\", iter_count, \"ea\", ea, \"root\", x_root)                  if (ea &lt; es or iter_count &gt;= iter_max) :             return x_root In\u00a0[5]: Copied! <pre>x_lowwer = 0\nx_upper = 1.3\nx_root = -1\ntrue_percent_relative_error = 0.01 # 0.01%\niter_max = 500\niter_count_list = []\nea_list = []\net_list = []\n\nx_root = ModFalsePos(x_lowwer, x_upper, x_root, true_percent_relative_error, iter_max, iter_count_list, ea_list, et_list)\n\nprint(\"\\nthe approximate root:\", x_root)\n</pre> x_lowwer = 0 x_upper = 1.3 x_root = -1 true_percent_relative_error = 0.01 # 0.01% iter_max = 500 iter_count_list = [] ea_list = [] et_list = []  x_root = ModFalsePos(x_lowwer, x_upper, x_root, true_percent_relative_error, iter_max, iter_count_list, ea_list, et_list)  print(\"\\nthe approximate root:\", x_root) <pre>count 1 ea 9999 root 0.09429959537232735\ncount 2 ea 48.11829867483983 root 0.1817588725190793\ncount 3 ea 45.42056803211995 root 0.33301715676712107\ncount 4 ea 40.89596253644958 root 0.5634423147022628\ncount 5 ea 33.42786332211735 root 0.8463635731395354\ncount 6 ea 21.261925768742138 root 1.074910177068493\ncount 7 ea 13.687880507544154 root 0.9454923183277778\ncount 8 ea 3.796168994661739 root 0.9828011093189348\ncount 9 ea 2.120752777330274 root 1.0040954923602121\ncount 10 ea 0.44213894808025606 root 0.9996755374546943\ncount 11 ea 0.03185260045655777 root 0.9999940615677148\ncount 12 ea 0.0011642999121982691 root 1.0000057046332558\n\nthe approximate root: 1.0000057046332558\n</pre> In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[7]: Copied! <pre># plot ea and et\n\nea_list[0] = 99     #the first element is neglected.\nx = iter_count_list\ny1 = ea_list\ny2 = et_list\n\nplt.plot(x, y1)\nplt.plot(x, y2)\n\nplt.xlim(0.9, 13)\nplt.ylim(0, 100)\nplt.xlabel(\"iteration\")\nplt.ylabel(\"percent\")\n\nplt.title(\"et and ea versus number of the iterations\")\nplt.grid()\nplt.legend([\"ea\", \"et\"], loc =\"upper right\")\n\nplt.savefig(\"./src/imgs/A4_4_2.png\", dpi=300)\n\nplt.show()\n</pre> # plot ea and et  ea_list[0] = 99     #the first element is neglected. x = iter_count_list y1 = ea_list y2 = et_list  plt.plot(x, y1) plt.plot(x, y2)  plt.xlim(0.9, 13) plt.ylim(0, 100) plt.xlabel(\"iteration\") plt.ylabel(\"percent\")  plt.title(\"et and ea versus number of the iterations\") plt.grid() plt.legend([\"ea\", \"et\"], loc =\"upper right\")  plt.savefig(\"./src/imgs/A4_4_2.png\", dpi=300)  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/a4/22_fall_a4_q3/#2022-fall-assignment4-3","title":"[2022 Fall] Assignment4-3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q3/#4-3-1","title":"4-3-1\u00b6","text":"<p>Develop a user-friendly subprogram for the modified false-position method based on Fig. 5.15. Test the program by determining the root of the function described in Example 5.6. Perform a number of runs until the true percent relative error falls below 0.01%. (Python)</p>"},{"location":"assignment/a4/22_fall_a4_q3/#4-3-2","title":"4-3-2\u00b6","text":"<p>Plot the true and approximate percent relative errors versus number of iterations. (Python)</p>"},{"location":"assignment/a4/22_fall_a4_q4/","title":"[2022 Fall] Assignment4-4","text":"In\u00a0[1]: Copied! <pre>import math\nimport matplotlib.pyplot as plt\n</pre> import math import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>def g(x) :\n    ans = math.sqrt((1.7 * x + 2.5) / 0.9)\n\n    return ans\n</pre> def g(x) :     ans = math.sqrt((1.7 * x + 2.5) / 0.9)      return ans In\u00a0[3]: Copied! <pre>def fix_point(x0, es, iter_max, ea_list, iter_count_list) :\n    x_root = x0\n    iter_count = 0\n\n    while True :\n        last_x_root = x_root\n        x_root = g(last_x_root)\n        iter_count += 1\n        iter_count_list.append(iter_count)\n\n        if (x_root != 0) :\n            ea = abs((x_root - last_x_root) / x_root) * 100\n            ea_list.append(ea)\n\n        print(\"iter time:\", iter_count, \",ea =\", ea)\n        if (ea &lt; es or iter_count &gt;= iter_max) :\n            return x_root\n</pre> def fix_point(x0, es, iter_max, ea_list, iter_count_list) :     x_root = x0     iter_count = 0      while True :         last_x_root = x_root         x_root = g(last_x_root)         iter_count += 1         iter_count_list.append(iter_count)          if (x_root != 0) :             ea = abs((x_root - last_x_root) / x_root) * 100             ea_list.append(ea)          print(\"iter time:\", iter_count, \",ea =\", ea)         if (ea &lt; es or iter_count &gt;= iter_max) :             return x_root In\u00a0[4]: Copied! <pre>x0 = 5\nes = 0.01\niter_max = 500\nea_list = []\niter_count_list = []\n\nprint(\"\\nThe approximate ans:\", fix_point(x0, es, iter_max, ea_list, iter_count_list))\n# print(ea_list)\n# print(iter_count)\n</pre> x0 = 5 es = 0.01 iter_max = 500 ea_list = [] iter_count_list = []  print(\"\\nThe approximate ans:\", fix_point(x0, es, iter_max, ea_list, iter_count_list)) # print(ea_list) # print(iter_count) <pre>iter time: 1 ,ea = 43.019388386838855\niter time: 2 ,ea = 14.140958348733184\niter time: 3 ,ea = 4.6679854963306715\niter time: 4 ,ea = 1.541483060629453\niter time: 5 ,ea = 0.5090321399985364\niter time: 6 ,ea = 0.16809099521169962\niter time: 7 ,ea = 0.05550608802781297\niter time: 8 ,ea = 0.01832887042630157\niter time: 9 ,ea = 0.006052438895087782\n\nThe approximate ans: 2.8601897496224673\n</pre> In\u00a0[5]: Copied! <pre># plot\n\nx = iter_count_list\ny = ea_list\n\nplt.plot(x, y)\n\nplt.xlim(0, 10)\nplt.ylim(0, 50)\n\nplt.title(\"Growing of ea by fixed point iteration\")\nplt.grid()\nplt.legend([\"ea\"], loc =\"upper right\")\n\nplt.savefig(\"./src/imgs/A4_4_a.png\", dpi=300)\n\nplt.show()\n</pre> # plot  x = iter_count_list y = ea_list  plt.plot(x, y)  plt.xlim(0, 10) plt.ylim(0, 50)  plt.title(\"Growing of ea by fixed point iteration\") plt.grid() plt.legend([\"ea\"], loc =\"upper right\")  plt.savefig(\"./src/imgs/A4_4_a.png\", dpi=300)  plt.show() In\u00a0[6]: Copied! <pre>def f(x) :\n    ans = -0.9 * x ** 2 + 1.7 * x + 2.5\n\n    return ans\n</pre> def f(x) :     ans = -0.9 * x ** 2 + 1.7 * x + 2.5      return ans In\u00a0[7]: Copied! <pre>def f_prime(x) :\n    ans = -1.8 * x + 1.7\n\n    return ans\n</pre> def f_prime(x) :     ans = -1.8 * x + 1.7      return ans In\u00a0[8]: Copied! <pre>def newton_raphson(x0, es, iter_max, ea_list, iter_count_list) :\n    iter_count = 0\n\n    while True :\n        next_x = x0 - (f(x0) / f_prime(x0))\n        x_root = next_x\n\n        iter_count += 1\n        iter_count_list.append(iter_count)\n\n        ea = abs((x_root - x0) / x_root) * 100\n        x0 = x_root\n        ea_list.append(ea)\n        \n\n        print(\"iter time:\", iter_count, \",ea =\", ea)\n\n        if (ea &lt; es or iter_count &gt;= iter_max) :\n            return x_root\n</pre> def newton_raphson(x0, es, iter_max, ea_list, iter_count_list) :     iter_count = 0      while True :         next_x = x0 - (f(x0) / f_prime(x0))         x_root = next_x          iter_count += 1         iter_count_list.append(iter_count)          ea = abs((x_root - x0) / x_root) * 100         x0 = x_root         ea_list.append(ea)                   print(\"iter time:\", iter_count, \",ea =\", ea)          if (ea &lt; es or iter_count &gt;= iter_max) :             return x_root In\u00a0[9]: Copied! <pre>x0 = 5\nes = 0.01\niter_max = 500\nea_list = []\niter_count_list = []\n\nprint(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max, ea_list, iter_count_list))\n</pre> x0 = 5 es = 0.01 iter_max = 500 ea_list = [] iter_count_list = []  print(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max, ea_list, iter_count_list)) <pre>iter time: 1 ,ea = 46.0\niter time: 2 ,ea = 17.108052750727655\niter time: 3 ,ea = 2.209254593287688\niter time: 4 ,ea = 0.03644225367328207\niter time: 5 ,ea = 9.913886563630006e-06\n\nThe approximate ans: 2.8601044055074283\n</pre> In\u00a0[10]: Copied! <pre># plot\n\nx = iter_count_list\ny = ea_list\n\nplt.plot(x, y)\n\nplt.xlim(0, 5)\nplt.ylim(0, 50)\n\nplt.title(\"Growing of ea by Newton Raphson\")\nplt.grid()\nplt.legend([\"ea\"], loc =\"upper right\")\n\nplt.savefig(\"./src/imgs/A4_4_b.png\", dpi=300)\n\nplt.show()\n</pre> # plot  x = iter_count_list y = ea_list  plt.plot(x, y)  plt.xlim(0, 5) plt.ylim(0, 50)  plt.title(\"Growing of ea by Newton Raphson\") plt.grid() plt.legend([\"ea\"], loc =\"upper right\")  plt.savefig(\"./src/imgs/A4_4_b.png\", dpi=300)  plt.show()"},{"location":"assignment/a4/22_fall_a4_q4/#2022-fall-assignment4-4","title":"[2022 Fall] Assignment4-4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q4/#4-4-a","title":"4-4-a\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q4/#fixed-point-iteration","title":"Fixed-point iteration\u00b6","text":"<p>to determine a root of $f(x) = -0.9x^2 + 1.7x + 2.5$ using $x_0 = 5.0$. Perform the computation until \ud835\udf00\ud835\udc4e is less than \ud835\udf00\ud835\udc60 = 0.01%. Also perform an error check of your final answer(plot the \ud835\udf00\ud835\udc4e as the iteration growing)</p> <p></p>"},{"location":"assignment/a4/22_fall_a4_q4/#4-4-b","title":"4-4-b\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q4/#the-newton-raphson-method","title":"the Newton-Raphson method\u00b6","text":"<p>to determine a root of $f(x) = -0.9x^2 + 1.7x + 2.5$ using $x_0 = 5.0$. Perform the computation until \ud835\udf00\ud835\udc4e is less than \ud835\udf00\ud835\udc60 = 0.01%. Also perform an error check of your final answer(plot the \ud835\udf00\ud835\udc4e as the iteration growing)</p> <p></p>"},{"location":"assignment/a4/22_fall_a4_q5/","title":"[2022 Fall] Assignment4-5","text":"In\u00a0[1]: Copied! <pre>import math\n</pre> import math In\u00a0[2]: Copied! <pre>def f(x) :\n    e = math.e\n    ans = ((e ** (-0.5 * x)) * (4 - x)) - 2\n\n    return ans\n\ndef f_prime(x) :\n    e = math.e\n    ans = (-0.5 * (e ** (-0.5 * x)) * (4 - x)) - (e ** (-0.5 * x))\n\n    return ans\n\ndef newton_raphson(x0, es, iter_max) :\n    iter_count = 0\n    iter_count_list = []\n    x_root = x0\n    print(\"x0 =\", x0)\n    print()\n\n    while True :\n        last_x_root = x_root\n\n        try :\n            x_root = last_x_root - (f(x_root) / f_prime(x_root))\n        except :\n            print(\"total use\", iter_count, \"times.\")\n            return \"Divergence\"\n\n        iter_count += 1\n        iter_count_list.append(iter_count)\n        if x_root != 0 :\n            ea = abs((x_root - last_x_root) / x_root) * 100        \n\n        print(\"iter time:\", iter_count, \",ea =\", ea, \"root:\", x_root)\n\n        if (ea &lt; es or iter_count &gt;= iter_max) :\n            print(\"total use\", iter_count, \"times.\")\n            return x_root\n</pre> def f(x) :     e = math.e     ans = ((e ** (-0.5 * x)) * (4 - x)) - 2      return ans  def f_prime(x) :     e = math.e     ans = (-0.5 * (e ** (-0.5 * x)) * (4 - x)) - (e ** (-0.5 * x))      return ans  def newton_raphson(x0, es, iter_max) :     iter_count = 0     iter_count_list = []     x_root = x0     print(\"x0 =\", x0)     print()      while True :         last_x_root = x_root          try :             x_root = last_x_root - (f(x_root) / f_prime(x_root))         except :             print(\"total use\", iter_count, \"times.\")             return \"Divergence\"          iter_count += 1         iter_count_list.append(iter_count)         if x_root != 0 :             ea = abs((x_root - last_x_root) / x_root) * 100                  print(\"iter time:\", iter_count, \",ea =\", ea, \"root:\", x_root)          if (ea &lt; es or iter_count &gt;= iter_max) :             print(\"total use\", iter_count, \"times.\")             return x_root In\u00a0[3]: Copied! <pre>x0 = 2\nes = 0.01\niter_max = 500\n\nprint(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max))\n</pre> x0 = 2 es = 0.01 iter_max = 500  print(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max)) <pre>x0 = 2\n\niter time: 1 ,ea = 609.9293556607687 root: 0.2817181715409549\niter time: 2 ,ea = 63.73755414477369 root: 0.7768868450453745\niter time: 3 ,ea = 11.888408438696143 root: 0.8817078789285671\niter time: 4 ,ea = 0.4510949099401444 root: 0.8857032411666447\niter time: 5 ,ea = 0.000627839236345159 root: 0.8857088019940234\ntotal use 5 times.\n\nThe approximate ans: 0.8857088019940234\n</pre> In\u00a0[4]: Copied! <pre>x0 = 6\nes = 0.01\niter_max = 500\n\nprint(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max))\n</pre> x0 = 6 es = 0.01 iter_max = 500  print(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max)) <pre>x0 = 6\n\ntotal use 0 times.\n\nThe approximate ans: Divergence\n</pre> In\u00a0[5]: Copied! <pre>x0 = 8\nes = 0.01\niter_max = 500\n\nprint(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max))\n</pre> x0 = 8 es = 0.01 iter_max = 500  print(\"\\nThe approximate ans:\", newton_raphson(x0, es, iter_max)) <pre>x0 = 8\n\niter time: 1 ,ea = 93.39913842615294 root: 121.19630006628846\niter time: 2 ,ea = 100.0 root: 7.212131452880089e+24\ntotal use 2 times.\n\nThe approximate ans: Divergence\n</pre>"},{"location":"assignment/a4/22_fall_a4_q5/#2022-fall-assignment4-5","title":"[2022 Fall] Assignment4-5\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q5/#4-5-1","title":"4-5-1\u00b6","text":"<p>Use the Newton-Raphson method to find the root of $f(x) = e^{-0.5x} (4 - x) - 2$</p> <p></p>"},{"location":"assignment/a4/22_fall_a4_q5/#4-5-2","title":"4-5-2\u00b6","text":"<p>Employ initial guesses of (a) 2, (b) 6, and (c) 8. Explain your results. (Python+\u89e3\u91cb) Hint: Think about the problems of this method.</p>"},{"location":"assignment/a4/22_fall_a4_q5/#a-x_0-2","title":"a. $x_0 = 2$\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q5/#b-x_0-6","title":"b. $x_0 = 6$\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q5/#c-x_0-8","title":"c. $x_0 = 8$\u00b6","text":""},{"location":"assignment/a4/22_fall_a4_q6/","title":"[2022 Fall] Assignment4-6","text":"In\u00a0[1]: Copied! <pre>import math\n</pre> import math In\u00a0[2]: Copied! <pre>def f(h, R, V) :\n    PI = math.pi\n    ans = PI * (h ** 2) * (((3 * R) - h) / 3) - V\n\n    return ans\n</pre> def f(h, R, V) :     PI = math.pi     ans = PI * (h ** 2) * (((3 * R) - h) / 3) - V      return ans In\u00a0[3]: Copied! <pre>def f_prime(h, R) :\n    PI = math.pi\n    ans = (2 * PI * h * R) - (PI * (h ** 2))\n\n    return ans\n</pre> def f_prime(h, R) :     PI = math.pi     ans = (2 * PI * h * R) - (PI * (h ** 2))      return ans In\u00a0[4]: Copied! <pre>def newton_raphson(x0, es, iter_max, R, V) :\n    iter_count = 0\n    iter_count_list = []\n    x_root = x0\n    print(\"x0 =\", x0)\n    print()\n\n    while True :\n        last_x_root = x_root\n\n        try :\n            x_root = last_x_root - (f(x_root, R, V) / f_prime(x_root, R))\n        except :\n            print(\"total use\", iter_count, \"times.\")\n            return \"Divergence\"\n\n        iter_count += 1\n        iter_count_list.append(iter_count)\n        if x_root != 0 :\n            ea = abs((x_root - last_x_root) / x_root) * 100        \n\n        print(\"iter time:\", iter_count, \",ea =\", ea, \"root:\", x_root)\n\n        if (ea &lt; es or iter_count &gt;= iter_max) :\n            print(\"total use\", iter_count, \"times.\")\n            return x_root\n</pre> def newton_raphson(x0, es, iter_max, R, V) :     iter_count = 0     iter_count_list = []     x_root = x0     print(\"x0 =\", x0)     print()      while True :         last_x_root = x_root          try :             x_root = last_x_root - (f(x_root, R, V) / f_prime(x_root, R))         except :             print(\"total use\", iter_count, \"times.\")             return \"Divergence\"          iter_count += 1         iter_count_list.append(iter_count)         if x_root != 0 :             ea = abs((x_root - last_x_root) / x_root) * 100                  print(\"iter time:\", iter_count, \",ea =\", ea, \"root:\", x_root)          if (ea &lt; es or iter_count &gt;= iter_max) :             print(\"total use\", iter_count, \"times.\")             return x_root In\u00a0[5]: Copied! <pre>R = 3\nV = 30\nx0 = R\nes = 0.01\niter_max = 3\n\nprint(\"\\nThe constrains of h:\", newton_raphson(x0, es, iter_max, R, V))\n</pre> R = 3 V = 30 x0 = R es = 0.01 iter_max = 3  print(\"\\nThe constrains of h:\", newton_raphson(x0, es, iter_max, R, V)) <pre>x0 = 3\n\niter time: 1 ,ea = 45.55808019742351 root: 2.061032953945969\niter time: 2 ,ea = 1.6768713794196717 root: 2.0270420656974903\niter time: 3 ,ea = 0.0067262694875214685 root: 2.026905730555795\ntotal use 3 times.\n\nThe constrains of h: 2.026905730555795\n</pre> In\u00a0[6]: Copied! <pre>print(\"\\nThe constrains of h:\", newton_raphson(x0, es, iter_max, R, V))\n</pre> print(\"\\nThe constrains of h:\", newton_raphson(x0, es, iter_max, R, V)) <pre>x0 = 3\n\niter time: 1 ,ea = 45.55808019742351 root: 2.061032953945969\niter time: 2 ,ea = 1.6768713794196717 root: 2.0270420656974903\niter time: 3 ,ea = 0.0067262694875214685 root: 2.026905730555795\ntotal use 3 times.\n\nThe constrains of h: 2.026905730555795\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/a4/22_fall_a4_q6/#2022-fall-assignment4-6","title":"[2022 Fall] Assignment4-6\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q6/#4-6-1","title":"4-6-1\u00b6","text":"<p>If R = 3 m, what depth must the tank be filled to so that it holds 30 \ud835\udc5a3?</p> <p></p>"},{"location":"assignment/a4/22_fall_a4_q6/#4-6-2","title":"4-6-2\u00b6","text":"<p>Newton-Raphson method (3 iterations; determine relative error after each iterations)(Python)</p>"},{"location":"assignment/a4/22_fall_a4_q6/#4-6-3","title":"4-6-3\u00b6","text":"<p>What are the constraints of h?</p>"},{"location":"assignment/a4/22_fall_a4_q7/","title":"[2022 Fall] Assignment4-7","text":"In\u00a0[\u00a0]: Copied!"},{"location":"assignment/a4/22_fall_a4_q7/#2022-fall-assignment4-7","title":"[2022 Fall] Assignment4-7\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q7/#4-7","title":"4-7\u00b6","text":"<p>Please read section 7.4 and describe the idea of Muller\u2019s method.</p> <p>\u7b97\u662f\u5272\u7dda\u6cd5\u7684\u5ef6\u4f38\uff0c\u672c\u60f3\u900f\u904e\u4e00\u76f4\u7dda\u901a\u904e\u51fd\u6578\u5230 x \u8ef8\u7684\u503c\u4f86\u7372\u53d6\u6578\u503c\u89e3\uff0c\u4e0d\u904e Muller's method \u5247\u505a\u4e86\u4fee\u6b63\uff0c\u8207\u5272\u7dda\u6cd5\u6700\u5927\u7684\u4e0d\u540c\u5c31\u662f\u900f\u904e\u300c\u66f2\u7dda\u300d\u4ee5\u66f2\u7dda\u7684\u6027\u8cea\u8b8a\u6210\u900f\u904e\u7b2c\u4e09\u500b\u9ede\u4f86\u5f97\u5230\u6578\u503c\u7684\u5206\u6790\u89e3\uff0c\u4f5c\u6cd5\u5247\u662f\u7528\u62cb\u7269\u7dda\u8207 x \u8ef8\u76f8\u4ea4\u7684\u9ede\u4f86\u5f97\u5230\u6578\u503c\u89e3\u3002</p>"},{"location":"assignment/a4/22_fall_a4_q8/","title":"[2022 Fall] Assignment4-8","text":"In\u00a0[\u00a0]: Copied!"},{"location":"assignment/a4/22_fall_a4_q8/#2022-fall-assignment4-8","title":"[2022 Fall] Assignment4-8\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q8/#4-8","title":"4-8\u00b6","text":"<p>Read chapter 7.2.2 and explain how to remove a found root of an nth-order polynomial.</p> <p>\u5728\u8fed\u4ee3\u6578\u6b21\u4e4b\u5f8c\u5e38\u6703\u767c\u73fe\u5f97\u5230\u76f8\u540c\u7684\u89e3\uff0c\u56e0\u6b64\u5728\u6211\u5011\u8981\u9032\u884c\u8fed\u4ee3\u6578\u6b21\u7684\u6642\u5019\u53ef\u4ee5\u5f9e\u5c0f\u6578\u9ede\u9032\u884c\u8457\u624b\uff0c\u4ee5\u6e1b\u8f15 round-off error \u70ba\u76ee\u6a19\u4f7f\u5f97\u7d50\u679c\u4e0d\u6703\u96e2\u6211\u5011\u9810\u671f\u7684\u592a\u904e\u9059\u9060\u3002</p> <p>\u4f7f round-off error \u4e0d\u6703\u9019\u9ebc\u5f71\u97ff\u6211\u5011\u7684\u7d50\u679c\uff0c\u4fbf\u662f\u8981\u6311\u9078\u597d\u7684\u4f30\u8a08\u503c\uff0c\u6709\u7684\u6642\u5019\u6211\u5011\u9700\u8981\u5f9e\u9ad8\u6b21\u9805\u8457\u624b\uff0c\u53cd\u4e4b\u6211\u5011\u9700\u8981\u518d\u4f4e\u6b21\u9805\u8457\u624b\uff0c\u5728\u597d\u7684\u7d50\u679c\u731c\u60f3\u4e2d\uff0c\u6240\u5f97\u5230\u7684\u7d50\u679c\u53ef\u4ee5\u4f7f\u6211\u5011\u4e0b\u6b21\u8fed\u4ee3\u4e2d\u5f97\u5230\u66f4\u597d\u7684\u7d50\u679c\uff0c</p> <p>\u53e6\u4e00\u7a2e\u65b9\u6cd5\u662f\u5728 deflaction \u5c07\u7372\u5f97\u7684\u9023\u7e8c\u6839\u8996\u70ba\u826f\u597d\u7684\u521d\u6b65\u731c\u6e2c\u3002\u7136\u5f8c\u53ef\u4ee5\u5c07\u6bcf\u500b\u4f30\u8a08\u503c\u7528\u505a\u521d\u59cb\u731c\u6e2c\uff0c\u518d\u904b\u7528 nondeflated polynomial \u5224\u5b9a\uff0c\u4e0d\u904e\u8981\u5c0f\u5fc3\u5982\u679c\u5169\u500b deflacted root \u4e0d\u5920\u6e96\u78ba\u4ee5\u81f3\u65bc\u6536\u6582\u81f3\u4e00\u500b\u89e3\u7684\u6642\u5019\uff0c\u53ef\u80fd\u6703\u767c\u751f\u932f\u8aa4\u7684\u8aa4\u5dee\u767c\u751f\uff0c\u6b64\u6642\u4fbf\u8981\u53bb\u6bd4\u5c0d\u6bcf\u4e00\u500b polished root\u3002</p>"},{"location":"assignment/a4/22_fall_a4_q8/#synthetic-division","title":"synthetic division\u00b6","text":"<pre><code>r = a(n)\na(n) = 0\nDOFOR i = n\u22121, 0, \u22121\n    s = a(i)\n    a(i) = r r=s+r*t\nEND DO\n</code></pre>"},{"location":"assignment/a4/22_fall_a4_q8/#ploynomial-deflaction","title":"Ploynomial deflaction\u00b6","text":"<pre>SUB poldiv(a, n, d, m, q, r) DOFOR j = 0, n\nr(j) = a(j)\nq(j) = 0 END DO\nDOFOR k = n\u2212m, 0, \u22121 q(k+1) = r(m+k) \u2215 d(m) DOFOR j = m+k\u22121, k, \u22121\nr(j) = r(j)\u2212q(k+1) * d(j\u2212k) END DO\n    END DO\nDOFOR j = m, n\nr(j) = 0 END DO\nn = n\u2212m END SUB\n</pre>"},{"location":"assignment/a4/22_fall_a4_q9/","title":"[2022 Fall] Assignment4-9","text":"In\u00a0[1]: Copied! <pre>import os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n</pre> import os import pandas as pd import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>\"\"\" Data type:\nstno: Observation's Number (Length: 6 digits)\nyyyymmddhh: UTC Time, yyyy: year, mm: month, dd: day, hh: hour (Length: 11 digits)\nSi: Significant Code (Length: 3 digits)\nPress: Pressure (Uint: hpa, Length: 7 digits)\nHeigh: Geopotential Height (Unit: gpm, Length: 6 digits)\nTx: Temperature (Unit: degrees Celsius, Length: 6 digits)\nTd: Dew Point (Unit: degrees Celsius, Length: 6 digits)\nWd: Wind Direction (Unit: degrees 360, Length: 4 digits)\nWs: Wind Speed (Unit: m/s, Length: 6 digits)\nRH: Relative Humidity (Unit: %, Length: 4 digits)\n\"\"\"\n\n# Fetch the local path to read the info of the file.\ndata_path = os.getcwd()\nfile = \"/src/data/20210101_upair.txt\"\nfile_path = f\"{data_path}/{file}\"\n\n\ndata = pd.read_csv(file_path, skiprows=13, sep=\"\\s+\")\ndata = data.replace(-0.99, 0)\ndata = data.replace(-9.99, 0)\ndata = data.replace(-1   , 0)\n# stno yyyymmddhh Si  Press Heigh    Tx    Td  Wd    Ws  RH\ndata.columns = [\"stno\", \"date\", \"Si\", \"press\", \"heigh\", \"Tx\", \"Td\", \"Wd\", \"Ws\", \"Rh\"]\n\nprint(data)\n</pre> \"\"\" Data type: stno: Observation's Number (Length: 6 digits) yyyymmddhh: UTC Time, yyyy: year, mm: month, dd: day, hh: hour (Length: 11 digits) Si: Significant Code (Length: 3 digits) Press: Pressure (Uint: hpa, Length: 7 digits) Heigh: Geopotential Height (Unit: gpm, Length: 6 digits) Tx: Temperature (Unit: degrees Celsius, Length: 6 digits) Td: Dew Point (Unit: degrees Celsius, Length: 6 digits) Wd: Wind Direction (Unit: degrees 360, Length: 4 digits) Ws: Wind Speed (Unit: m/s, Length: 6 digits) RH: Relative Humidity (Unit: %, Length: 4 digits) \"\"\"  # Fetch the local path to read the info of the file. data_path = os.getcwd() file = \"/src/data/20210101_upair.txt\" file_path = f\"{data_path}/{file}\"   data = pd.read_csv(file_path, skiprows=13, sep=\"\\s+\") data = data.replace(-0.99, 0) data = data.replace(-9.99, 0) data = data.replace(-1   , 0) # stno yyyymmddhh Si  Press Heigh    Tx    Td  Wd    Ws  RH data.columns = [\"stno\", \"date\", \"Si\", \"press\", \"heigh\", \"Tx\", \"Td\", \"Wd\", \"Ws\", \"Rh\"]  print(data) <pre>      stno        date  Si   press  heigh    Tx    Td   Wd    Ws  Rh\n0   466920  2021010100   6  1010.7    137  10.6   5.0   94   5.1  68\n1   466920  2021010100  10  1000.0    224  10.1   4.7   91   6.7  69\n2   466920  2021010100   6   970.7    471   8.0   3.8   69   8.8  74\n3   466920  2021010100   6   925.1    866   4.6   2.7   67  11.9  87\n4   466920  2021010100  10   925.0    867   4.6   2.7   67  11.9  87\n..     ...         ...  ..     ...    ...   ...   ...  ...   ...  ..\n63  466920  2021010100   2    97.0  16676 -84.6 -90.9  260  37.3  34\n64  466920  2021010100   2    87.8  17228 -85.0 -91.8  273  33.5  31\n65  466920  2021010100   2    84.5  17444 -79.0 -88.1  281  30.2  22\n66  466920  2021010100   6    82.3  17591 -79.4 -87.9  288  28.0  25\n67  466920  2021010100  20    76.9  17983 -76.1 -85.9  263  26.2  21\n\n[68 rows x 10 columns]\n</pre> In\u00a0[3]: Copied! <pre># At first we observe the realtionship between height and temperature\n\nplt.plot(data[\"Tx\"], data[\"heigh\"])\n\nplt.xlabel(\"Temperature(\u02dac)\")\nplt.ylabel(\"Height(gpm)\")\nplt.title(\"the realtionship between height and temperature\")\n\nplt.grid()\nplt.legend([\"temperature\"], loc =\"upper right\")\nplt.savefig(\"src/imgs/A4_9_1.jpg\", dpi = 300)\n\nplt.show()\n</pre> # At first we observe the realtionship between height and temperature  plt.plot(data[\"Tx\"], data[\"heigh\"])  plt.xlabel(\"Temperature(\u02dac)\") plt.ylabel(\"Height(gpm)\") plt.title(\"the realtionship between height and temperature\")  plt.grid() plt.legend([\"temperature\"], loc =\"upper right\") plt.savefig(\"src/imgs/A4_9_1.jpg\", dpi = 300)  plt.show() In\u00a0[4]: Copied! <pre># the key point we need is height and the temperature\n\ndata_num = len(data)\ninversion_happen = []\nx = []\ny = []\n\nfor i in range(0, data_num) :\n    if (i == data_num - 1) :\n        break\n\n    if (data[\"Tx\"][i] &lt; data[\"Tx\"][i + 1]) :\n        inversion_happen.append(i)\n        print(\"Height:\", data[\"heigh\"][i], \"Temperature inversion:\", data[\"Tx\"][i])\n        x.append(data[\"Tx\"][i])\n        y.append(data[\"heigh\"][i])\n\n\nplt.plot(data[\"Tx\"], data[\"heigh\"])\nplt.scatter(x, y, c='red')\n\nplt.xlabel(\"Temperature(\u02dac)\")\nplt.ylabel(\"Height(gpm)\")\nplt.title(\"the realtionship between height and temperature\")\n\nplt.grid()\nplt.legend([\"temperature\", \"temperature inversion\"], loc =\"upper right\")\nplt.savefig(\"src/imgs/A4_9_2.jpg\", dpi = 300)\n\nplt.show()\n</pre> # the key point we need is height and the temperature  data_num = len(data) inversion_happen = [] x = [] y = []  for i in range(0, data_num) :     if (i == data_num - 1) :         break      if (data[\"Tx\"][i] &lt; data[\"Tx\"][i + 1]) :         inversion_happen.append(i)         print(\"Height:\", data[\"heigh\"][i], \"Temperature inversion:\", data[\"Tx\"][i])         x.append(data[\"Tx\"][i])         y.append(data[\"heigh\"][i])   plt.plot(data[\"Tx\"], data[\"heigh\"]) plt.scatter(x, y, c='red')  plt.xlabel(\"Temperature(\u02dac)\") plt.ylabel(\"Height(gpm)\") plt.title(\"the realtionship between height and temperature\")  plt.grid() plt.legend([\"temperature\", \"temperature inversion\"], loc =\"upper right\") plt.savefig(\"src/imgs/A4_9_2.jpg\", dpi = 300)  plt.show() <pre>Height: 1761 Temperature inversion: -1.3\nHeight: 1951 Temperature inversion: -1.2\nHeight: 2556 Temperature inversion: -5.1\nHeight: 2577 Temperature inversion: -3.8\nHeight: 2595 Temperature inversion: 0.0\nHeight: 2872 Temperature inversion: 0.5\nHeight: 2955 Temperature inversion: 0.7\nHeight: 3009 Temperature inversion: 2.6\nHeight: 3032 Temperature inversion: 3.5\nHeight: 3100 Temperature inversion: 3.7\nHeight: 3167 Temperature inversion: 4.0\nHeight: 3319 Temperature inversion: 5.6\nHeight: 3675 Temperature inversion: 7.8\nHeight: 17228 Temperature inversion: -85.0\nHeight: 17591 Temperature inversion: -79.4\n</pre> In\u00a0[5]: Copied! <pre>y = data[\"press\"].iloc[::-1]\nplt.plot(data[\"Tx\"], y)\nplt.xlabel(\"Temperature(\u02dac)\")\nplt.ylabel(\"Pressure(hPa)\")\nplt.title(\"SkewT\")\n\nplt.grid()\nplt.legend([\"temperature\", \"temperature inversion\"], loc =\"upper right\")\nplt.savefig(\"src/imgs/A4_9_3.jpg\", dpi = 300)\n\nplt.show()\n</pre> y = data[\"press\"].iloc[::-1] plt.plot(data[\"Tx\"], y) plt.xlabel(\"Temperature(\u02dac)\") plt.ylabel(\"Pressure(hPa)\") plt.title(\"SkewT\")  plt.grid() plt.legend([\"temperature\", \"temperature inversion\"], loc =\"upper right\") plt.savefig(\"src/imgs/A4_9_3.jpg\", dpi = 300)  plt.show()"},{"location":"assignment/a4/22_fall_a4_q9/#2022-fall-assignment4-9","title":"[2022 Fall] Assignment4-9\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a4/22_fall_a4_q9/#4-9","title":"4-9\u00b6","text":"<p>Please write Python codes to determine the height of temperature inversion? (data is in the eeclass)</p>"},{"location":"assignment/a5/22_fall_a5_q1/","title":"[2022 Fall] Assignment5-1","text":"In\u00a0[\u00a0]: Copied!"},{"location":"assignment/a5/22_fall_a5_q1/#2022-fall-assignment5-1","title":"[2022 Fall] Assignment5-1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a5/22_fall_a5_q1/#q5-1","title":"Q5-1\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q1/#given-the-equations","title":"Given the equations\u00b6","text":"<p>$10x_1 +2x_2 -x_3 = 27 $</p> <p>$-3x_1 \u2013 6x_2 + 2x_3 = -61.5$</p> <p>$x_1 +x_2 +5x_3 = -21.5$</p> <ol> <li>Solve by na\u00efve Gauss elimination. Show all steps of the computation.(\u624b\u5beb)</li> <li>Substitute your results into the original equations to check your answers.</li> </ol>"},{"location":"assignment/a5/22_fall_a5_q1/#solve-by-naive-gauss-elimination-show-all-steps-of-the-computation","title":"Solve by na\u00efve Gauss elimination. Show all steps of the computation.(\u624b\u5beb)\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q1/#substitute-your-results-into-the-original-equations-to-check-your-answers","title":"Substitute your results into the original equations to check your answers.\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q2/","title":"[2022 Fall] Assignment5-2","text":"In\u00a0[\u00a0]: Copied!"},{"location":"assignment/a5/22_fall_a5_q2/#2022-fall-assignment5-2","title":"[2022 Fall] Assignment5-2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a5/22_fall_a5_q2/#q5-2","title":"Q5-2\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q2/#use-gauss-jordan-elimination-to-solve","title":"Use Gauss-Jordan elimination to solve :\u00b6","text":"<p>$2x_1 +x_2 -x_3 =1$</p> <p>$5x_1 +2x_2 +2x_3 =-4$</p> <p>$3x_1 +x_2 +x_3 =5$</p> <ol> <li>Do not employ pivoting. Check your answers by substituting them into the original equations. (\u624b\u5beb)</li> </ol>"},{"location":"assignment/a5/22_fall_a5_q3/","title":"[2022 Fall] Assignment5-3","text":"In\u00a0[\u00a0]: Copied!"},{"location":"assignment/a5/22_fall_a5_q3/#2022-fall-assignment5-3","title":"[2022 Fall] Assignment5-3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a5/22_fall_a5_q3/#q5-3","title":"Q5-3\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q3/#solve","title":"Solve :\u00b6","text":"<p>$x_1 +x_2 -x_3 =-3$</p> <p>$6x_1 +2x_2 +2x_3 =2$</p> <p>$-3x_1 +4x_2 +x_3 =1$</p>"},{"location":"assignment/a5/22_fall_a5_q3/#with","title":"With\u00b6","text":"<ol> <li>Na\u00efve Gauss elimination (\u624b\u5beb)</li> <li>Gauss elimination with partial pivoting (\u624b\u5beb)</li> <li>Gauss-Jordan without partial pivoting (\u624b\u5beb)</li> </ol>"},{"location":"assignment/a5/22_fall_a5_q3/#naive-gauss-elimination","title":"Na\u00efve Gauss elimination (\u624b\u5beb)\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q3/#gauss-elimination-with-partial-pivoting","title":"Gauss elimination with partial pivoting (\u624b\u5beb)\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q3/#gauss-jordan-without-partial-pivoting","title":"Gauss-Jordan without partial pivoting (\u624b\u5beb)\u00b6","text":""},{"location":"assignment/a5/22_fall_a5_q4/","title":"[2022 Fall] Assignment5-4","text":"In\u00a0[1]: Copied! <pre>#9.18\nimport numpy as np\n\ndef pivot(a, b):                 \n    p = np.array((a), float)\n    q = np.array((b), float)\n    n = len(q)\n\n    for i in range(0, n - 1) :\n        if abs(p[i, 1]) == 0 : \n            for k in range(i + 1, n) :\n                if abs((p[k, i])) &gt; abs(p[i, i]) :\n                    p[[i, k]] = p[[k, i]] \n                    q[[i, k]] = q[[k, i]]\n                    break\n        for j in range(i + 1, n):\n            f = p[j][i] / p[i][i] \n            p[j,:] = p[j,:] - f * p[i,:]\n            q[j] = q[j] -f * q[i]\n\n    return p, q\n\n\ndef back_substituted(a, b) : \n    n = b.size\n    x = np.zeros(n)\n\n    x[n - 1] = b[n - 1] / a[n - 1,n - 1]\n\n    for i in range(n - 2, -1, -1) :\n        sum1 = 0\n\n        for j in range(i + 1, n) :\n            sum1 = sum1 + a[i, j] * x[j]\n        x[i] = (b[i] - sum1) / a[i, i]\n\n    return x\n\n\nxx = np.array([[ 1, 2, -1], \n               [ 5, 2,  2], \n               [-3, 5, -1]])\nt = np.array([2, 9, 1])\na, b = pivot(xx, t)\nx = back_substituted(a, b)\n\nprint('[x1, x2, x3] =', x)\n</pre> #9.18 import numpy as np  def pivot(a, b):                      p = np.array((a), float)     q = np.array((b), float)     n = len(q)      for i in range(0, n - 1) :         if abs(p[i, 1]) == 0 :              for k in range(i + 1, n) :                 if abs((p[k, i])) &gt; abs(p[i, i]) :                     p[[i, k]] = p[[k, i]]                      q[[i, k]] = q[[k, i]]                     break         for j in range(i + 1, n):             f = p[j][i] / p[i][i]              p[j,:] = p[j,:] - f * p[i,:]             q[j] = q[j] -f * q[i]      return p, q   def back_substituted(a, b) :      n = b.size     x = np.zeros(n)      x[n - 1] = b[n - 1] / a[n - 1,n - 1]      for i in range(n - 2, -1, -1) :         sum1 = 0          for j in range(i + 1, n) :             sum1 = sum1 + a[i, j] * x[j]         x[i] = (b[i] - sum1) / a[i, i]      return x   xx = np.array([[ 1, 2, -1],                 [ 5, 2,  2],                 [-3, 5, -1]]) t = np.array([2, 9, 1]) a, b = pivot(xx, t) x = back_substituted(a, b)  print('[x1, x2, x3] =', x) <pre>[x1, x2, x3] = [1. 1. 1.]\n</pre> In\u00a0[2]: Copied! <pre>import numpy as np\n\ndef print_2d_matrix(data) :\n\n    for i in range(data.shape[0]) :\n        for j in range(data.shape[1]) :\n            print(\"%5.7f\"%data[i][j], end = \" \")\n        print()\n    print()\n\n    return\n\ndef substitute(data, n, b, x) :\n    \n    for i in range(n, 0, -1) :\n        sum = 0\n\n        for j in range(i, n) :\n            sum = sum + data[i - 1][j] * x[i]\n        \n        x[i - 1] = (b[i - 1] - sum) / data[i - 1][i - 1]\n    \n    print(x)\n\n    return\n\n\ndef pivot(data, b, s, n, k) :\n\n    p = k\n    big = abs(data[k][k] / s[k])\n\n    for ii in range(k, n) :\n        dummy = abs(data[ii][k] / s[ii])\n\n        if dummy &gt; big :\n            big = dummy\n            p = ii\n\n    if p != k :\n        for jj in range(k, n) :\n            dummy = data[p][jj]\n            data[p][jj] = data[k][jj]\n            data[k][jj] = dummy\n\n        dummy = data[p][n]\n        data[p][n] = data[k][n]\n        data[k][n] = dummy\n        dummy = s[p]\n        s[p] = s[k]\n        s[k] = dummy\n\n    return\n\n\ndef eliminate(data, s, n, b, tol, er) :\n    for k in range(n - 1) :\n        pivot(data, b, s, n, k)\n        print_2d_matrix(data)\n\n        if abs(data[k][k] / s[k]) &lt; tol :\n            er = -1\n\n            return\n\n        for i in range(k + 1, n) :\n            factor = data[i][k] / data[k][k]\n\n            for j in range(k, n) :\n                data[i][j] = data[i][j] - factor * data[k][j]\n            \n            data[i][n] = data[i][n] - factor * data[k][n]\n            print_2d_matrix(data)\n    \n    return\n\n\ndef gauss() :\n\n    er = 1\n    tol = 1\n    data = np.array([[ 1, 2, -1, 2], \n                     [ 5, 2,  2, 9],\n                     [-3, 5, -1, 1]], dtype=\"float\")\n    n = data.shape[0]\n    b = np.zeros(n)\n    s = np.zeros(n)\n    x = np.zeros(n)\n\n    for i in range(n) :\n        s[i] = abs(data[i][0])\n\n        for j in range(1, n) :\n            if abs(data[i][j] &gt; s[i]) :\n                s[i] = abs(data[i][j])\n    \n    print_2d_matrix(data)\n    eliminate(data, s, n, b, tol, er)\n\n    if er != -1 :\n        b = data[:, n]\n        substitute(data, n, b, x)\n\n    return\n\ngauss()\n</pre> import numpy as np  def print_2d_matrix(data) :      for i in range(data.shape[0]) :         for j in range(data.shape[1]) :             print(\"%5.7f\"%data[i][j], end = \" \")         print()     print()      return  def substitute(data, n, b, x) :          for i in range(n, 0, -1) :         sum = 0          for j in range(i, n) :             sum = sum + data[i - 1][j] * x[i]                  x[i - 1] = (b[i - 1] - sum) / data[i - 1][i - 1]          print(x)      return   def pivot(data, b, s, n, k) :      p = k     big = abs(data[k][k] / s[k])      for ii in range(k, n) :         dummy = abs(data[ii][k] / s[ii])          if dummy &gt; big :             big = dummy             p = ii      if p != k :         for jj in range(k, n) :             dummy = data[p][jj]             data[p][jj] = data[k][jj]             data[k][jj] = dummy          dummy = data[p][n]         data[p][n] = data[k][n]         data[k][n] = dummy         dummy = s[p]         s[p] = s[k]         s[k] = dummy      return   def eliminate(data, s, n, b, tol, er) :     for k in range(n - 1) :         pivot(data, b, s, n, k)         print_2d_matrix(data)          if abs(data[k][k] / s[k]) &lt; tol :             er = -1              return          for i in range(k + 1, n) :             factor = data[i][k] / data[k][k]              for j in range(k, n) :                 data[i][j] = data[i][j] - factor * data[k][j]                          data[i][n] = data[i][n] - factor * data[k][n]             print_2d_matrix(data)          return   def gauss() :      er = 1     tol = 1     data = np.array([[ 1, 2, -1, 2],                       [ 5, 2,  2, 9],                      [-3, 5, -1, 1]], dtype=\"float\")     n = data.shape[0]     b = np.zeros(n)     s = np.zeros(n)     x = np.zeros(n)      for i in range(n) :         s[i] = abs(data[i][0])          for j in range(1, n) :             if abs(data[i][j] &gt; s[i]) :                 s[i] = abs(data[i][j])          print_2d_matrix(data)     eliminate(data, s, n, b, tol, er)      if er != -1 :         b = data[:, n]         substitute(data, n, b, x)      return  gauss() <pre>1.0000000 2.0000000 -1.0000000 2.0000000 \n5.0000000 2.0000000 2.0000000 9.0000000 \n-3.0000000 5.0000000 -1.0000000 1.0000000 \n\n5.0000000 2.0000000 2.0000000 9.0000000 \n1.0000000 2.0000000 -1.0000000 2.0000000 \n-3.0000000 5.0000000 -1.0000000 1.0000000 \n\n5.0000000 2.0000000 2.0000000 9.0000000 \n0.0000000 1.6000000 -1.4000000 0.2000000 \n-3.0000000 5.0000000 -1.0000000 1.0000000 \n\n5.0000000 2.0000000 2.0000000 9.0000000 \n0.0000000 1.6000000 -1.4000000 0.2000000 \n0.0000000 6.2000000 0.2000000 6.4000000 \n\n5.0000000 2.0000000 2.0000000 9.0000000 \n0.0000000 6.2000000 0.2000000 6.4000000 \n0.0000000 1.6000000 -1.4000000 0.2000000 \n\n5.0000000 2.0000000 2.0000000 9.0000000 \n0.0000000 6.2000000 0.2000000 6.4000000 \n0.0000000 0.0000000 -1.4516129 -1.4516129 \n\n[1. 1. 1.]\n</pre>"},{"location":"assignment/a5/22_fall_a5_q4/#2022-fall-assignment5-4","title":"[2022 Fall] Assignment5-4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a5/22_fall_a5_q4/#q5-4","title":"Q5-4\u00b6","text":"<p>Develop, debug, and test a program in either a high-level language or macro langrage of your choice to solve a system of equations with Gauss elimination with partial pivoting. Base the program on the pseudocode from Fig. 9.6. Test the program using the following system (which has an answer of $\ud835\udc65_1 = \ud835\udc65_2 = \ud835\udc65_3 = 1$) (Python)</p> <p>$x_1 +2x_2 \u2013x_3 =2$</p> <p>$5x_1 +2x_2 +2x_3 =9$</p> <p>$-3x_1 +5x_2 \u2013x_3 =1$</p>"},{"location":"assignment/a5/22_fall_a5_q4/#pseudocode-gauss","title":"Pseudocode Gauss\u00b6","text":"<pre>SUB Gauss(a, b, n, x, tol, er)\nDIMENSION s(n)\ner = 0\nDOFOR i = 1, n\nsi = ABS(a[i][1])\nDOFOR j = 2, n\nIF ABS(a[i][j]) &gt; si THEN\nsi = ABS(a[i][j])\nENDDO\nENDDO\n\nCALL Eliminate(a, s, n, b, tol, er)\n\nIF (er != -1) THEN\nCALL Substitute(a, n, b, x)\nENDIF\nEND Gauss\n</pre>"},{"location":"assignment/a5/22_fall_a5_q4/#pseudocode-elminate","title":"Pseudocode Elminate\u00b6","text":"<pre>SUB Eliminate(a, s, n, b, tol, er)\nDOFOR k = 1, n - 1\nCALL Pivot(a, b, s, n, k)\n\nIF ABS(a[k][k] / s[k]) &lt; tol THEN\ner = 01\nEXIT DO\nEND IF\nDOFOR i = k + 1, n\nfactor = a[i][k] / a[k][k]\nDOFOR j = k + 1, n\na[i][j] = a[i][j] - factor * a[k][j]\nENDDO\n\nb[i] = b[i] - factor * bk\nENDDO\nENDDO\n\nIF ABS(a[n][n] / s[n]) &lt; tol THEN\ner = -1\nENDIF\nEND Eliminate\n</pre>"},{"location":"assignment/a5/22_fall_a5_q4/#pseudocode-pivot","title":"Pseudocode Pivot\u00b6","text":"<pre>SUB Pivot(a, b, s, n, k)\np = k\nbig = ABS(a[k][k] / s[k])\nDOFOR ii = k + 1, n\ndummy = ABS(a[ii][k] / s[ii])\nIF dummy &gt; big THEN\nbig = dummy\np = ii\nEND IF\nENDDO\n\nIF p != k THEN\nDOFOR jj = k, n\ndummy = a[p][jj]\na[p][jj] = a[k][jj]\na[k][jj] = dummy\nENDDO\n\ndummy = b[p]\nb[p] = b[k]\nb[k] = summy\ndummy = s[p]\ns[p] = s[k]\ns[k] = dummy\nEND IF\nEND Pivot\n</pre>"},{"location":"assignment/a5/22_fall_a5_q4/#pseudocode-subsitute","title":"Pseudocode Subsitute\u00b6","text":"<pre>SUB Substitute(a, n, b, x)\nx[n] = b[n] / a[n][n]\n\nDOFOR i = n - 1, 1, -1\nsum = 0\nDOFOR j = i + 1, n\nsum = sum + a[i][j] * x[j]\nENDDO\nx[n] = (b[n] - sum) / a[n][n]\nENDDO\nEND Substitute\n</pre>"},{"location":"assignment/a5/22_fall_a5_q5/","title":"[2022 Fall] Assignment5-5","text":"In\u00a0[\u00a0]: Copied!"},{"location":"assignment/a5/22_fall_a5_q5/#2022-fall-assignment5-5","title":"[2022 Fall] Assignment5-5\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q1/","title":"[2022 Fall] Assignment6-1","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\na = np.array([[15, -3, -1],\n              [-3, 18, -6],\n              [-4, -1, 12]])\nb = np.array([[3300], \n              [1200], \n              [2400]])\n\ndef L(x):\n\n    f21 = x[1][0] / x[0][0]\n    f31 = x[2][0] / x[0][0]\n    x = np.array([[x[0][0], x[0][1], x[0][2]],\n                  [x[1][0] - (x[0][0] * f21), x[1][1] - (x[0][1] * f21), x[1][2] - (x[0][2] * f21)],\n                  [x[2][0] - (x[0][0] * f31), x[2][1] - (x[0][1] * f31), x[2][2] - (x[0][2] * f31)]])\n    f32 = x[2][1] / x[1][1]\n\n    return np.array([[  1,   0, 0],\n                     [f21,   1, 0],\n                     [f31, f32, 1]])\n\n\ndef U(x):\n\n    a10 = x[1][0] / x[0][0]\n    a20 = x[2][0] / x[0][0]\n    x = np.array([[x[0][0], x[0][1], x[0][2]],\n                  [x[1][0] - (x[0][0] * a10), x[1][1] - (x[0][1] * a10), x[1][2] - (x[0][2] * a10)],\n                  [x[2][0] - (x[0][0] * a20), x[2][1] - (x[0][1] * a20), x[2][2] - (x[0][2] * a20)]])\n    a21 = x[2][1] / x[1][1]\n    x = np.array([[x[0][0], x[0][1], x[0][2]],\n                  [x[1][0], x[1][1], x[1][2]],\n                  [x[2][0], x[2][1] - (x[1][1] * a21), x[2][2] - (x[1][2] * a21)]])\n\n    return x\n\n\ndef inverse(x):\n    LU_L = L(x)\n    LU_U = U(x)\n    inv = np.array([[0., 0., 0.],\n                    [0., 0., 0.],\n                    [0., 0., 0.]])\n\n    for i in range(0, 3):\n        if i == 0:\n            b_1 = 1\n            b_2 = 0\n            b_3 = 0\n        elif i == 1:\n            b_1 = 0\n            b_2 = 1\n            b_3 = 0\n        elif i == 2:\n            b_1 = 0\n            b_2 = 0\n            b_3 = 1\n        \n        d1 = b_1/LU_L[0][0]\n        d2 = (b_2-LU_L[1][0]*d1)/LU_L[1][1]\n        d3 = (b_3-LU_L[2][0]*d1-LU_L[2][1]*d2)/LU_L[2][2]\n        x3 = d3/LU_U[2][2]\n        x2 = (d2-LU_U[1][2]*x3)/LU_U[1][1]\n        x1 = (d1-LU_U[0][2]*x3-LU_U[0][1]*x2)/LU_U[0][0]\n        inv[0][i] = x1\n        inv[1][i] = x2\n        inv[2][i] = x3\n\n    return inv\n\ninverse_a = inverse(a)\nprint(inverse_a)\n</pre> import numpy as np  a = np.array([[15, -3, -1],               [-3, 18, -6],               [-4, -1, 12]]) b = np.array([[3300],                [1200],                [2400]])  def L(x):      f21 = x[1][0] / x[0][0]     f31 = x[2][0] / x[0][0]     x = np.array([[x[0][0], x[0][1], x[0][2]],                   [x[1][0] - (x[0][0] * f21), x[1][1] - (x[0][1] * f21), x[1][2] - (x[0][2] * f21)],                   [x[2][0] - (x[0][0] * f31), x[2][1] - (x[0][1] * f31), x[2][2] - (x[0][2] * f31)]])     f32 = x[2][1] / x[1][1]      return np.array([[  1,   0, 0],                      [f21,   1, 0],                      [f31, f32, 1]])   def U(x):      a10 = x[1][0] / x[0][0]     a20 = x[2][0] / x[0][0]     x = np.array([[x[0][0], x[0][1], x[0][2]],                   [x[1][0] - (x[0][0] * a10), x[1][1] - (x[0][1] * a10), x[1][2] - (x[0][2] * a10)],                   [x[2][0] - (x[0][0] * a20), x[2][1] - (x[0][1] * a20), x[2][2] - (x[0][2] * a20)]])     a21 = x[2][1] / x[1][1]     x = np.array([[x[0][0], x[0][1], x[0][2]],                   [x[1][0], x[1][1], x[1][2]],                   [x[2][0], x[2][1] - (x[1][1] * a21), x[2][2] - (x[1][2] * a21)]])      return x   def inverse(x):     LU_L = L(x)     LU_U = U(x)     inv = np.array([[0., 0., 0.],                     [0., 0., 0.],                     [0., 0., 0.]])      for i in range(0, 3):         if i == 0:             b_1 = 1             b_2 = 0             b_3 = 0         elif i == 1:             b_1 = 0             b_2 = 1             b_3 = 0         elif i == 2:             b_1 = 0             b_2 = 0             b_3 = 1                  d1 = b_1/LU_L[0][0]         d2 = (b_2-LU_L[1][0]*d1)/LU_L[1][1]         d3 = (b_3-LU_L[2][0]*d1-LU_L[2][1]*d2)/LU_L[2][2]         x3 = d3/LU_U[2][2]         x2 = (d2-LU_U[1][2]*x3)/LU_U[1][1]         x1 = (d1-LU_U[0][2]*x3-LU_U[0][1]*x2)/LU_U[0][0]         inv[0][i] = x1         inv[1][i] = x2         inv[2][i] = x3      return inv  inverse_a = inverse(a) print(inverse_a) <pre>[[0.07253886 0.01278066 0.01243523]\n [0.02072539 0.06079447 0.03212435]\n [0.02590674 0.00932642 0.09015544]]\n</pre> In\u00a0[2]: Copied! <pre>x = np.dot(inverse_a, b)\nprint(x)\n</pre> x = np.dot(inverse_a, b) print(x) <pre>[[284.55958549]\n [218.44559585]\n [313.05699482]]\n</pre> In\u00a0[3]: Copied! <pre>x[0][0] = x[0][0] - 10 \nb_new = np.dot(a, x)\n\nprint('the rate of mass input to reactor3=', b_new[2][0])\n</pre> x[0][0] = x[0][0] - 10  b_new = np.dot(a, x)  print('the rate of mass input to reactor3=', b_new[2][0]) <pre>the rate of mass input to reactor3= 2440.0\n</pre> In\u00a0[4]: Copied! <pre>print('initial concentration in reactor3 =', x[2][0])\n\nfor i in range(1, 4):\n    b[0][0] = b[0][0] - 700\n    b[1][0] = b[1][0] - 350\n    x_new = np.dot(inverse_a, b)\n\n    print('Day', i, ': the concentration in reactor3 =', x_new[2][0])\n</pre> print('initial concentration in reactor3 =', x[2][0])  for i in range(1, 4):     b[0][0] = b[0][0] - 700     b[1][0] = b[1][0] - 350     x_new = np.dot(inverse_a, b)      print('Day', i, ': the concentration in reactor3 =', x_new[2][0]) <pre>initial concentration in reactor3 = 313.05699481865287\nDay 1 : the concentration in reactor3 = 291.6580310880829\nDay 2 : the concentration in reactor3 = 270.259067357513\nDay 3 : the concentration in reactor3 = 248.86010362694302\n</pre>"},{"location":"assignment/a6/22_fall_a6_q1/#2022-fall-assignment6-1","title":"[2022 Fall] Assignment6-1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q1/#q6-1","title":"Q6-1\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q1/#1-determine-the-matrix-inverse","title":"1. Determine the matrix inverse.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q1/#2-use-the-inverse-to-determine-the-solution","title":"2. Use the inverse to determine the solution.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q1/#3-how-much-the-rate-of-mass-input-to-reactor-3-must-be-increased-to-induce-a-10gm3-rise-in-the-concentration-of-reactor-1","title":"3. How much the rate of mass input to reactor 3 must be increased to induce a 10g/m3 rise in the concentration of reactor 1?\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q1/#4-how-much-will-the-concentration-in-reactor-3-be-reduced-if-the-rate-of-mass-input-to-reactors-1-and-2-is-reduced-by-700-and-350-gday-respectively","title":"4. How much will the concentration in reactor 3 be reduced if the rate of mass input to reactors 1 and 2 is reduced by 700 and 350 g/day, respectively?\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q2/","title":"[2022 Fall] Assignment6-2","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[2]: Copied! <pre>a = np.array([[ 1,  4,  9, 16, 25],\n              [ 4,  9, 16, 25, 36],\n              [ 9, 16, 25, 36, 49],\n              [16, 25, 36, 49, 64],\n              [25, 36, 49, 64, 81]])\na_determinant = np.linalg.det(a)\n\nprint(\"Condition number of A:\", np.linalg.cond(a, p=None))\n\n# print('determinant of A =', a_determine)\n</pre> a = np.array([[ 1,  4,  9, 16, 25],               [ 4,  9, 16, 25, 36],               [ 9, 16, 25, 36, 49],               [16, 25, 36, 49, 64],               [25, 36, 49, 64, 81]]) a_determinant = np.linalg.det(a)  print(\"Condition number of A:\", np.linalg.cond(a, p=None))  # print('determinant of A =', a_determine) <pre>Condition number of A: 2.6934910583421254e+17\n</pre> In\u00a0[3]: Copied! <pre>a = np.float32([[ 1,  4,  9, 16, 25],\n              [ 4,  9, 16, 25, 36],\n              [ 9, 16, 25, 36, 49],\n              [16, 25, 36, 49, 64],\n              [25, 36, 49, 64, 81]])\n\nfor i in range(0, 5) :\n    for j in range(0, 5) :\n        a[i][j] = float(a[i][j] / a[i][4])\n        # print(a[i][j])\n        \nprint(\"Making the max element in each row to 1:\\n\")\nprint(a)\n</pre> a = np.float32([[ 1,  4,  9, 16, 25],               [ 4,  9, 16, 25, 36],               [ 9, 16, 25, 36, 49],               [16, 25, 36, 49, 64],               [25, 36, 49, 64, 81]])  for i in range(0, 5) :     for j in range(0, 5) :         a[i][j] = float(a[i][j] / a[i][4])         # print(a[i][j])          print(\"Making the max element in each row to 1:\\n\") print(a) <pre>Making the max element in each row to 1:\n\n[[0.04       0.16       0.36       0.64       1.        ]\n [0.11111111 0.25       0.44444445 0.6944444  1.        ]\n [0.18367347 0.3265306  0.5102041  0.7346939  1.        ]\n [0.25       0.390625   0.5625     0.765625   1.        ]\n [0.30864197 0.44444445 0.60493827 0.79012346 1.        ]]\n</pre>"},{"location":"assignment/a6/22_fall_a6_q2/#2022-fall-assignment6-2","title":"[2022 Fall] Assignment6-2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q2/#q6-2","title":"Q6-2\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q2/#1-determine-the-condition-number-for-the-following-system-using-the-row-sum-norm-do-not-normalize-the-system","title":"1. Determine the condition number for the following system using the row-sum norm. Do not normalize the system.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q2/#2-repeat-a-but-scale-the-matrix-by-making-the-max-element-in-each-row-to-1","title":"2. Repeat (a) but scale the matrix by making the max element in each row to 1.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q2/#3-condition-number","title":"3. \u60f3\u60f3\u770b\uff0c\u7531condition number\u53ef\u77e5\uff0c\u9019\u662f\u4e00\u500b\u4ec0\u9ebc\u6a23\u7684\u77e9\u9663\u5462?\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q3/","title":"[2022 Fall] Assignment6-3","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[2]: Copied! <pre>a = np.array([[0, 1,  0,  0],\n              [0, 0,  2,  1],\n              [1, 1,  0,  0],\n              [1, 1, -1, -1]])\nb = np.array([[1],[1],[4],[0]])\n\ninverse_a = np.linalg.inv(a)\nprint(inverse_a.dot(b))\n</pre> a = np.array([[0, 1,  0,  0],               [0, 0,  2,  1],               [1, 1,  0,  0],               [1, 1, -1, -1]]) b = np.array([[1],[1],[4],[0]])  inverse_a = np.linalg.inv(a) print(inverse_a.dot(b)) <pre>[[ 3.]\n [ 1.]\n [-3.]\n [ 7.]]\n</pre>"},{"location":"assignment/a6/22_fall_a6_q3/#2022-fall-assignment6-3","title":"[2022 Fall] Assignment6-3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q4/","title":"[2022 Fall] Assignment6-4","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[2]: Copied! <pre>a = np.array([\n    [ 6,  15,  55],\n    [15,  55, 225],\n    [55, 225, 979]]\n)\nb = np.array([\n    [152.6],\n    [585.6],\n    [2488.8]]\n)\n</pre> a = np.array([     [ 6,  15,  55],     [15,  55, 225],     [55, 225, 979]] ) b = np.array([     [152.6],     [585.6],     [2488.8]] ) In\u00a0[3]: Copied! <pre>def L(x):\n\n    f21 = x[1][0] / x[0][0]\n    f31 = x[2][0] / x[0][0]\n    x = np.array([[x[0][0], x[0][1], x[0][2]],\n                  [x[1][0] - (x[0][0] * f21), x[1][1] - (x[0][1] * f21), x[1][2] - (x[0][2] * f21)],\n                  [x[2][0] - (x[0][0] * f31), x[2][1] - (x[0][1] * f31), x[2][2] - (x[0][2] * f31)]])\n    f32 = x[2][1] / x[1][1]\n\n    return np.array([[  1,   0, 0],\n                     [f21,   1, 0],\n                     [f31, f32, 1]])\n</pre> def L(x):      f21 = x[1][0] / x[0][0]     f31 = x[2][0] / x[0][0]     x = np.array([[x[0][0], x[0][1], x[0][2]],                   [x[1][0] - (x[0][0] * f21), x[1][1] - (x[0][1] * f21), x[1][2] - (x[0][2] * f21)],                   [x[2][0] - (x[0][0] * f31), x[2][1] - (x[0][1] * f31), x[2][2] - (x[0][2] * f31)]])     f32 = x[2][1] / x[1][1]      return np.array([[  1,   0, 0],                      [f21,   1, 0],                      [f31, f32, 1]]) In\u00a0[4]: Copied! <pre>def U(x):\n\n    a10 = x[1][0] / x[0][0]\n    a20 = x[2][0] / x[0][0]\n    x = np.array([[x[0][0], x[0][1], x[0][2]],\n                  [x[1][0] - (x[0][0] * a10), x[1][1] - (x[0][1] * a10), x[1][2] - (x[0][2] * a10)],\n                  [x[2][0] - (x[0][0] * a20), x[2][1] - (x[0][1] * a20), x[2][2] - (x[0][2] * a20)]])\n    a21 = x[2][1] / x[1][1]\n    x = np.array([[x[0][0], x[0][1], x[0][2]],\n                  [x[1][0], x[1][1], x[1][2]],\n                  [x[2][0], x[2][1] - (x[1][1] * a21), x[2][2] - (x[1][2] * a21)]])\n\n    return x\n</pre> def U(x):      a10 = x[1][0] / x[0][0]     a20 = x[2][0] / x[0][0]     x = np.array([[x[0][0], x[0][1], x[0][2]],                   [x[1][0] - (x[0][0] * a10), x[1][1] - (x[0][1] * a10), x[1][2] - (x[0][2] * a10)],                   [x[2][0] - (x[0][0] * a20), x[2][1] - (x[0][1] * a20), x[2][2] - (x[0][2] * a20)]])     a21 = x[2][1] / x[1][1]     x = np.array([[x[0][0], x[0][1], x[0][2]],                   [x[1][0], x[1][1], x[1][2]],                   [x[2][0], x[2][1] - (x[1][1] * a21), x[2][2] - (x[1][2] * a21)]])      return x In\u00a0[5]: Copied! <pre>d = np.dot(np.linalg.inv(L(a)), b)      # [L]{D} = {B}\nx = np.dot(np.linalg.inv(U(a)), d)      # [U]{X} = {D}\nprint('After LU decomposition\\n[L] =')\nprint(L(a))\nprint('[U] =')\nprint(U(a))\nprint('[A] =')\nprint(x)\nprint('a0 =', x[0], 'a1 =', x[1], 'a2 =', x[2])\n</pre> d = np.dot(np.linalg.inv(L(a)), b)      # [L]{D} = {B} x = np.dot(np.linalg.inv(U(a)), d)      # [U]{X} = {D} print('After LU decomposition\\n[L] =') print(L(a)) print('[U] =') print(U(a)) print('[A] =') print(x) print('a0 =', x[0], 'a1 =', x[1], 'a2 =', x[2]) <pre>After LU decomposition\n[L] =\n[[1.         0.         0.        ]\n [2.5        1.         0.        ]\n [9.16666667 5.         1.        ]]\n[U] =\n[[ 6.         15.         55.        ]\n [ 0.         17.5        87.5       ]\n [ 0.          0.         37.33333333]]\n[A] =\n[[2.47857143]\n [2.35928571]\n [1.86071429]]\na0 = [2.47857143] a1 = [2.35928571] a2 = [1.86071429]\n</pre> In\u00a0[6]: Copied! <pre>l11 = np.sqrt(a[0][0])\nl21 = a[1][0] / l11\nl22 = np.sqrt(a[1][1] - l21 ** 2)\nl31 = a[2][0] / l11\nl32 = (a[2][1] - l21 * l31) / l22\nl33 = np.sqrt(a[2][2] - l31 ** 2 - l32 ** 2)\nl = np.array([[l11,   0,   0],\n              [l21, l22,   0],\n              [l31, l32, l33]])\n              \nprint('Cholesky decomposition')\nprint('[L]=')\nprint(l)\n</pre> l11 = np.sqrt(a[0][0]) l21 = a[1][0] / l11 l22 = np.sqrt(a[1][1] - l21 ** 2) l31 = a[2][0] / l11 l32 = (a[2][1] - l21 * l31) / l22 l33 = np.sqrt(a[2][2] - l31 ** 2 - l32 ** 2) l = np.array([[l11,   0,   0],               [l21, l22,   0],               [l31, l32, l33]])                print('Cholesky decomposition') print('[L]=') print(l) <pre>Cholesky decomposition\n[L]=\n[[ 2.44948974  0.          0.        ]\n [ 6.12372436  4.18330013  0.        ]\n [22.45365598 20.91650066  6.11010093]]\n</pre>"},{"location":"assignment/a6/22_fall_a6_q4/#2022-fall-assignment6-4","title":"[2022 Fall] Assignment6-4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q4/#q6-4","title":"Q6-4\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q4/#lu-decomposition","title":"LU decomposition.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q4/#cholesky-decomposition","title":"Cholesky decomposition\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q5/","title":"[2022 Fall] Assignment6-5","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[2]: Copied! <pre>a = np.array([\n    [ 0.8, -0.4,  0.0],\n    [-0.4,  0.8, -0.4],\n    [ 0.0, -0.4,  0.8]]\n)\nb = np.array([\n    [ 41],\n    [ 25],\n    [105]]\n)\n</pre> a = np.array([     [ 0.8, -0.4,  0.0],     [-0.4,  0.8, -0.4],     [ 0.0, -0.4,  0.8]] ) b = np.array([     [ 41],     [ 25],     [105]] ) In\u00a0[3]: Copied! <pre>x1 = 0\nx2 = 1\nx3 = 0\ncount = 0\nc = 1.2\n</pre> x1 = 0 x2 = 1 x3 = 0 count = 0 c = 1.2 In\u00a0[4]: Copied! <pre>while True:\n    xold1 = x1\n    xold2 = x2\n    xold3 = x3\n    es = 0.5 * 10 ** (-2)\n\n    count += 1\n    x1 = ((b[0][0]) - (a[0][1]) * x2 - (a[0][2]) * x3) / a[0][0]\n    x1 = c * x1 + (1 - c) * xold1\n    x2 = ((b[1][0]) - (a[1][0]) * x1 - (a[1][2]) * x3) / a[1][1]\n    x2 = c * x2 + (1 - c) * xold2\n    x3 = ((b[2][0]) - (a[2][0]) * x1 - (a[2][1]) * x2) / a[2][2]\n    x3 = c * x3 + (1 - c) * xold3\n    if ((x1 - xold1) / x1 &lt; es) and \\\n           ((x2-xold2)/x2 &lt; es) and \\\n           ((x3-xold3)/x3 &lt; es) :\n        break\n\nprint('x1 =', x1)\nprint('x2 =', x2)\nprint('x3 =', x3)\nprint()\nprint('Total used', count, \"times.\")\n</pre> while True:     xold1 = x1     xold2 = x2     xold3 = x3     es = 0.5 * 10 ** (-2)      count += 1     x1 = ((b[0][0]) - (a[0][1]) * x2 - (a[0][2]) * x3) / a[0][0]     x1 = c * x1 + (1 - c) * xold1     x2 = ((b[1][0]) - (a[1][0]) * x1 - (a[1][2]) * x3) / a[1][1]     x2 = c * x2 + (1 - c) * xold2     x3 = ((b[2][0]) - (a[2][0]) * x1 - (a[2][1]) * x2) / a[2][2]     x3 = c * x3 + (1 - c) * xold3     if ((x1 - xold1) / x1 &lt; es) and \\            ((x2-xold2)/x2 &lt; es) and \\            ((x3-xold3)/x3 &lt; es) :         break  print('x1 =', x1) print('x2 =', x2) print('x3 =', x3) print() print('Total used', count, \"times.\") <pre>x1 = 173.79293976576002\nx2 = 245.05792502579206\nx3 = 253.76707266232324\n\nTotal used 6 times.\n</pre>"},{"location":"assignment/a6/22_fall_a6_q5/#2022-fall-assignment6-5","title":"[2022 Fall] Assignment6-5\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q5/#q6-5","title":"Q6-5\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q6/","title":"[2022 Fall] Assignment6-6","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[2]: Copied! <pre>a = np.array([[ 2.0, -6.0, -1.0],\n              [-3.0, -1.0,  7.0],\n              [-8.0,  1.0, -2.0]])\nb = np.array([[-38.0],\n              [-34.0],\n              [-20.0]])\n\ndef pivot(a, b):  \n\n    p = np.array((a), float)\n    q = np.array((b), float)\n    n = len(q)\n\n    for i in range(0, n - 1):\n\n        if abs(p[i, 1]) == 0:\n            for k in range(i + 1, n):\n                if abs((p[k, i])) &gt; abs(p[i, i]):\n                    p[[i, k]] = p[[k, i]]\n                    q[[i, k]] = q[[k, i]]\n\n                    break\n\n        for j in range(i + 1, n):\n            f = p[j][i] / p[i][i]\n            p[j, :] = p[j, :] - f * p[i, :]\n            q[j] = q[j] -f * q[i]\n\n    return p,q\n\n\na, b = pivot(a, b)\nx1 = 1\nx2 = 1\nx3 = 1\ncount = 0\nes = 0.05\n\nwhile True:\n\n    xold1 = x1\n    xold2 = x2\n    xold3 = x3\n    count += 1\n    x1 = ((b[0][0]) - (a[0][1]) * xold2 - (a[0][2]) * xold3) / a[0][0]\n    x2 = ((b[1][0]) - (a[1][0]) * xold1 - (a[1][2]) * xold3) / a[1][1]\n    x3 = ((b[2][0]) - (a[2][0]) * xold1 - (a[2][1]) * xold2) / a[2][2]\n\n    if (((x1 - xold1) / x1) &lt; es) and \\\n             ((x2-xold2)/x2 &lt; es) and \\\n             ((x3-xold3)/x3 &lt; es) :\n        break\n\n\nprint('without relaxation')\nprint('x1 =', x1)\nprint('x2 =', x2)\nprint('x3 =', x3)\nprint()\nprint('Total used', count, \"times.\")\n</pre> a = np.array([[ 2.0, -6.0, -1.0],               [-3.0, -1.0,  7.0],               [-8.0,  1.0, -2.0]]) b = np.array([[-38.0],               [-34.0],               [-20.0]])  def pivot(a, b):        p = np.array((a), float)     q = np.array((b), float)     n = len(q)      for i in range(0, n - 1):          if abs(p[i, 1]) == 0:             for k in range(i + 1, n):                 if abs((p[k, i])) &gt; abs(p[i, i]):                     p[[i, k]] = p[[k, i]]                     q[[i, k]] = q[[k, i]]                      break          for j in range(i + 1, n):             f = p[j][i] / p[i][i]             p[j, :] = p[j, :] - f * p[i, :]             q[j] = q[j] -f * q[i]      return p,q   a, b = pivot(a, b) x1 = 1 x2 = 1 x3 = 1 count = 0 es = 0.05  while True:      xold1 = x1     xold2 = x2     xold3 = x3     count += 1     x1 = ((b[0][0]) - (a[0][1]) * xold2 - (a[0][2]) * xold3) / a[0][0]     x2 = ((b[1][0]) - (a[1][0]) * xold1 - (a[1][2]) * xold3) / a[1][1]     x3 = ((b[2][0]) - (a[2][0]) * xold1 - (a[2][1]) * xold2) / a[2][2]      if (((x1 - xold1) / x1) &lt; es) and \\              ((x2-xold2)/x2 &lt; es) and \\              ((x3-xold3)/x3 &lt; es) :         break   print('without relaxation') print('x1 =', x1) print('x2 =', x2) print('x3 =', x3) print() print('Total used', count, \"times.\") <pre>without relaxation\nx1 = 4.0\nx2 = 8.0\nx3 = -1.9999999999999993\n\nTotal used 3 times.\n</pre> In\u00a0[3]: Copied! <pre>a, b = pivot(a, b)\nx1 = 1\nx2 = 1\nx3 = 1\ncount = 0\nc = 1.2\nes = 0.05\n\nwhile True:\n    xold1 = x1\n    xold2 = x2\n    xold3 = x3\n    count += 1\n    x1 = ((b[0][0]) - (a[0][1]) * xold2 - (a[0][2]) * xold3) / a[0][0]\n    x2 = ((b[1][0]) - (a[1][0]) * xold1 - (a[1][2]) * xold3) / a[1][1]\n    x3 = ((b[2][0]) - (a[2][0]) * xold1 - (a[2][1]) * xold2) / a[2][2]\n    x1 = c * x1 + (1 - c) * xold1\n    x2 = c * x2 + (1 - c) * xold2\n    x3 = c * x3 + (1 - c) * xold3\n\n    if (((x1 - xold1) / x1) &lt; es) and \\\n             ((x2-xold2)/x2 &lt; es) and \\\n             ((x3-xold3)/x3 &lt; es) :\n        break\n    \n\nprint('with relaxation')\nprint('x1=',x1)\nprint('x2=',x2)\nprint('x3=',x3)\nprint()\nprint('Total used', count, \"times.\")\n</pre> a, b = pivot(a, b) x1 = 1 x2 = 1 x3 = 1 count = 0 c = 1.2 es = 0.05  while True:     xold1 = x1     xold2 = x2     xold3 = x3     count += 1     x1 = ((b[0][0]) - (a[0][1]) * xold2 - (a[0][2]) * xold3) / a[0][0]     x2 = ((b[1][0]) - (a[1][0]) * xold1 - (a[1][2]) * xold3) / a[1][1]     x3 = ((b[2][0]) - (a[2][0]) * xold1 - (a[2][1]) * xold2) / a[2][2]     x1 = c * x1 + (1 - c) * xold1     x2 = c * x2 + (1 - c) * xold2     x3 = c * x3 + (1 - c) * xold3      if (((x1 - xold1) / x1) &lt; es) and \\              ((x2-xold2)/x2 &lt; es) and \\              ((x3-xold3)/x3 &lt; es) :         break       print('with relaxation') print('x1=',x1) print('x2=',x2) print('x3=',x3) print() print('Total used', count, \"times.\") <pre>with relaxation\nx1= 3.2435200000000086\nx2= 8.018080000000001\nx3= -2.000959999999999\n\nTotal used 5 times.\n</pre>"},{"location":"assignment/a6/22_fall_a6_q6/#2022-fall-assignment6-6","title":"[2022 Fall] Assignment6-6\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q6/#q6-6","title":"Q6-6\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q6/#1-without-relaxation","title":"1. without relaxation.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q6/#2-with-relaxation","title":"2. with relaxation.\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q7/","title":"[2022 Fall] Assignment6-7","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[2]: Copied! <pre>a = np.array([[-4,  1,  1,  0],\n              [ 1, -4,  0,  1],\n              [ 1,  0, -4,  1],\n              [ 0,  1,  1, -4]])\nb = np.array([[-275],\n              [-225],\n              [ -75],\n              [-25]])\n\nx1 = 1\nx2 = 1\nx3 = 1\nx4 = 1\ncount = 0\n\nwhile True:\n    xold1 = x1\n    xold2 = x2\n    xold3 = x3\n    xold4 = x4\n    count += 1\n    es = 0.0005\n    x1 = (b[0][0] - a[0][1] * xold2 - a[0][2] * xold3 - a[0][3] * xold4) / a[0][0]\n    x2 = (b[1][0] - a[1][0] * xold1 - a[1][2] * xold3 - a[1][3] * xold4) / a[1][1]\n    x3 = (b[2][0] - a[2][0] * xold1 - a[2][1] * xold2 - a[2][3] * xold4) / a[2][2]\n    x4 = (b[3][0] - a[3][0] * xold1 - a[3][1] * xold2 - a[3][2] * xold3) / a[3][3]\n\n    if (((x1 - xold1) / x1) &lt; es) and \\\n             ((x2-xold2)/x2 &lt; es) and \\\n             ((x3-xold3)/x3 &lt; es) :\n        break\n\nprint('t11 =', x1)\nprint('t12 =', x2)\nprint('t21 =', x3)\nprint('t22 =', x4)\nprint()\nprint('Total used', count, \"times.\")\n</pre> a = np.array([[-4,  1,  1,  0],               [ 1, -4,  0,  1],               [ 1,  0, -4,  1],               [ 0,  1,  1, -4]]) b = np.array([[-275],               [-225],               [ -75],               [-25]])  x1 = 1 x2 = 1 x3 = 1 x4 = 1 count = 0  while True:     xold1 = x1     xold2 = x2     xold3 = x3     xold4 = x4     count += 1     es = 0.0005     x1 = (b[0][0] - a[0][1] * xold2 - a[0][2] * xold3 - a[0][3] * xold4) / a[0][0]     x2 = (b[1][0] - a[1][0] * xold1 - a[1][2] * xold3 - a[1][3] * xold4) / a[1][1]     x3 = (b[2][0] - a[2][0] * xold1 - a[2][1] * xold2 - a[2][3] * xold4) / a[2][2]     x4 = (b[3][0] - a[3][0] * xold1 - a[3][1] * xold2 - a[3][2] * xold3) / a[3][3]      if (((x1 - xold1) / x1) &lt; es) and \\              ((x2-xold2)/x2 &lt; es) and \\              ((x3-xold3)/x3 &lt; es) :         break  print('t11 =', x1) print('t12 =', x2) print('t21 =', x3) print('t22 =', x4) print() print('Total used', count, \"times.\") <pre>t11 = 106.23193359375\nt12 = 93.73193359375\nt21 = 56.23193359375\nt22 = 43.73193359375\n\nTotal used 12 times.\n</pre>"},{"location":"assignment/a6/22_fall_a6_q7/#2022-fall-assignment6-7","title":"[2022 Fall] Assignment6-7\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q7/#q6-7","title":"Q6-7\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q8/","title":"[2022 Fall] Assignment6-8","text":""},{"location":"assignment/a6/22_fall_a6_q8/#2022-fall-assignment6-8","title":"[2022 Fall] Assignment6-8\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q8/#q6-8","title":"Q6-8\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q8/#1-solve-with-the-optimal-gradient-steepest-descent-method","title":"1. Solve with the optimal gradient steepest descent method\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q8/#2-solve-with-the-newtons-method","title":"2. Solve with the Newton\u2019s method\u00b6","text":""},{"location":"assignment/a6/22_fall_a6_q9/","title":"[2022 Fall] Assignment6-9","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\n%matplotlib inline\n\nfig, ax = plt.subplots(figsize=(20, 15)) \nimg = mpimg.imread('./imgs/6.9.jpg')\nimgplot = ax.imshow(img)\nax.xaxis.set_visible(False)\nax.yaxis.set_visible(False)\nplt.show()\n</pre> import matplotlib.pyplot as plt import matplotlib.image as mpimg  %matplotlib inline  fig, ax = plt.subplots(figsize=(20, 15))  img = mpimg.imread('./imgs/6.9.jpg') imgplot = ax.imshow(img) ax.xaxis.set_visible(False) ax.yaxis.set_visible(False) plt.show()  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/a6/22_fall_a6_q9/#2022-fall-assignment6-9","title":"[2022 Fall] Assignment6-9\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a6/22_fall_a6_q9/#q6-9","title":"Q6-9\u00b6","text":"<p>$f(x, y) =e^{\u2212x^{2}y^{2}}+cos(\ud835\udc65) +cos(2\ud835\udc66)$</p> <p>using the steepest ascend method.</p> <p>$f(x_0, y_0) = (-1, -1)$</p>"},{"location":"assignment/a7/22_fall_a7_q1/","title":"[2022 Fall] Assignment7-1","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.array([1,   2, 3, 4, 5, 6, 7,  8,  9])\ny = np.array([1, 1.5, 2, 3, 4, 5, 8, 10, 13])\n\nspace = np.linspace(1, 10) # line space\nA = np.zeros((2, 2))\nB = np.zeros(2)\n\n# Construct Matrix for solution\nn = np.size(x)\nm = 1\nA[0, 0] = np.size(x)\nA[0, 1] = np.sum(x)\nA[1, 0] = np.sum(x)\nA[1, 1] = np.sum(x ** 2)\nB[0] = np.sum(y)\nB[1] = np.sum(x * y)\n\n# Solve AX=B to know a0(X[0]), a1(X[1])\nX = np.inner(np.linalg.inv(A), B)\nprint(\"Condition number: \", np.linalg.cond(A))\n\n# construct regression line\nregress = X[1] * space + X[0]\n\nSt = np.sum((y - np.mean(y)) ** 2)\nSr = np.sum((y - X[0] - X[1] * x) ** 2)\nSyx = np.sqrt(Sr / (n-(m+1)))\nr2 = (St - Sr) / St\nr = np.sqrt(r2)\n\nprint('Standard Deviation:', Syx)\nprint('Coefficient of determination:', r2)\nprint('Correlation Coefficient:', r)\n\nplt.scatter(x, y, s=10)\nplt.plot(space, regress, 'r')\nplt.title(\"Linear Regression\")\nplt.legend(['Regression Line', 'Data Point'])\nplt.grid()\n\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  x = np.array([1,   2, 3, 4, 5, 6, 7,  8,  9]) y = np.array([1, 1.5, 2, 3, 4, 5, 8, 10, 13])  space = np.linspace(1, 10) # line space A = np.zeros((2, 2)) B = np.zeros(2)  # Construct Matrix for solution n = np.size(x) m = 1 A[0, 0] = np.size(x) A[0, 1] = np.sum(x) A[1, 0] = np.sum(x) A[1, 1] = np.sum(x ** 2) B[0] = np.sum(y) B[1] = np.sum(x * y)  # Solve AX=B to know a0(X[0]), a1(X[1]) X = np.inner(np.linalg.inv(A), B) print(\"Condition number: \", np.linalg.cond(A))  # construct regression line regress = X[1] * space + X[0]  St = np.sum((y - np.mean(y)) ** 2) Sr = np.sum((y - X[0] - X[1] * x) ** 2) Syx = np.sqrt(Sr / (n-(m+1))) r2 = (St - Sr) / St r = np.sqrt(r2)  print('Standard Deviation:', Syx) print('Coefficient of determination:', r2) print('Correlation Coefficient:', r)  plt.scatter(x, y, s=10) plt.plot(space, regress, 'r') plt.title(\"Linear Regression\") plt.legend(['Regression Line', 'Data Point']) plt.grid()  plt.show() <pre>Condition number:  158.06033996889786\nStandard Deviation: 1.3066526967183245\nCoefficient of determination: 0.9143610668789809\nCorrelation Coefficient: 0.9562222894698601\n</pre> In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.array([1,   2, 3, 4, 5, 6, 7,  8,  9])\ny = np.array([1, 1.5, 2, 3, 4, 5, 8, 10, 13])\n\nspace = np.linspace(1, 10)\n\nA = np.zeros((3, 3))\nB = np.zeros(3)\n\n# Construct Matrix for solution\nn = np.size(x)\nm = 2\nA[0, 0] = np.size(x)\nA[0, 1] = np.sum(x)\nA[1, 0] = np.sum(x)\nA[1, 1] = np.sum(x ** 2)\nA[0, 2] = np.sum(x ** 2)\nA[2, 0] = np.sum(x ** 2) \nA[1, 2] = np.sum(x ** 3)\nA[2, 1] = np.sum(x ** 3)\nA[2, 2] = np.sum(x ** 4)\nB[0] = np.sum(y)\nB[1] = np.sum(x * y)\nB[2] = np.sum((x ** 2) * y)\n\n# Solve AX=B to know a0(X[0]), a1(X[1])\nX = np.inner(np.linalg.inv(A), B)\nprint(\"Condition number:\", np.linalg.cond(A)) # Knowing the condition number\n\n# construct regression line\nregress = X[2] * (space ** 2) + X[1] * space + X[0]\n\n# calculate St, Sr, Syx(STD), R^2, R\nSt = np.sum((y - np.mean(y)) ** 2)\nSr = np.sum((y - X[0] - X[1] * x - X[2] * (x ** 2)) ** 2)\nSyx = np.sqrt(Sr / (n - (m + 1)))\nr2 = (St - Sr) / St\nr = np.sqrt(r2)\n\n#print(A, B, X)\nprint('Standard Deviation:', Syx)\nprint('Coefficient of determination:', r2)\nprint('Correlation Coefficient:', r)\n\nplt.scatter(x, y, s=15)\nplt.plot(space, regress, 'r')\nplt.title(\"Polynomial Regression\")\nplt.legend(['Regression Line', 'Data Point'])\nplt.grid()\n\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  x = np.array([1,   2, 3, 4, 5, 6, 7,  8,  9]) y = np.array([1, 1.5, 2, 3, 4, 5, 8, 10, 13])  space = np.linspace(1, 10)  A = np.zeros((3, 3)) B = np.zeros(3)  # Construct Matrix for solution n = np.size(x) m = 2 A[0, 0] = np.size(x) A[0, 1] = np.sum(x) A[1, 0] = np.sum(x) A[1, 1] = np.sum(x ** 2) A[0, 2] = np.sum(x ** 2) A[2, 0] = np.sum(x ** 2)  A[1, 2] = np.sum(x ** 3) A[2, 1] = np.sum(x ** 3) A[2, 2] = np.sum(x ** 4) B[0] = np.sum(y) B[1] = np.sum(x * y) B[2] = np.sum((x ** 2) * y)  # Solve AX=B to know a0(X[0]), a1(X[1]) X = np.inner(np.linalg.inv(A), B) print(\"Condition number:\", np.linalg.cond(A)) # Knowing the condition number  # construct regression line regress = X[2] * (space ** 2) + X[1] * space + X[0]  # calculate St, Sr, Syx(STD), R^2, R St = np.sum((y - np.mean(y)) ** 2) Sr = np.sum((y - X[0] - X[1] * x - X[2] * (x ** 2)) ** 2) Syx = np.sqrt(Sr / (n - (m + 1))) r2 = (St - Sr) / St r = np.sqrt(r2)  #print(A, B, X) print('Standard Deviation:', Syx) print('Coefficient of determination:', r2) print('Correlation Coefficient:', r)  plt.scatter(x, y, s=15) plt.plot(space, regress, 'r') plt.title(\"Polynomial Regression\") plt.legend(['Regression Line', 'Data Point']) plt.grid()  plt.show() <pre>Condition number: 29878.808747043993\nStandard Deviation: 0.3447712921158663\nCoefficient of determination: 0.9948894656299115\nCorrelation Coefficient: 0.9974414597508525\n</pre>"},{"location":"assignment/a7/22_fall_a7_q1/#2022-fall-assignment7-1","title":"[2022 Fall] Assignment7-1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a7/22_fall_a7_q1/#q7-1","title":"Q7-1\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q1/#a-use-least-squares-regression-to-fit-a-straight-line-compute-the-standard-error-eq179-of-the-estimate-and-the-correlation-coefficient-assess-the-fit-python","title":"a. Use least-squares regression to fit a straight line. Compute the standard error [Eq.17.9] of the estimate and the correlation coefficient. Assess the fit. (Python+\u7e6a\u5716)\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q1/#b-use-polynomial-regression-to-fit-a-parabola-to-the-data-compute-the-standard-error-and-correlation-coefficient-compare-with-a-python","title":"b. Use polynomial regression to fit a parabola to the data. Compute the standard error and correlation coefficient. Compare with (a). (Python+\u7e6a\u5716)\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q2/","title":"[2022 Fall] Assignment7-2","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.array([0.4, 0.8,  1.2,  1.6,    2,  2.3])\ny = np.array([800, 980, 1500, 1945, 2900, 3600])\nlnx = np.log(x)\nlny = np.log(y)\na0 = 1\na1 = 1\n\nspace=np.linspace(0, 2.5) # line space\n\nA = np.zeros((2, 2))\nB = np.zeros(2)\n\n# Construct Matrix for solution\nn = np.size(lnx)\nm = 1\nA[0, 0] = np.size(x)\nA[0, 1] = np.sum(x)\nA[1, 0] = np.sum(x)\nA[1, 1] = np.sum(x ** 2)\nB[0] = np.sum(lny)\nB[1] = np.sum(x * lny)\n\n# Solve AX=B to know a0(X[0]), a1(X[1])\nX = np.inner(np.linalg.inv(A), B)\nprint(\"Condition number: \", np.linalg.cond(A))\n\n# Construct regression line\nregress = X[1] * space + X[0]\nexp_regress = np.exp(regress)\n\n# calculate St, Sr, Syx(STD), R^2, R\nSt = np.sum((lny - np.mean(lny)) ** 2)\nSr = np.sum((lny - X[0] - X[1] * x) ** 2)\nSyx = np.sqrt(Sr / (n - (m + 1)))\nr2 = (St - Sr) / St\nr = np.sqrt(r2)\n\n# R = (A[0, 0] * B[1] - A[0,1] * B[0]) / \n# (np.sqrt(A[0, 0] * A[1, 1] - A[0, 1] ** 2) *\n# np.sqrt(A[0, 0] * np.sum(y ** 2) - B[0] ** 2))\n\nprint('Standard Deviation:', Syx)\nprint('Coefficient of determination:', r2)\nprint('Correlation Coefficient:', r)\n\nplt.scatter(x, y, s=15)\nplt.plot(space, exp_regress, 'r')\nplt.title(\"Exponential Regression\")\nplt.legend(['Regression Line', 'Data Point'])\nplt.grid()\n\nplt.show()\n</pre> import numpy as np import matplotlib.pyplot as plt  x = np.array([0.4, 0.8,  1.2,  1.6,    2,  2.3]) y = np.array([800, 980, 1500, 1945, 2900, 3600]) lnx = np.log(x) lny = np.log(y) a0 = 1 a1 = 1  space=np.linspace(0, 2.5) # line space  A = np.zeros((2, 2)) B = np.zeros(2)  # Construct Matrix for solution n = np.size(lnx) m = 1 A[0, 0] = np.size(x) A[0, 1] = np.sum(x) A[1, 0] = np.sum(x) A[1, 1] = np.sum(x ** 2) B[0] = np.sum(lny) B[1] = np.sum(x * lny)  # Solve AX=B to know a0(X[0]), a1(X[1]) X = np.inner(np.linalg.inv(A), B) print(\"Condition number: \", np.linalg.cond(A))  # Construct regression line regress = X[1] * space + X[0] exp_regress = np.exp(regress)  # calculate St, Sr, Syx(STD), R^2, R St = np.sum((lny - np.mean(lny)) ** 2) Sr = np.sum((lny - X[0] - X[1] * x) ** 2) Syx = np.sqrt(Sr / (n - (m + 1))) r2 = (St - Sr) / St r = np.sqrt(r2)  # R = (A[0, 0] * B[1] - A[0,1] * B[0]) /  # (np.sqrt(A[0, 0] * A[1, 1] - A[0, 1] ** 2) * # np.sqrt(A[0, 0] * np.sum(y ** 2) - B[0] ** 2))  print('Standard Deviation:', Syx) print('Coefficient of determination:', r2) print('Correlation Coefficient:', r)  plt.scatter(x, y, s=15) plt.plot(space, exp_regress, 'r') plt.title(\"Exponential Regression\") plt.legend(['Regression Line', 'Data Point']) plt.grid()  plt.show() <pre>Condition number:  23.74754533671138\nStandard Deviation: 0.053091820126552336\nCoefficient of determination: 0.9935702501670921\nCorrelation Coefficient: 0.9967799406925744\n</pre>"},{"location":"assignment/a7/22_fall_a7_q2/#2022-fall-assignment7-2","title":"[2022 Fall] Assignment7-2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a7/22_fall_a7_q2/#q7-2","title":"Q7-2\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q2/#fit-an-exponential-model-to-the-data-plot-the-data-and-the-equation-on-standardsemi-log-graph-python","title":"Fit an exponential model to the data. Plot the data and the equation on standard/semi-log graph. (Python+\u7e6a\u5716)\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q3/","title":"[2022 Fall] Assignment7-3","text":"In\u00a0[1]: Copied! <pre>def f(m, n):\n    \n    a = (y[m] - y[n]) / (x[m] - x[n])\n\n    return a\n</pre> def f(m, n):          a = (y[m] - y[n]) / (x[m] - x[n])      return a In\u00a0[2]: Copied! <pre>x = [1, 2,  3,  5,   7,   8]\ny = [3, 6, 19, 99, 291, 444]\na = 4\n\nans = y[2] + (a - x[2]) * f(3, 2)\n\nprint(\"Newton's interpolating polynomials f(4) =\", ans)\n</pre> x = [1, 2,  3,  5,   7,   8] y = [3, 6, 19, 99, 291, 444] a = 4  ans = y[2] + (a - x[2]) * f(3, 2)  print(\"Newton's interpolating polynomials f(4) =\", ans) <pre>Newton's interpolating polynomials f(4) = 59.0\n</pre>"},{"location":"assignment/a7/22_fall_a7_q3/#2022-fall-assignment7-3","title":"[2022 Fall] Assignment7-3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a7/22_fall_a7_q3/#q7-3","title":"Q7-3\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q3/#use-newtons-interpolating-polynomials-of-order-1-to-4-to-get-f4-choose-your-base-points-to-attain-good-accuracypython","title":"Use Newton\u2019s interpolating polynomials of order 1 to 4 to get f(4). Choose your base points to attain good accuracy.(Python) (\u7e6a\u5716\u3001\u503c)\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q4/","title":"[2022 Fall] Assignment7-4","text":"In\u00a0[1]: Copied! <pre>def NewtInt(x, y, n, x_miss):\n\n    fdd = np.zeros((n, n))\n    fdd[0:n, 0] = y[0:n]\n\n    for j in range(1, n, 1):\n        for i in range(0, n-j, 1):\n            fdd[i, j] = (fdd[i + 1, j-1] - fdd[i, j - 1]) / (x[i + j] - x[i])\n\n    y_interp = y[0]\n    xterm = 1.0\n\n    for order in range(1, n):\n        xterm = xterm * (x_miss - x[order - 1])\n        y_interp = y_interp + fdd[0, order] * xterm\n\n    return y_interp\n</pre> def NewtInt(x, y, n, x_miss):      fdd = np.zeros((n, n))     fdd[0:n, 0] = y[0:n]      for j in range(1, n, 1):         for i in range(0, n-j, 1):             fdd[i, j] = (fdd[i + 1, j-1] - fdd[i, j - 1]) / (x[i + j] - x[i])      y_interp = y[0]     xterm = 1.0      for order in range(1, n):         xterm = xterm * (x_miss - x[order - 1])         y_interp = y_interp + fdd[0, order] * xterm      return y_interp In\u00a0[2]: Copied! <pre>import numpy as np\n\nx = [1, 2,  3,  5,   7,   8]\ny = [3, 6, 19, 99, 291, 444]\nn = 3\nx_miss = 4\n\nans_New = NewtInt(x, y, n, x_miss)\n\nprint(\"Newton's interpolating polynomials f(4) =\", ans_New)\n</pre> import numpy as np  x = [1, 2,  3,  5,   7,   8] y = [3, 6, 19, 99, 291, 444] n = 3 x_miss = 4  ans_New = NewtInt(x, y, n, x_miss)  print(\"Newton's interpolating polynomials f(4) =\", ans_New) <pre>Newton's interpolating polynomials f(4) = 42.0\n</pre>"},{"location":"assignment/a7/22_fall_a7_q4/#2022-fall-assignment7-4","title":"[2022 Fall] Assignment7-4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a7/22_fall_a7_q4/#q7-4","title":"Q7-4\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q4/#repeat-q186-using-lagrange-polynomials-of-order-1-to-3-python-interpret-your-results-in-word-or-print-in-code","title":"Repeat Q18.6 using Lagrange polynomials of order 1 to 3. (Python) (\u7e6a\u5716\u3001\u503c) Interpret your results in word or print in code\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q5/","title":"[2022 Fall] Assignment7-5","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nT = [     0,      8,    16,    24,    32,    40]\no = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413]\no27_1 = o[3] + (((o[4] - o[3]) / (T[4] - T[3])) * (27 - T[3]))\ntrue_value = 7.986\nea = abs((true_value - o27_1) / true_value)\n\nprint('Linear interpolation o27 =', o27_1)\nprint('exact_result =', 7.986)\nprint('relative error =', ea)\n\nplt.scatter(T, o, s=20)\nplt.scatter(27, o27_1, s=20)\nplt.plot(T, o)\nplt.title(\"Linear interpolation\")\nplt.legend(['Linear interpolation', 'Data point', 'Linear interpolation value'])\nplt.grid()\n\nplt.show()\n</pre> import numpy as np import matplotlib.pyplot as plt  T = [     0,      8,    16,    24,    32,    40] o = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413] o27_1 = o[3] + (((o[4] - o[3]) / (T[4] - T[3])) * (27 - T[3])) true_value = 7.986 ea = abs((true_value - o27_1) / true_value)  print('Linear interpolation o27 =', o27_1) print('exact_result =', 7.986) print('relative error =', ea)  plt.scatter(T, o, s=20) plt.scatter(27, o27_1, s=20) plt.plot(T, o) plt.title(\"Linear interpolation\") plt.legend(['Linear interpolation', 'Data point', 'Linear interpolation value']) plt.grid()  plt.show() <pre>Linear interpolation o27 = 8.000625\nexact_result = 7.986\nrelative error = 0.001831329827197554\n</pre> In\u00a0[2]: Copied! <pre>def f(x, y):\n    \n    a = (o[x] - o[y]) / (T[x] - T[y])\n\n    return a\n\ndef g(x, y, z):\n\n    b = (f(x, y) - f(y, z)) / (T[x] - T[z])\n    \n    return b\n\ndef h(x, y, z, m):\n    \n    c = (g(x, y, z) - g(y, z, m)) / (T[x] - T[m])\n    \n    return c\n    \ndef i(x, y, z, m, n):\n    \n    d = (h(x, y, z, m) - h(y, z, m, n)) / (T[x] - T[n])\n    \n    return d\n</pre> def f(x, y):          a = (o[x] - o[y]) / (T[x] - T[y])      return a  def g(x, y, z):      b = (f(x, y) - f(y, z)) / (T[x] - T[z])          return b  def h(x, y, z, m):          c = (g(x, y, z) - g(y, z, m)) / (T[x] - T[m])          return c      def i(x, y, z, m, n):          d = (h(x, y, z, m) - h(y, z, m, n)) / (T[x] - T[n])          return d In\u00a0[3]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nT = [     0,      8,    16,    24,    32,    40]\no = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413]\ntrue_value = 7.986\n\no27_2 = o[0] \\\n    + (27 - T[0]) * f(1, 0) \\\n    + (27 - T[0]) * (27 - T[1]) * g(2, 1, 0) \\\n    + (27 - T[0]) * (27 - T[1]) * (27 - T[2]) * h(3, 2, 1, 0) \\\n    + (27 - T[0]) * (27 - T[1]) * (27 - T[2]) * (27 - T[3]) * i(4, 3, 2, 1, 0)\n\nea = abs((true_value - o27_2) / true_value)\n\nprint(\"Newton's interpolation o27=\",o27_2)\nprint('exact_result=',7.986)\nprint('relative error=',ea)\n</pre> import numpy as np import matplotlib.pyplot as plt  T = [     0,      8,    16,    24,    32,    40] o = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413] true_value = 7.986  o27_2 = o[0] \\     + (27 - T[0]) * f(1, 0) \\     + (27 - T[0]) * (27 - T[1]) * g(2, 1, 0) \\     + (27 - T[0]) * (27 - T[1]) * (27 - T[2]) * h(3, 2, 1, 0) \\     + (27 - T[0]) * (27 - T[1]) * (27 - T[2]) * (27 - T[3]) * i(4, 3, 2, 1, 0)  ea = abs((true_value - o27_2) / true_value)  print(\"Newton's interpolation o27=\",o27_2) print('exact_result=',7.986) print('relative error=',ea) <pre>Newton's interpolation o27= 7.967420959472656\nexact_result= 7.986\nrelative error= 0.00232645135579064\n</pre> In\u00a0[4]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nT = [     0,      8,    16,    24,    32,    40]\no = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413]\ntrue_value = 7.986\n\ndef cubic_inter(x0, x, y):\n\n    x = np.array(x)\n    y = np.array(y)\n    # remove non finite values\n    # indexes = np.isfinite(x)\n    # check if sorted\n    if np.any(np.diff(x) &lt; 0):\n        indexes = np.argsort(x)\n        x = x[indexes]\n        y = y[indexes]\n\n    size = len(x)\n    xdiff = np.diff(x)\n    ydiff = np.diff(y)\n\n    # allocate buffer matrices\n    Li = np.zeros(size)\n    Li_1 = np.zeros(size - 1)\n    z = np.zeros(size)\n\n    # fill diagonals Li and Li - 1 and solve [L][y] = [B]\n    Li[0] = np.sqrt(2 * xdiff[0])\n    Li_1[0] = 0.0\n    B0 = 0.0 # natural boundary\n    z[0] = B0 / Li[0]\n\n    for i in range(1, size-1, 1):\n        Li_1[i] = xdiff[i - 1] / Li[i - 1]\n        Li[i] = np.sqrt(2 * (xdiff[i - 1] + xdiff[i]) - Li_1[i - 1] * Li_1[i - 1])\n        Bi = 6 * (ydiff[i] / xdiff[i] - ydiff[i - 1] / xdiff[i - 1])\n        z[i] = (Bi - Li_1[i - 1] * z[i - 1]) / Li[i]\n\n    i = size - 1\n    Li_1[i - 1] = xdiff[-1] / Li[i - 1]\n    Li[i] = np.sqrt(2*xdiff[-1] - Li_1[i - 1] * Li_1[i - 1])\n    Bi = 0.0 # natural boundary\n    z[i] = (Bi - Li_1[i - 1]*z[i - 1])/Li[i]\n\n    # solve [L.T][x] = [y]\n    i = size - 1\n    z[i] = z[i] / Li[i]\n    for i in range(size - 2, -1, -1):\n        z[i] = (z[i] - Li_1[i - 1]*z[i+1])/Li[i]\n\n    # find index\n    index = x.searchsorted(x0)\n    np.clip(index, 1, size - 1, index)\n\n    xi1, xi0 = x[index], x[index - 1]\n    yi1, yi0 = y[index], y[index - 1]\n    zi1, zi0 = z[index], z[index - 1]\n    hi1 = xi1 - xi0\n\n    # calculate cubic\n    f0 = zi0 / (6 * hi1) * (xi1 - x0) ** 3 \\\n        + zi1 / (6 * hi1) * (x0 - xi0) ** 3 \\\n        + (yi1 / hi1 - zi1 * hi1 / 6) * (x0 - xi0) \\\n        + (yi0 / hi1 - zi0 * hi1 / 6) * (xi1 - x0)\n    \n    return f0\n</pre> import numpy as np import matplotlib.pyplot as plt  T = [     0,      8,    16,    24,    32,    40] o = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413] true_value = 7.986  def cubic_inter(x0, x, y):      x = np.array(x)     y = np.array(y)     # remove non finite values     # indexes = np.isfinite(x)     # check if sorted     if np.any(np.diff(x) &lt; 0):         indexes = np.argsort(x)         x = x[indexes]         y = y[indexes]      size = len(x)     xdiff = np.diff(x)     ydiff = np.diff(y)      # allocate buffer matrices     Li = np.zeros(size)     Li_1 = np.zeros(size - 1)     z = np.zeros(size)      # fill diagonals Li and Li - 1 and solve [L][y] = [B]     Li[0] = np.sqrt(2 * xdiff[0])     Li_1[0] = 0.0     B0 = 0.0 # natural boundary     z[0] = B0 / Li[0]      for i in range(1, size-1, 1):         Li_1[i] = xdiff[i - 1] / Li[i - 1]         Li[i] = np.sqrt(2 * (xdiff[i - 1] + xdiff[i]) - Li_1[i - 1] * Li_1[i - 1])         Bi = 6 * (ydiff[i] / xdiff[i] - ydiff[i - 1] / xdiff[i - 1])         z[i] = (Bi - Li_1[i - 1] * z[i - 1]) / Li[i]      i = size - 1     Li_1[i - 1] = xdiff[-1] / Li[i - 1]     Li[i] = np.sqrt(2*xdiff[-1] - Li_1[i - 1] * Li_1[i - 1])     Bi = 0.0 # natural boundary     z[i] = (Bi - Li_1[i - 1]*z[i - 1])/Li[i]      # solve [L.T][x] = [y]     i = size - 1     z[i] = z[i] / Li[i]     for i in range(size - 2, -1, -1):         z[i] = (z[i] - Li_1[i - 1]*z[i+1])/Li[i]      # find index     index = x.searchsorted(x0)     np.clip(index, 1, size - 1, index)      xi1, xi0 = x[index], x[index - 1]     yi1, yi0 = y[index], y[index - 1]     zi1, zi0 = z[index], z[index - 1]     hi1 = xi1 - xi0      # calculate cubic     f0 = zi0 / (6 * hi1) * (xi1 - x0) ** 3 \\         + zi1 / (6 * hi1) * (x0 - xi0) ** 3 \\         + (yi1 / hi1 - zi1 * hi1 / 6) * (x0 - xi0) \\         + (yi0 / hi1 - zi0 * hi1 / 6) * (xi1 - x0)          return f0 In\u00a0[5]: Copied! <pre>if __name__ == '__main__':\n\n    x_new = np.linspace(0, 40, 40)\n    plt.scatter(T, o, s=15)\n    plt.scatter(27, cubic_inter(x_new, T, o)[26], s=15)\n    plt.title('Cubic spline')\n    plt.plot(x_new, cubic_inter(x_new,T,o))\n    plt.legend(['Cubic spline','Data point','Cubic spline value'])\n    plt.grid()\n    plt.show()\n\nprint('Cubic spline=', cubic_inter(x_new,T,o)[26])\nprint('exact_result=', 7.986)\nea = abs((true_value - cubic_inter(x_new,T,o)[26])/true_value)\nprint('relative error=',ea)\n</pre> if __name__ == '__main__':      x_new = np.linspace(0, 40, 40)     plt.scatter(T, o, s=15)     plt.scatter(27, cubic_inter(x_new, T, o)[26], s=15)     plt.title('Cubic spline')     plt.plot(x_new, cubic_inter(x_new,T,o))     plt.legend(['Cubic spline','Data point','Cubic spline value'])     plt.grid()     plt.show()  print('Cubic spline=', cubic_inter(x_new,T,o)[26]) print('exact_result=', 7.986) ea = abs((true_value - cubic_inter(x_new,T,o)[26])/true_value) print('relative error=',ea) <pre>Cubic spline= 8.0106776431084\nexact_result= 7.986\nrelative error= 0.003090113086451281\n</pre>"},{"location":"assignment/a7/22_fall_a7_q5/#2022-fall-assignment7-5","title":"[2022 Fall] Assignment7-5\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a7/22_fall_a7_q5/#q7-5","title":"Q7-5\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q5/#1-using-a-linear-interpolation-b-newtons-interpolating-polynomial-c-cubic-splines-to-estimate-o27","title":"1. Using (a) Linear interpolation (b) Newton\u2019s interpolating polynomial (c) Cubic splines to estimate o(27).\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q5/#2-note-that-the-exact-result-is-7986-mgl","title":"2. Note that the exact result is 7.986 mg/L.\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q5/#a-linear-interpolation","title":"(a). Linear interpolation\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q5/#b-newtons-interpolating-polynomial","title":"(b). Newton\u2019s interpolating polynomial\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q5/#c-cubic-splines-to-estimate-o27","title":"(c) Cubic splines to estimate o(27).\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q6/","title":"[2022 Fall] Assignment7-6","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nT = [     0,      8,    16,    24,    32,    40]\no = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413]\n\n\nPI = np.pi\n\ndef f(x):\n\n    return (np.sin(x))**2\n\n\ndef cubic_inter(x0, x, y):\n\n    x = np.array(x)\n    y = np.array(y)\n    # remove non finite values\n    # indexes = np.isfinite(x)\n    # check if sorted\n    if np.any(np.diff(x) &lt; 0):\n        indexes = np.argsort(x)\n        x = x[indexes]\n        y = y[indexes]\n\n    size = len(x)\n    xdiff = np.diff(x)\n    ydiff = np.diff(y)\n\n    # allocate buffer matrices\n    Li = np.zeros(size)\n    Li_1 = np.zeros(size - 1)\n    z = np.zeros(size)\n\n    # fill diagonals Li and Li - 1 and solve [L][y] = [B]\n    Li[0] = np.sqrt(2 * xdiff[0])\n    Li_1[0] = 0.0\n    B0 = 0.0 # natural boundary\n    z[0] = B0 / Li[0]\n\n    for i in range(1, size-1, 1):\n        Li_1[i] = xdiff[i - 1] / Li[i - 1]\n        Li[i] = np.sqrt(2 * (xdiff[i - 1] + xdiff[i]) - Li_1[i - 1] * Li_1[i - 1])\n        Bi = 6 * (ydiff[i] / xdiff[i] - ydiff[i - 1] / xdiff[i - 1])\n        z[i] = (Bi - Li_1[i - 1] * z[i - 1]) / Li[i]\n\n    i = size - 1\n    Li_1[i - 1] = xdiff[-1] / Li[i - 1]\n    Li[i] = np.sqrt(2*xdiff[-1] - Li_1[i - 1] * Li_1[i - 1])\n    Bi = 0.0 # natural boundary\n    z[i] = (Bi - Li_1[i - 1]*z[i - 1])/Li[i]\n\n    # solve [L.T][x] = [y]\n    i = size - 1\n    z[i] = z[i] / Li[i]\n    for i in range(size - 2, -1, -1):\n        z[i] = (z[i] - Li_1[i - 1]*z[i+1])/Li[i]\n\n    # find index\n    index = x.searchsorted(x0)\n    np.clip(index, 1, size - 1, index)\n\n    xi1, xi0 = x[index], x[index - 1]\n    yi1, yi0 = y[index], y[index - 1]\n    zi1, zi0 = z[index], z[index - 1]\n    hi1 = xi1 - xi0\n\n    # calculate cubic\n    f0 = zi0 / (6 * hi1) * (xi1 - x0) ** 3 \\\n        + zi1 / (6 * hi1) * (x0 - xi0) ** 3 \\\n        + (yi1 / hi1 - zi1 * hi1 / 6) * (x0 - xi0) \\\n        + (yi0 / hi1 - zi0 * hi1 / 6) * (xi1 - x0)\n    \n    return f0\n</pre> import numpy as np import matplotlib.pyplot as plt  T = [     0,      8,    16,    24,    32,    40] o = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413]   PI = np.pi  def f(x):      return (np.sin(x))**2   def cubic_inter(x0, x, y):      x = np.array(x)     y = np.array(y)     # remove non finite values     # indexes = np.isfinite(x)     # check if sorted     if np.any(np.diff(x) &lt; 0):         indexes = np.argsort(x)         x = x[indexes]         y = y[indexes]      size = len(x)     xdiff = np.diff(x)     ydiff = np.diff(y)      # allocate buffer matrices     Li = np.zeros(size)     Li_1 = np.zeros(size - 1)     z = np.zeros(size)      # fill diagonals Li and Li - 1 and solve [L][y] = [B]     Li[0] = np.sqrt(2 * xdiff[0])     Li_1[0] = 0.0     B0 = 0.0 # natural boundary     z[0] = B0 / Li[0]      for i in range(1, size-1, 1):         Li_1[i] = xdiff[i - 1] / Li[i - 1]         Li[i] = np.sqrt(2 * (xdiff[i - 1] + xdiff[i]) - Li_1[i - 1] * Li_1[i - 1])         Bi = 6 * (ydiff[i] / xdiff[i] - ydiff[i - 1] / xdiff[i - 1])         z[i] = (Bi - Li_1[i - 1] * z[i - 1]) / Li[i]      i = size - 1     Li_1[i - 1] = xdiff[-1] / Li[i - 1]     Li[i] = np.sqrt(2*xdiff[-1] - Li_1[i - 1] * Li_1[i - 1])     Bi = 0.0 # natural boundary     z[i] = (Bi - Li_1[i - 1]*z[i - 1])/Li[i]      # solve [L.T][x] = [y]     i = size - 1     z[i] = z[i] / Li[i]     for i in range(size - 2, -1, -1):         z[i] = (z[i] - Li_1[i - 1]*z[i+1])/Li[i]      # find index     index = x.searchsorted(x0)     np.clip(index, 1, size - 1, index)      xi1, xi0 = x[index], x[index - 1]     yi1, yi0 = y[index], y[index - 1]     zi1, zi0 = z[index], z[index - 1]     hi1 = xi1 - xi0      # calculate cubic     f0 = zi0 / (6 * hi1) * (xi1 - x0) ** 3 \\         + zi1 / (6 * hi1) * (x0 - xi0) ** 3 \\         + (yi1 / hi1 - zi1 * hi1 / 6) * (x0 - xi0) \\         + (yi0 / hi1 - zi0 * hi1 / 6) * (xi1 - x0)          return f0 In\u00a0[2]: Copied! <pre>if __name__ == '__main__':\n\n    x = [    PI / 4,     PI / 2, PI * 3 / 4, \n                 PI, PI * 5 / 4, PI * 6 / 4,\n         PI * 7 / 4, PI * 2]\n\n    for i in range(0, 8):\n        y = [f(x[i])]\n\n    plt.scatter(T, o, s=15)\n    x_new = np.linspace(0, 2 * PI, 40)\n    plt.title('Cubic spline')\n    plt.plot(x_new, cubic_inter(x_new, x, y),'r')\n    plt.legend(['Cubic spline', 'Data point'])\n    plt.grid()\n    plt.show()\n\n    print('Cubic spline=',cubic_inter(x_new,x,y))\n</pre> if __name__ == '__main__':      x = [    PI / 4,     PI / 2, PI * 3 / 4,                   PI, PI * 5 / 4, PI * 6 / 4,          PI * 7 / 4, PI * 2]      for i in range(0, 8):         y = [f(x[i])]      plt.scatter(T, o, s=15)     x_new = np.linspace(0, 2 * PI, 40)     plt.title('Cubic spline')     plt.plot(x_new, cubic_inter(x_new, x, y),'r')     plt.legend(['Cubic spline', 'Data point'])     plt.grid()     plt.show()      print('Cubic spline=',cubic_inter(x_new,x,y)) <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[2], line 13\n     11 x_new = np.linspace(0, 2 * PI, 40)\n     12 plt.title('Cubic spline')\n---&gt; 13 plt.plot(x_new, cubic_inter(x_new, x, y),'r')\n     14 plt.legend(['Cubic spline', 'Data point'])\n     15 plt.grid()\n\nCell In[1], line 45, in cubic_inter(x0, x, y)\n     43     Li_1[i] = xdiff[i - 1] / Li[i - 1]\n     44     Li[i] = np.sqrt(2 * (xdiff[i - 1] + xdiff[i]) - Li_1[i - 1] * Li_1[i - 1])\n---&gt; 45     Bi = 6 * (ydiff[i] / xdiff[i] - ydiff[i - 1] / xdiff[i - 1])\n     46     z[i] = (Bi - Li_1[i - 1] * z[i - 1]) / Li[i]\n     48 i = size - 1\n\nIndexError: index 1 is out of bounds for axis 0 with size 0</pre> In\u00a0[3]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nPI = np.pi\n\ndef f(x):\n    return (np.sin(x))**2\n\n\nif __name__ == '__main__':\n    x = [PI / 4, PI / 2, PI * 3 / 4, PI, PI * 5 / 4, PI * 6 / 4, PI * 7 / 4, PI * 2]\n    y = [f(val) for val in x]  # Collect all the data points\n\n    plt.scatter(x, y, s=15)\n    x_new = np.linspace(0, 2 * PI, 40)\n    plt.title('Cubic spline')\n    plt.plot(x_new, cubic_inter(x_new, x, y), 'r')\n    plt.legend(['Cubic spline', 'Data point'])\n    plt.grid()\n    plt.show()\n\n    print('Cubic spline=', cubic_inter(x_new, x, y))\n</pre>   import numpy as np import matplotlib.pyplot as plt  PI = np.pi  def f(x):     return (np.sin(x))**2   if __name__ == '__main__':     x = [PI / 4, PI / 2, PI * 3 / 4, PI, PI * 5 / 4, PI * 6 / 4, PI * 7 / 4, PI * 2]     y = [f(val) for val in x]  # Collect all the data points      plt.scatter(x, y, s=15)     x_new = np.linspace(0, 2 * PI, 40)     plt.title('Cubic spline')     plt.plot(x_new, cubic_inter(x_new, x, y), 'r')     plt.legend(['Cubic spline', 'Data point'])     plt.grid()     plt.show()      print('Cubic spline=', cubic_inter(x_new, x, y)) <pre>Cubic spline= [ 5.49132399e-01  3.94337639e-01  3.31184901e-01  3.41987513e-01\n  4.09058800e-01  5.14712089e-01  6.41260707e-01  7.71017980e-01\n  8.86297235e-01  9.69411797e-01  9.97523923e-01  9.52387846e-01\n  8.60999255e-01  7.36849235e-01  5.93428873e-01  4.41792552e-01\n  2.93151586e-01  1.63466774e-01  6.45951955e-02  8.39392907e-03\n  8.67143788e-03  6.53569157e-02  1.64500287e-01  2.94102860e-01\n  4.42165945e-01  5.96605074e-01  7.43981007e-01  8.69888415e-01\n  9.59908322e-01  9.99621753e-01  9.76469601e-01  8.98456594e-01\n  7.83672860e-01  6.50152382e-01  5.15929141e-01  3.96193048e-01\n  2.90739570e-01  1.93573370e-01  9.86687475e-02 -6.93889390e-18]\n</pre>"},{"location":"assignment/a7/22_fall_a7_q6/#2022-fall-assignment7-6","title":"[2022 Fall] Assignment7-6\u00b6","text":"<p>Course: AP3021</p>"},{"location":"assignment/a7/22_fall_a7_q6/#q7-6","title":"Q7-6\u00b6","text":""},{"location":"assignment/a7/22_fall_a7_q6/#1-generate-8-equally-spaced-points-from-f-sin2t-from-0-to-2-fit-this-data-with-a-cubic-splinepython","title":"1. Generate 8 equally-spaced points from f = sin2t from 0 to 2\ud835\udf0b. Fit this data with a cubic spline.(Python+\u7e6a\u5716)\u00b6","text":""},{"location":"assignment/power_spectrum/22_fall_FFT/","title":"FFT Introduction","text":"<p>\u7d66\u5b9a\u4e00\u77e9\u9663 x (t space)\uff0c\u5c0d\u5176\u9032\u884c FFT\uff0c\u7522\u751f y \u77e9\u9663 (s space)</p> In\u00a0[1]: Copied! <pre>import numpy as np\nfrom scipy.fft import fft, ifft\n\nx = np.array([1.0, 2.0, 1.0, -1.0, 1.5])\ny = fft(x)\nyinv = ifft(y)\n</pre> import numpy as np from scipy.fft import fft, ifft  x = np.array([1.0, 2.0, 1.0, -1.0, 1.5]) y = fft(x) yinv = ifft(y) In\u00a0[2]: Copied! <pre>print('y:', y)\n</pre> print('y:', y) <pre>y: [ 4.5       -0.j          2.08155948-1.65109876j -1.83155948+1.60822041j\n -1.83155948-1.60822041j  2.08155948+1.65109876j]\n</pre> In\u00a0[3]: Copied! <pre>print('yinv:', yinv)\n</pre> print('yinv:', yinv) <pre>yinv: [ 1. +0.j  2. +0.j  1. +0.j -1. +0.j  1.5+0.j]\n</pre> In\u00a0[4]: Copied! <pre>print('sum:', np.sum(x))\n</pre> print('sum:', np.sum(x)) <pre>sum: 4.5\n</pre> In\u00a0[5]: Copied! <pre>import numpy as np\nfrom scipy.fft import fft, fftfreq\nimport matplotlib.pyplot as plt\n\n# Number of sample points\nN = 600 \n\n# sample spacing\nT = 1.0 / 800.0 #\u7d66\u5b9a\u9031\u671f\nx = np.linspace(0.0, N*T, N, endpoint=False)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x) #\u5169\u500b\u6ce2\nyf = fft(y) #\u8f49\u63db\nxf = fftfreq(N, T)[:N//2] #\u983b\u7387\n\nplt.figure(2) #\u6ce2\u8b5c\u5206\u6790(s space)\nplt.plot(xf, 2.0/N * np.abs(yf[0:N//2]))\nplt.grid()\n\nplt.figure(1) #\u771f\u5be6\u503c(t space)\nplt.plot(x,y)\n\nplt.show()\n</pre> import numpy as np from scipy.fft import fft, fftfreq import matplotlib.pyplot as plt  # Number of sample points N = 600   # sample spacing T = 1.0 / 800.0 #\u7d66\u5b9a\u9031\u671f x = np.linspace(0.0, N*T, N, endpoint=False) y = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x) #\u5169\u500b\u6ce2 yf = fft(y) #\u8f49\u63db xf = fftfreq(N, T)[:N//2] #\u983b\u7387  plt.figure(2) #\u6ce2\u8b5c\u5206\u6790(s space) plt.plot(xf, 2.0/N * np.abs(yf[0:N//2])) plt.grid()  plt.figure(1) #\u771f\u5be6\u503c(t space) plt.plot(x,y)  plt.show() <p>\u5728\u5169\u500b\u6ce2\u4e2d\u4e58\u4e0a\u4e00\u500b\u6771\u897f(\u9ad8\u65af\u5206\u5e03\u7684\u51fd\u6578)\uff0c\u5c0d\u5176\u9032\u884cFFT\u5206\u6790</p> In\u00a0[6]: Copied! <pre>import numpy as np\nfrom scipy.fft import fft, fftfreq\nfrom scipy.signal import blackman\nimport matplotlib.pyplot as plt\n\n# Number of sample points\nN = 600\n\n# sample spacing\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N, endpoint=False)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = fft(y)\nw = blackman(N) #\u5728\u6ce2\u4e2d\u52a0\u5165\u4e00\u500b\u64fe\u52d5\nywf = fft(y*w)\nxf = fftfreq(N, T)[:N//2]\n\nplt.figure(2) #\u6ce2\u8b5c\u5206\u6790\nplt.semilogy(xf[1:N//2], 2.0/N * np.abs(yf[1:N//2]), '-b')\nplt.semilogy(xf[1:N//2], 2.0/N * np.abs(ywf[1:N//2]), '-r')\nplt.legend(['FFT', 'FFT w. window'])\nplt.grid()\n\nplt.figure(1) #\u771f\u5be6\u6ce2\u758a\u52a0\u5f8c\u7684\u6a23\u5b50\nplt.plot(x,y)\nplt.plot(x,w)\nplt.plot(x,y*w)\nplt.legend(['y', 'w', 'y*w'])\n\n\nplt.show()\n</pre> import numpy as np from scipy.fft import fft, fftfreq from scipy.signal import blackman import matplotlib.pyplot as plt  # Number of sample points N = 600  # sample spacing T = 1.0 / 800.0 x = np.linspace(0.0, N*T, N, endpoint=False) y = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x) yf = fft(y) w = blackman(N) #\u5728\u6ce2\u4e2d\u52a0\u5165\u4e00\u500b\u64fe\u52d5 ywf = fft(y*w) xf = fftfreq(N, T)[:N//2]  plt.figure(2) #\u6ce2\u8b5c\u5206\u6790 plt.semilogy(xf[1:N//2], 2.0/N * np.abs(yf[1:N//2]), '-b') plt.semilogy(xf[1:N//2], 2.0/N * np.abs(ywf[1:N//2]), '-r') plt.legend(['FFT', 'FFT w. window']) plt.grid()  plt.figure(1) #\u771f\u5be6\u6ce2\u758a\u52a0\u5f8c\u7684\u6a23\u5b50 plt.plot(x,y) plt.plot(x,w) plt.plot(x,y*w) plt.legend(['y', 'w', 'y*w'])   plt.show() <pre>/tmp/ipykernel_2657/2852321607.py:14: DeprecationWarning: Importing blackman from 'scipy.signal' is deprecated and will raise an error in SciPy 1.13.0. Please use 'scipy.signal.windows.blackman' or the convenience function 'scipy.signal.get_window' instead.\n  w = blackman(N) #\u5728\u6ce2\u4e2d\u52a0\u5165\u4e00\u500b\u64fe\u52d5\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/power_spectrum/22_fall_FFT/#fft-introduction","title":"FFT Introduction\u00b6","text":"<p>Using <code>scipy.fft</code></p>"},{"location":"assignment/power_spectrum/22_fall_FFT/#example-of-the-fft-of-the-sum-of-two-sines","title":"Example of the FFT of the sum of two sines\u00b6","text":"<p>\u5c07\u5169\u500b\u6ce2\u758a\u52a0\uff0c\u4f7f\u7528FFT\u5206\u6790</p>"},{"location":"assignment/power_spectrum/22_fall_fftnino3ls/","title":"Assignment - Power Spectrum","text":"<p>Read the nino data</p> In\u00a0[1]: Copied! <pre># -*- coding: utf-8 -*-\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, ifft\n\n# Read the Nino data\nfd = open('nindex.dat', 'r')\nmydata = np.genfromtxt(fd,\n                       dtype=('S10', 'float', 'float', 'float', 'float',\n                              'float', 'float', 'float', 'float'),\n                       delimiter=[10, 9, 4, 9, 4, 9, 4, 9, 4],\n                       skip_header=3)\nmydata = np.array(mydata,\n         dtype=[('Week', '&lt;S10'), ('Nino1+2_SST', '&lt;f4'),\n                ('Nino1+2_SSTA', '&lt;f4'), ('Nino3_SST', '&lt;f4'),\n                ('Nino3_SSTA', '&lt;f4'), ('Nino34_SST', '&lt;f4'),\n                ('Nino34_SSTA', '&lt;f4'), ('Nino4_SST', '&lt;f4'),\n                ('Nino4_SSTA', '&lt;f4')])\nfd.close()\n</pre> # -*- coding: utf-8 -*- import numpy as np import matplotlib.pyplot as plt from scipy.fft import fft, fftfreq, ifft  # Read the Nino data fd = open('nindex.dat', 'r') mydata = np.genfromtxt(fd,                        dtype=('S10', 'float', 'float', 'float', 'float',                               'float', 'float', 'float', 'float'),                        delimiter=[10, 9, 4, 9, 4, 9, 4, 9, 4],                        skip_header=3) mydata = np.array(mydata,          dtype=[('Week', ' <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[1], line 7\n      4 from scipy.fft import fft, fftfreq, ifft\n      6 # Read the Nino data\n----&gt; 7 fd = open('nindex.dat', 'r')\n      8 mydata = np.genfromtxt(fd,\n      9                        dtype=('S10', 'float', 'float', 'float', 'float',\n     10                               'float', 'float', 'float', 'float'),\n     11                        delimiter=[10, 9, 4, 9, 4, 9, 4, 9, 4],\n     12                        skip_header=3)\n     13 mydata = np.array(mydata,\n     14          dtype=[('Week', '&lt;S10'), ('Nino1+2_SST', '&lt;f4'),\n     15                 ('Nino1+2_SSTA', '&lt;f4'), ('Nino3_SST', '&lt;f4'),\n     16                 ('Nino3_SSTA', '&lt;f4'), ('Nino34_SST', '&lt;f4'),\n     17                 ('Nino34_SSTA', '&lt;f4'), ('Nino4_SST', '&lt;f4'),\n     18                 ('Nino4_SSTA', '&lt;f4')])\n\nFile /opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/IPython/core/interactiveshell.py:284, in _modified_open(file, *args, **kwargs)\n    277 if file in {0, 1, 2}:\n    278     raise ValueError(\n    279         f\"IPython won't let you open fd={file} by default \"\n    280         \"as it is likely to crash IPython. If you know what you are doing, \"\n    281         \"you can use builtins' open.\"\n    282     )\n--&gt; 284 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'nindex.dat'</pre> <p>ex: Fourier Transform with General Formulas (Sine/Cosine Function)</p> In\u00a0[2]: Copied! <pre>n1 = 'Nino3_SSTA'\nns = 1024  # 20\u5e74\u8cc7\u6599\n# ns = 1081  # 20\u5e74\u8cc7\u6599\nx = mydata[n1][0:ns]\nm = x.size  # Window length\npt = np.arange(m)\n\nno = 101  # \u53d6\u5230\u7b2c101\u9805\nD = np.zeros((m, no))\nD3 = np.zeros((3, no))\nin3 = np.array([400.0, 700.0, 950.0])\nD[:, 0] = 1\na = np.zeros((no))\n\nfor i in range(1, no, 2):\n    D[:, i] = np.cos(i * np.pi * pt / m)\n    D3[:, i] = np.cos(i * np.pi * in3 / m)\n    a[i] = (2 / m) * np.inner(x, np.cos(i * np.pi * pt / ns))\n\nfor i in range(2, no, 2):\n    D[:, i] = np.sin((i - 1) * np.pi * pt / m)\n    D3[:, i] = np.cos((i - 1) * np.pi * in3 / m)\n    a[i] = (2 / m) * np.inner(x, np.sin((i - 1) * np.pi * pt / ns))\n\na[0] = np.sum(x) / m\n# a[1:41] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0b\u7684\u6ce2 (\u6ffe\u9664\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0a\u7684\u6ce2\u632f\u5e45\u8a2d\u70ba0)\na[41::] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0a\u7684\u6ce2 (\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0b\u7684\u6ce2\u7684\u632f\u5e45\u8a2d\u70ba0)\nyr = np.inner(D, a)\nyy = np.inner(D3, a)\n\n# Plot time series\nplt.figure(figsize=(10, 3), dpi=300)\nax = plt.gca()\nplt.plot(pt, x)\nplt.plot(pt, yr, color='red')\nplt.plot(in3,\n         yy,\n         marker='o',\n         markersize=8,\n         linestyle='None',\n         markerfacecolor='None',\n         markeredgecolor='black')\nax.set_xlim([0, ns])\nax.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.title(n1, fontsize=16, fontweight=\"bold\")\nplt.xlabel('# of Week', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\nplt.grid(linestyle='--')\nplt.legend([f'{n1}', f'{n1} (filtered, k=20)'])\nplt.savefig('Nino3_SSTA_formula.jpg',\n            bbox_inches='tight')\n</pre> n1 = 'Nino3_SSTA' ns = 1024  # 20\u5e74\u8cc7\u6599 # ns = 1081  # 20\u5e74\u8cc7\u6599 x = mydata[n1][0:ns] m = x.size  # Window length pt = np.arange(m)  no = 101  # \u53d6\u5230\u7b2c101\u9805 D = np.zeros((m, no)) D3 = np.zeros((3, no)) in3 = np.array([400.0, 700.0, 950.0]) D[:, 0] = 1 a = np.zeros((no))  for i in range(1, no, 2):     D[:, i] = np.cos(i * np.pi * pt / m)     D3[:, i] = np.cos(i * np.pi * in3 / m)     a[i] = (2 / m) * np.inner(x, np.cos(i * np.pi * pt / ns))  for i in range(2, no, 2):     D[:, i] = np.sin((i - 1) * np.pi * pt / m)     D3[:, i] = np.cos((i - 1) * np.pi * in3 / m)     a[i] = (2 / m) * np.inner(x, np.sin((i - 1) * np.pi * pt / ns))  a[0] = np.sum(x) / m # a[1:41] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0b\u7684\u6ce2 (\u6ffe\u9664\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0a\u7684\u6ce2\u632f\u5e45\u8a2d\u70ba0) a[41::] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0a\u7684\u6ce2 (\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0b\u7684\u6ce2\u7684\u632f\u5e45\u8a2d\u70ba0) yr = np.inner(D, a) yy = np.inner(D3, a)  # Plot time series plt.figure(figsize=(10, 3), dpi=300) ax = plt.gca() plt.plot(pt, x) plt.plot(pt, yr, color='red') plt.plot(in3,          yy,          marker='o',          markersize=8,          linestyle='None',          markerfacecolor='None',          markeredgecolor='black') ax.set_xlim([0, ns]) ax.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.title(n1, fontsize=16, fontweight=\"bold\") plt.xlabel('# of Week', fontsize=14) plt.ylabel('Amplitude', fontsize=14) plt.grid(linestyle='--') plt.legend([f'{n1}', f'{n1} (filtered, k=20)']) plt.savefig('Nino3_SSTA_formula.jpg',             bbox_inches='tight') <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 4\n      2 ns = 1024  # 20\u5e74\u8cc7\u6599\n      3 # ns = 1081  # 20\u5e74\u8cc7\u6599\n----&gt; 4 x = mydata[n1][0:ns]\n      5 m = x.size  # Window length\n      6 pt = np.arange(m)\n\nNameError: name 'mydata' is not defined</pre> <p>ex: Fourier/Inversed Fourier Transform with FFT function from Scipy</p> In\u00a0[3]: Copied! <pre>yf = fft(x)\n\n# ------------------------------self code\nplt.plot(yf.real)\nplt.plot(yf.imag)\n\ny0 = yf.copy()\n\nk = 10\ny0[1:1 + k - 1] = 0\ny0[ns - k:ns] = 0\nyt_self = ifft(y0, ns)\n# ------------------------------self code\nk = round(m / 24)\ny01 = np.zeros(ns, dtype=complex)\n\ny01[0] = yf[0]\ny01[1:1 + k - 1] = yf[1:1 + k - 1]\ny01[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_42 = ifft(y01, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n# ------------------------------self code\ny1 = np.zeros(ns, dtype=complex)  #\u8f49\u5b8c\u7684\u8cc7\u6599\u70bacomplex\u5f62\u5f0f\n# print('yf=', yf)\n\nk = 20  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ffe\u9664\u4e00\u5e74\u4ee5\u4e0b\uff0c\u6ce2\u6578\u53d620\ny1[0] = yf[0]\ny1[1:1 + k - 1] = yf[1:1 + k - 1]\ny1[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_20 = ifft(y1, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n\ny2 = np.zeros(ns, dtype=complex)\nk = 10  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d610\ny2[0] = yf[0]\ny2[1:1 + k - 1] = yf[1:1 + k - 1]\ny2[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_10 = ifft(y2, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n\ny3 = np.zeros(ns, dtype=complex)\nk = 5  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d65\ny3[0] = yf[0]\ny3[1:1 + k - 1] = yf[1:1 + k - 1]\ny3[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_5 = ifft(y3, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n\n#\u756b\u5716\ndate = []\nfor i in range(len(mydata['Week'])):\n    date.append(mydata['Week'][i].decode('UTF-8')[1::])\n\nplt.figure(figsize=(10, 9), dpi=300)\n\naxs = plt.subplot(5, 1, 1)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_20, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.title(n1, fontsize=16, fontweight=\"bold\")\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Yearly Filtered (k=20)'])\n\naxs = plt.subplot(5, 1, 2)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_10, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered (k=10)'])\n\naxs = plt.subplot(5, 1, 3)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_5, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xlabel('Date', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered (k=5)'])\n\n# ------------------------------self code\naxs = plt.subplot(5, 1, 4)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_self, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xlabel('Date', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered'])\n# ------------------------------self code\naxs = plt.subplot(5, 1, 5)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_42, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xlabel('Date', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered (k=42)'])\n# ------------------------------self code\n\nplt.savefig('Nino3_SSTA_Scipy.jpg', bbox_inches='tight')\nplt.show()\n</pre> yf = fft(x)  # ------------------------------self code plt.plot(yf.real) plt.plot(yf.imag)  y0 = yf.copy()  k = 10 y0[1:1 + k - 1] = 0 y0[ns - k:ns] = 0 yt_self = ifft(y0, ns) # ------------------------------self code k = round(m / 24) y01 = np.zeros(ns, dtype=complex)  y01[0] = yf[0] y01[1:1 + k - 1] = yf[1:1 + k - 1] y01[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_42 = ifft(y01, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space # ------------------------------self code y1 = np.zeros(ns, dtype=complex)  #\u8f49\u5b8c\u7684\u8cc7\u6599\u70bacomplex\u5f62\u5f0f # print('yf=', yf)  k = 20  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ffe\u9664\u4e00\u5e74\u4ee5\u4e0b\uff0c\u6ce2\u6578\u53d620 y1[0] = yf[0] y1[1:1 + k - 1] = yf[1:1 + k - 1] y1[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_20 = ifft(y1, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space  y2 = np.zeros(ns, dtype=complex) k = 10  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d610 y2[0] = yf[0] y2[1:1 + k - 1] = yf[1:1 + k - 1] y2[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_10 = ifft(y2, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space  y3 = np.zeros(ns, dtype=complex) k = 5  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d65 y3[0] = yf[0] y3[1:1 + k - 1] = yf[1:1 + k - 1] y3[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_5 = ifft(y3, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space  #\u756b\u5716 date = [] for i in range(len(mydata['Week'])):     date.append(mydata['Week'][i].decode('UTF-8')[1::])  plt.figure(figsize=(10, 9), dpi=300)  axs = plt.subplot(5, 1, 1) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_20, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.title(n1, fontsize=16, fontweight=\"bold\") plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Yearly Filtered (k=20)'])  axs = plt.subplot(5, 1, 2) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_10, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered (k=10)'])  axs = plt.subplot(5, 1, 3) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_5, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xlabel('Date', fontsize=14) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered (k=5)'])  # ------------------------------self code axs = plt.subplot(5, 1, 4) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_self, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xlabel('Date', fontsize=14) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered']) # ------------------------------self code axs = plt.subplot(5, 1, 5) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_42, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xlabel('Date', fontsize=14) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered (k=42)']) # ------------------------------self code  plt.savefig('Nino3_SSTA_Scipy.jpg', bbox_inches='tight') plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 yf = fft(x)\n      3 # ------------------------------self code\n      4 plt.plot(yf.real)\n\nNameError: name 'x' is not defined</pre> <p>\u983b\u8b5c\u5206\u6790</p> In\u00a0[4]: Copied! <pre>#FFT Power spectrum\n# dt = 1/m\ndt = 20/m  # m=1024\n\nyf = fft(x)\nxf = fftfreq(m, dt)[:m//2]\n\nplt.figure(figsize=(10, 5), dpi=300)\n\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\n\nplt.plot(xf[1:], 1.0/m * np.abs(yf[1:m//2]))\n\nplt.title(\"Power Spectrum\", fontsize=16, fontweight=\"bold\")\n\nplt.grid(linestyle='--')\nplt.xlim(xf[1], xf[-1])\n\nplt.xlabel('Frequency', fontsize=14)\nplt.ylabel('Intensity', fontsize=14)\n\nplt.savefig(\"./power_spectrum.jpg\")\nplt.show()\n</pre> #FFT Power spectrum # dt = 1/m dt = 20/m  # m=1024  yf = fft(x) xf = fftfreq(m, dt)[:m//2]  plt.figure(figsize=(10, 5), dpi=300)  plt.xticks(fontsize=12) plt.yticks(fontsize=12)  plt.plot(xf[1:], 1.0/m * np.abs(yf[1:m//2]))  plt.title(\"Power Spectrum\", fontsize=16, fontweight=\"bold\")  plt.grid(linestyle='--') plt.xlim(xf[1], xf[-1])  plt.xlabel('Frequency', fontsize=14) plt.ylabel('Intensity', fontsize=14)  plt.savefig(\"./power_spectrum.jpg\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 3\n      1 #FFT Power spectrum\n      2 # dt = 1/m\n----&gt; 3 dt = 20/m  # m=1024\n      5 yf = fft(x)\n      6 xf = fftfreq(m, dt)[:m//2]\n\nNameError: name 'm' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/power_spectrum/22_fall_fftnino3ls/#assignment-power-spectrum","title":"Assignment - Power Spectrum\u00b6","text":"<p>Course: AP3021</p> <p>Student Number: 109601003</p> <p>Name: \u6797\u7fa4\u8cc0</p>"},{"location":"assignment/power_spectrum/22_fall_fftnino3ls/#nino","title":"Nino\u8cc7\u6599\u5be6\u4f5c\u00b6","text":"<p>\u76ee\u6a19\uff1a\u5229\u7528FFT\u53bb\u9664\u9031\u671f\u70ba\u4e00\u5e74\u4ee5\u4e0b\u7684\u9ad8\u983b\u6ce2\u52d5</p> <p>\u8aaa\u660e\uff1a\u5728nindex.dat\u6a94\u6848\u4e2d\uff0c\u6709Nino1+2, Nino3, Nino34, Nino4\u56db\u7d44\u8cc7\u6599\uff0c\u6bcf\u7d44\u8cc7\u6599\u5305\u542bSST\u8207SSTA (Anomaly)</p>"},{"location":"assignment/power_spectrum/fftnino3ls/","title":"Assignment - Power Spectrum","text":"<p>Read the nino data</p> In\u00a0[1]: Copied! <pre># -*- coding: utf-8 -*-\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, ifft\n\n# Read the Nino data\nfd = open('nindex.dat', 'r')\nmydata = np.genfromtxt(fd,\n                       dtype=('S10', 'float', 'float', 'float', 'float',\n                              'float', 'float', 'float', 'float'),\n                       delimiter=[10, 9, 4, 9, 4, 9, 4, 9, 4],\n                       skip_header=3)\nmydata = np.array(mydata,\n         dtype=[('Week', '&lt;S10'), ('Nino1+2_SST', '&lt;f4'),\n                ('Nino1+2_SSTA', '&lt;f4'), ('Nino3_SST', '&lt;f4'),\n                ('Nino3_SSTA', '&lt;f4'), ('Nino34_SST', '&lt;f4'),\n                ('Nino34_SSTA', '&lt;f4'), ('Nino4_SST', '&lt;f4'),\n                ('Nino4_SSTA', '&lt;f4')])\nfd.close()\n</pre> # -*- coding: utf-8 -*- import numpy as np import matplotlib.pyplot as plt from scipy.fft import fft, fftfreq, ifft  # Read the Nino data fd = open('nindex.dat', 'r') mydata = np.genfromtxt(fd,                        dtype=('S10', 'float', 'float', 'float', 'float',                               'float', 'float', 'float', 'float'),                        delimiter=[10, 9, 4, 9, 4, 9, 4, 9, 4],                        skip_header=3) mydata = np.array(mydata,          dtype=[('Week', ' <p>ex: Fourier Transform with General Formulas (Sine/Cosine Function)</p> In\u00a0[2]: Copied! <pre>n1 = 'Nino3_SSTA'\nns = 1024  # 20\u5e74\u8cc7\u6599\n# ns = 1081  # 20\u5e74\u8cc7\u6599\nx = mydata[n1][0:ns]\nm = x.size  # Window length\npt = np.arange(m)\n\nno = 101  # \u53d6\u5230\u7b2c101\u9805\nD = np.zeros((m, no))\nD3 = np.zeros((3, no))\nin3 = np.array([400.0, 700.0, 950.0])\nD[:, 0] = 1\na = np.zeros((no))\n\nfor i in range(1, no, 2):\n    D[:, i] = np.cos(i * np.pi * pt / m)\n    D3[:, i] = np.cos(i * np.pi * in3 / m)\n    a[i] = (2 / m) * np.inner(x, np.cos(i * np.pi * pt / ns))\n\nfor i in range(2, no, 2):\n    D[:, i] = np.sin((i - 1) * np.pi * pt / m)\n    D3[:, i] = np.cos((i - 1) * np.pi * in3 / m)\n    a[i] = (2 / m) * np.inner(x, np.sin((i - 1) * np.pi * pt / ns))\n\na[0] = np.sum(x) / m\n# a[1:41] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0b\u7684\u6ce2 (\u6ffe\u9664\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0a\u7684\u6ce2\u632f\u5e45\u8a2d\u70ba0)\na[41::] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0a\u7684\u6ce2 (\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0b\u7684\u6ce2\u7684\u632f\u5e45\u8a2d\u70ba0)\nyr = np.inner(D, a)\nyy = np.inner(D3, a)\n\n# Plot time series\nplt.figure(figsize=(10, 3), dpi=300)\nax = plt.gca()\nplt.plot(pt, x)\nplt.plot(pt, yr, color='red')\nplt.plot(in3,\n         yy,\n         marker='o',\n         markersize=8,\n         linestyle='None',\n         markerfacecolor='None',\n         markeredgecolor='black')\nax.set_xlim([0, ns])\nax.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.title(n1, fontsize=16, fontweight=\"bold\")\nplt.xlabel('# of Week', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\nplt.grid(linestyle='--')\nplt.legend([f'{n1}', f'{n1} (filtered, k=20)'])\nplt.savefig('Nino3_SSTA_formula.jpg',\n            bbox_inches='tight')\n</pre> n1 = 'Nino3_SSTA' ns = 1024  # 20\u5e74\u8cc7\u6599 # ns = 1081  # 20\u5e74\u8cc7\u6599 x = mydata[n1][0:ns] m = x.size  # Window length pt = np.arange(m)  no = 101  # \u53d6\u5230\u7b2c101\u9805 D = np.zeros((m, no)) D3 = np.zeros((3, no)) in3 = np.array([400.0, 700.0, 950.0]) D[:, 0] = 1 a = np.zeros((no))  for i in range(1, no, 2):     D[:, i] = np.cos(i * np.pi * pt / m)     D3[:, i] = np.cos(i * np.pi * in3 / m)     a[i] = (2 / m) * np.inner(x, np.cos(i * np.pi * pt / ns))  for i in range(2, no, 2):     D[:, i] = np.sin((i - 1) * np.pi * pt / m)     D3[:, i] = np.cos((i - 1) * np.pi * in3 / m)     a[i] = (2 / m) * np.inner(x, np.sin((i - 1) * np.pi * pt / ns))  a[0] = np.sum(x) / m # a[1:41] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0b\u7684\u6ce2 (\u6ffe\u9664\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0a\u7684\u6ce2\u632f\u5e45\u8a2d\u70ba0) a[41::] = 0.0       # \u6ffe\u9664\u6ce2\u6578\u70ba20\u4ee5\u4e0a\u7684\u6ce2 (\u9031\u671f\u5927\u7d04\u70ba\u4e00\u5e74\u4ee5\u4e0b\u7684\u6ce2\u7684\u632f\u5e45\u8a2d\u70ba0) yr = np.inner(D, a) yy = np.inner(D3, a)  # Plot time series plt.figure(figsize=(10, 3), dpi=300) ax = plt.gca() plt.plot(pt, x) plt.plot(pt, yr, color='red') plt.plot(in3,          yy,          marker='o',          markersize=8,          linestyle='None',          markerfacecolor='None',          markeredgecolor='black') ax.set_xlim([0, ns]) ax.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.title(n1, fontsize=16, fontweight=\"bold\") plt.xlabel('# of Week', fontsize=14) plt.ylabel('Amplitude', fontsize=14) plt.grid(linestyle='--') plt.legend([f'{n1}', f'{n1} (filtered, k=20)']) plt.savefig('Nino3_SSTA_formula.jpg',             bbox_inches='tight') <p>ex: Fourier/Inversed Fourier Transform with FFT function from Scipy</p> In\u00a0[3]: Copied! <pre>yf = fft(x)\n\n# ------------------------------self code\nplt.plot(yf.real)\nplt.plot(yf.imag)\n\ny0 = yf.copy()\n\nk = 10\ny0[1:1 + k - 1] = 0\ny0[ns - k:ns] = 0\nyt_self = ifft(y0, ns)\n# ------------------------------self code\nk = round(m / 24)\ny01 = np.zeros(ns, dtype=complex)\n\ny01[0] = yf[0]\ny01[1:1 + k - 1] = yf[1:1 + k - 1]\ny01[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_42 = ifft(y01, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n# ------------------------------self code\ny1 = np.zeros(ns, dtype=complex)  #\u8f49\u5b8c\u7684\u8cc7\u6599\u70bacomplex\u5f62\u5f0f\n# print('yf=', yf)\n\nk = 20  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ffe\u9664\u4e00\u5e74\u4ee5\u4e0b\uff0c\u6ce2\u6578\u53d620\ny1[0] = yf[0]\ny1[1:1 + k - 1] = yf[1:1 + k - 1]\ny1[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_20 = ifft(y1, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n\ny2 = np.zeros(ns, dtype=complex)\nk = 10  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d610\ny2[0] = yf[0]\ny2[1:1 + k - 1] = yf[1:1 + k - 1]\ny2[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_10 = ifft(y2, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n\ny3 = np.zeros(ns, dtype=complex)\nk = 5  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d65\ny3[0] = yf[0]\ny3[1:1 + k - 1] = yf[1:1 + k - 1]\ny3[ns - k:ns] = yf[ns - k:ns]  #conjugate\nyt_5 = ifft(y3, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space\n\n#\u756b\u5716\ndate = []\nfor i in range(len(mydata['Week'])):\n    date.append(mydata['Week'][i].decode('UTF-8')[1::])\n\nplt.figure(figsize=(10, 9), dpi=300)\n\naxs = plt.subplot(5, 1, 1)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_20, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.title(n1, fontsize=16, fontweight=\"bold\")\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Yearly Filtered (k=20)'])\n\naxs = plt.subplot(5, 1, 2)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_10, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered (k=10)'])\n\naxs = plt.subplot(5, 1, 3)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_5, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xlabel('Date', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered (k=5)'])\n\n# ------------------------------self code\naxs = plt.subplot(5, 1, 4)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_self, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xlabel('Date', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered'])\n# ------------------------------self code\naxs = plt.subplot(5, 1, 5)\naxs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599\naxs.plot(pt, yt_42, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599\naxs.set_xlim([0, ns])\naxs.set_ylim([-2, 4])\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.xticks([0, 200, 400, 600, 800, 1000],\n           date[0:1200:200])\nplt.xlabel('Date', fontsize=14)\nplt.ylabel('Amplitude', fontsize=14)\naxs.grid(linestyle='--')\nplt.legend(['Original', 'Filtered (k=42)'])\n# ------------------------------self code\n\nplt.savefig('Nino3_SSTA_Scipy.jpg', bbox_inches='tight')\nplt.show()\n</pre> yf = fft(x)  # ------------------------------self code plt.plot(yf.real) plt.plot(yf.imag)  y0 = yf.copy()  k = 10 y0[1:1 + k - 1] = 0 y0[ns - k:ns] = 0 yt_self = ifft(y0, ns) # ------------------------------self code k = round(m / 24) y01 = np.zeros(ns, dtype=complex)  y01[0] = yf[0] y01[1:1 + k - 1] = yf[1:1 + k - 1] y01[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_42 = ifft(y01, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space # ------------------------------self code y1 = np.zeros(ns, dtype=complex)  #\u8f49\u5b8c\u7684\u8cc7\u6599\u70bacomplex\u5f62\u5f0f # print('yf=', yf)  k = 20  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ffe\u9664\u4e00\u5e74\u4ee5\u4e0b\uff0c\u6ce2\u6578\u53d620 y1[0] = yf[0] y1[1:1 + k - 1] = yf[1:1 + k - 1] y1[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_20 = ifft(y1, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space  y2 = np.zeros(ns, dtype=complex) k = 10  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d610 y2[0] = yf[0] y2[1:1 + k - 1] = yf[1:1 + k - 1] y2[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_10 = ifft(y2, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space  y3 = np.zeros(ns, dtype=complex) k = 5  #\u7e3d\u517120\u5e74\u7684\u8cc7\u6599\uff0c\u6ce2\u6578\u53d65 y3[0] = yf[0] y3[1:1 + k - 1] = yf[1:1 + k - 1] y3[ns - k:ns] = yf[ns - k:ns]  #conjugate yt_5 = ifft(y3, ns)  #\u628a\u6ffe\u904e\u7684\u6ce2\u8f49\u56de\u539f\u672c\u7684t space  #\u756b\u5716 date = [] for i in range(len(mydata['Week'])):     date.append(mydata['Week'][i].decode('UTF-8')[1::])  plt.figure(figsize=(10, 9), dpi=300)  axs = plt.subplot(5, 1, 1) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_20, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.title(n1, fontsize=16, fontweight=\"bold\") plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Yearly Filtered (k=20)'])  axs = plt.subplot(5, 1, 2) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_10, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered (k=10)'])  axs = plt.subplot(5, 1, 3) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_5, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xlabel('Date', fontsize=14) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered (k=5)'])  # ------------------------------self code axs = plt.subplot(5, 1, 4) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_self, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xlabel('Date', fontsize=14) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered']) # ------------------------------self code axs = plt.subplot(5, 1, 5) axs.plot(pt, x)  #\u539f\u672c\u8cc7\u6599 axs.plot(pt, yt_42, color='red')  #\u6ffe\u6ce2\u5f8c\u7684\u8cc7\u6599 axs.set_xlim([0, ns]) axs.set_ylim([-2, 4]) plt.xticks(fontsize=12) plt.yticks(fontsize=12) plt.xticks([0, 200, 400, 600, 800, 1000],            date[0:1200:200]) plt.xlabel('Date', fontsize=14) plt.ylabel('Amplitude', fontsize=14) axs.grid(linestyle='--') plt.legend(['Original', 'Filtered (k=42)']) # ------------------------------self code  plt.savefig('Nino3_SSTA_Scipy.jpg', bbox_inches='tight') plt.show() <pre>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1340: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> <p>\u983b\u8b5c\u5206\u6790</p> In\u00a0[4]: Copied! <pre>#FFT Power spectrum\n# dt = 1/m\ndt = 20/m  # m=1024\n\nyf = fft(x)\nxf = fftfreq(m, dt)[:m//2]\n\nplt.figure(figsize=(10, 5), dpi=300)\n\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\n\nplt.plot(xf[1:], 1.0/m * np.abs(yf[1:m//2]))\n\nplt.title(\"Power Spectrum\", fontsize=16, fontweight=\"bold\")\n\nplt.grid(linestyle='--')\nplt.xlim(xf[1], xf[-1])\n\nplt.xlabel('Frequency', fontsize=14)\nplt.ylabel('Intensity', fontsize=14)\n\nplt.savefig(\"./power_spectrum.jpg\")\nplt.show()\n</pre> #FFT Power spectrum # dt = 1/m dt = 20/m  # m=1024  yf = fft(x) xf = fftfreq(m, dt)[:m//2]  plt.figure(figsize=(10, 5), dpi=300)  plt.xticks(fontsize=12) plt.yticks(fontsize=12)  plt.plot(xf[1:], 1.0/m * np.abs(yf[1:m//2]))  plt.title(\"Power Spectrum\", fontsize=16, fontweight=\"bold\")  plt.grid(linestyle='--') plt.xlim(xf[1], xf[-1])  plt.xlabel('Frequency', fontsize=14) plt.ylabel('Intensity', fontsize=14)  plt.savefig(\"./power_spectrum.jpg\") plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"assignment/power_spectrum/fftnino3ls/#assignment-power-spectrum","title":"Assignment - Power Spectrum\u00b6","text":"<p>Course: AP3021</p> <p>Student Number: 109601003</p> <p>Name: \u6797\u7fa4\u8cc0</p>"},{"location":"assignment/power_spectrum/fftnino3ls/#nino","title":"Nino\u8cc7\u6599\u5be6\u4f5c\u00b6","text":"<p>\u76ee\u6a19\uff1a\u5229\u7528FFT\u53bb\u9664\u9031\u671f\u70ba\u4e00\u5e74\u4ee5\u4e0b\u7684\u9ad8\u983b\u6ce2\u52d5</p> <p>\u8aaa\u660e\uff1a\u5728nindex.dat\u6a94\u6848\u4e2d\uff0c\u6709Nino1+2, Nino3, Nino34, Nino4\u56db\u7d44\u8cc7\u6599\uff0c\u6bcf\u7d44\u8cc7\u6599\u5305\u542bSST\u8207SSTA (Anomaly)</p>"},{"location":"course_note/Week01/","title":"Week01","text":"<p>numerical and analytical are close \u2192 approximation \u2192 we need to consider the error bar</p> <p>through different way;however, we want the same answer.</p> <p>we have to consider how meaningful about analytical sol. \u2192 errors</p> <ul> <li>round off error<ul> <li>finite digits</li> </ul> </li> <li>truncation error<ul> <li>decide the stopping point</li> </ul> </li> </ul> <p>certain digits + estimated digit(half of the smallest scale)</p> <p>accuracy v.s. precision</p> <p>error definition \u2192 percent relative error</p> <p>$0.5 * 10 ^ {(2 - n)}$ (n is the runTimes)</p>"},{"location":"course_note/Week02/","title":"Week02","text":"<p>\u503c\u8d8a\u5927\u8aa4\u5dee\u8d8a\u5927</p> <p>\u8981\u5b58\u53d6\u8f03\u5927\u7684\u503c\uff0cexponent \u4e5f\u8981\u8ddf\u8457\u8b8a\u5927\uff0c\u4e0d\u904e\u4f4d\u5143\u6578\u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u6e96\u78ba\u5ea6\u6703\u964d\u4f4e</p> <p>chopping rounding</p> <p>Note:\u00a0In the interest of making this somewhat self-contained, I am using terminology from the most recent versions of the IEEE-754 standard. Prior to 2008, \"subnormal numbers\" were called \"denormal numbers\", and \"binary32\" was called \"single precision\". Some textbooks/papers/etc may use the old terms.</p> <p>The representation that you are talking about here is called, in IEEE-754, normal numbers. A normal number is one which has a single nonzero digit on the left-hand side of the radix point (i.e. decimal point or binary point) of its mantissa.</p> <p>The representation for zero uses a slightly different representation, namely, subnormal numbers.</p>"},{"location":"course_note/Week03/","title":"Week03","text":""},{"location":"course_note/Week03/#chapter-four","title":"Chapter Four","text":"<p>Step size \u2192 large: error less; small error more and accumulate.   </p> <p>$partial(f(x)) / partial(h) = 0$ \u2192 to get the minimal error.</p> <p>There are three inseting ways to find the error; however, this class we intro the middle way. And we need calculus to find the error.</p> <p>We have to consider round-off error and truncation error to let the numerical error minimize.</p> <p>blunders \u2192 what stupid people did, formulation errors \u2192 there are still some phenomanon that we haven\u2019t certained, data uncertainty</p> <p>How will you improve the accuracy of the divergence? </p> <ul> <li> <p>HW</p> <p>4.3</p> <p>4.8</p> <p>4.23</p> </li> </ul>"},{"location":"course_note/Week03/#chapter-five","title":"Chapter Five","text":"<p>if we meet the complex polynomial \u2192 through graphic method to find the point interect with x-axis.</p> <ul> <li>Bisection:<ul> <li>divided into 2, we can count the truth steps of getting the value what we want.</li> <li>True error never exceeds delta(x) / 2</li> <li>more times</li> </ul> </li> <li>False position:<ul> <li>linear interpolation</li> <li>less times</li> </ul> </li> </ul>"},{"location":"course_note/Week03/#chapter-six","title":"Chapter Six","text":"<ul> <li>Simple fixed-point iteration:<ul> <li>rewrite the funciton \u2192 left-side = right-side</li> </ul> </li> </ul>"},{"location":"course_note/Week04/","title":"Week04","text":""},{"location":"course_note/Week04/#chapter-six","title":"Chapter Six","text":"<ul> <li> <p>Simple fixed-point iteration:</p> <ul> <li>rewrite the funciton \u2192 left-side = right-side</li> </ul> </li> <li> <p>Newton-Raphson</p> </li> <li>review the textbook </li> <li>poor convergence</li> <li> <p>depends on nature of the function and the accuracy of the initial guess -&gt; initial guess is important.</p> </li> <li> <p>Secant method</p> </li> <li>required two initial guess</li> </ul>"},{"location":"course_note/Week05/","title":"Week05","text":""},{"location":"course_note/Week05/#plot","title":"plot","text":""},{"location":"course_note/Week05/#cramers-rule","title":"Cramer's rule","text":""},{"location":"course_note/Week05/#naive-gauss","title":"Naive Gauss","text":"<pre><code>do k = 1, n - 1\ndo i = k + 1, n\nfactor = a(i, k) / a(k, k)\ndo j = k + 1, n\na(i, j) = a(i, j) - factor * a(k, j)\nenddo\nb(i) = b(i) - factor * b(k)\nenddo\nenddo\n</code></pre> <ul> <li>ill-conditioned systems</li> <li>small change in coefficients results in large scale.</li> <li>wide range of the answers.</li> <li> <p>determinant close to zero.</p> </li> <li> <p>condition number</p> </li> <li> <p>standardlize -&gt; pick up the maximum element.</p> </li> <li> <p>Improve</p> </li> <li>use more significant figures</li> <li>pick up the great pivot<ul> <li>avoid divide zero and round-off error</li> </ul> </li> <li>scaling<ul> <li>we not include scaling into the system.</li> </ul> </li> </ul>"},{"location":"course_note/Week05/#flops","title":"Flops","text":""},{"location":"course_note/Week06/","title":"Week06","text":""},{"location":"course_note/Week06/#lu-decomposition","title":"LU Decomposition","text":""},{"location":"course_note/Week06/#choleshy-factorization","title":"Choleshy factorization","text":""},{"location":"course_note/Week06/#matrix-inverse","title":"Matrix inverse","text":""},{"location":"course_note/Week07/","title":"Week07","text":"<p>jacobi -&gt; gauss seidel \u5c0d\u89d2\u7dda\u4e3b\u5c0e</p>"},{"location":"course_note/Week08/","title":"Week08","text":"<p>find the maximum and minimum</p>"},{"location":"course_note/Week09/","title":"Week09","text":"<p>conjugate gradient solver residual</p>"},{"location":"course_note/Week11/","title":"Week11","text":"<p>\u7dda\u6027\u8f49\u63db</p>"},{"location":"course_note/Week12/","title":"Week12","text":"<p>auxilary</p>"},{"location":"past_exam/2021_fall/","title":"[2021 Fall] Final Exam","text":"In\u00a0[\u00a0]: Copied!"},{"location":"past_exam/2021_fall/#2021-fall-final-exam","title":"[2021 Fall] Final Exam\u00b6","text":"<p>Date: 2022/01/12</p> <ol> <li>The given data is the temperature profile of the radiosonde.<ol> <li>Determine the vertical temperature gradient with the central difference method (10%)</li> <li>Determine the determine the temperature at the level of $975hPa$ with the Newton finite difference methods. (10%)</li> <li>Determine the determine the temperature at the level of $975hPa$ with the cubic spline method (10%)</li> <li>Determine the depth of inversion with the Lagrange method (10%)</li> </ol> </li> <li>Please evaluate the total precipitable water (TPW) with the following formula. $$TPW=\\frac{1}{\\rho_wg}\\int_{0}^{Z_T}q(z)dz$$ , where $q(z)$ is the water vapor mixing ratio, $\\rho_w$ is the water density $1000 (kg/m^3)$, g is the gravitational constant $9.8 (m/s^2)$ and $Z_T$ is the top of atmosphere. The vertical distribution of water vapor mixing ratio $(g/Kg)$ can be described as function of height $(km)$ $(Eq. (1))$. $$q(z) = \u22126.01z^8 + 4.92z^7 \u2212 0.024z^4 + 0.13z^3 + \u2212 0.37z^2 \u2212 1.88z + 20.00 (1)$$<ol> <li>Calculate TPW with the trapezoid, Simpson 1/3 and Romberg methods. (24%) Please use the data points from 0 to 10km with an interval of 1km.</li> <li>Calculate TPW with the Gauss-quadrature method (16%)</li> </ol> </li> <li>Given pairs of temperature (\u00b0C) and saturation vapor pressure data (Pa), Please derive the Clausius\u2013Clapeyron (C-C) equation.<ol> <li>Please construct the C-C equation using the LINEAR regression (25%)</li> <li>Please determine the goodness of fitting (5%).</li> </ol> </li> <li>The given data is the ground-based Global Navigation Satellite System (GNSS) zenith total delay on 19 July 2019 with an interval of 30 min (at 15 and 45 minutes). Please apply FFT and find the diurnal component of this data set.</li> </ol>"},{"location":"past_exam/2021_fall/21_fall_q1/","title":"[2021 Fall] Final Exam - Question 1","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n#\u8b80\u8cc7\u6599\nwith open(\"./data/obs_2021-03-18_12_00_00.sound\") as a:\n    for i in range(2):\n        head=a.readline()\n    data=a.readlines()\n    T,P=np.zeros((len(data)))*np.nan,np.zeros((len(data)))*np.nan\n    for i,tmp in enumerate(data):\n        T[i]=tmp.split()[3]\n        P[i]=tmp.split()[0]\n\n#\u78ba\u8a8d\u8cc7\u6599\nplt.figure(figsize=(3,9))      \nplt.scatter(T,P)\nplt.gca().invert_yaxis()\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Pressure (hPa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\nplt.show()\n</pre> import numpy as np import matplotlib.pyplot as plt  #\u8b80\u8cc7\u6599 with open(\"./data/obs_2021-03-18_12_00_00.sound\") as a:     for i in range(2):         head=a.readline()     data=a.readlines()     T,P=np.zeros((len(data)))*np.nan,np.zeros((len(data)))*np.nan     for i,tmp in enumerate(data):         T[i]=tmp.split()[3]         P[i]=tmp.split()[0]  #\u78ba\u8a8d\u8cc7\u6599 plt.figure(figsize=(3,9))       plt.scatter(T,P) plt.gca().invert_yaxis() plt.title(\"Temperature Profile\") plt.ylabel(\"Pressure (hPa)\") plt.xlabel(\"Temperature (degree Celsius)\") plt.show() <p>(a)</p> In\u00a0[2]: Copied! <pre>def D(l, y):    #\u5fae\u5206\uff0c\u4e2d\u63d2\u70ba\u4e3b\uff0c\u524d\u5f8c\u70ba\u524d\u63d2\u53ca\u5f8c\u63d2\n    ans = []\n    h = float(l[1] - l[0])\n    for i in range(0, len(l)):\n        if i == 0:\n            d = (float(y[i+1] - y[i])) / (h)\n        elif i == len(l) - 1:\n            d = (float(y[i] - y[i-1])) / (h)\n        else:            \n            d = (float(y[i+1] - y[i-1])) / (2*h)\n        ans.append(d)\n    return ans\n\ntemp_grad = D(P, T)\n#print(temp_grad)\n\nfor i in range(0, len(temp_grad)):\n    print('When P =', P[i], ', temperature gradient =', temp_grad[i])\n</pre> def D(l, y):    #\u5fae\u5206\uff0c\u4e2d\u63d2\u70ba\u4e3b\uff0c\u524d\u5f8c\u70ba\u524d\u63d2\u53ca\u5f8c\u63d2     ans = []     h = float(l[1] - l[0])     for i in range(0, len(l)):         if i == 0:             d = (float(y[i+1] - y[i])) / (h)         elif i == len(l) - 1:             d = (float(y[i] - y[i-1])) / (h)         else:                         d = (float(y[i+1] - y[i-1])) / (2*h)         ans.append(d)     return ans  temp_grad = D(P, T) #print(temp_grad)  for i in range(0, len(temp_grad)):     print('When P =', P[i], ', temperature gradient =', temp_grad[i]) <pre>When P = 1009.9839 , temperature gradient = 0.07667405009371818\nWhen P = 1008.8101 , temperature gradient = 0.05111603339581111\nWhen P = 1008.2232 , temperature gradient = 0.055375702845462796\nWhen P = 1007.0579 , temperature gradient = 0.059635372295114474\nWhen P = 1006.476 , temperature gradient = 0.029817686147557237\nWhen P = 1005.894 , temperature gradient = 0.02555801669790707\nWhen P = 1005.3077 , temperature gradient = 0.04259669449650926\nWhen P = 1004.1254 , temperature gradient = 0.04685636394616094\nWhen P = 1003.5343 , temperature gradient = 0.029817686147557237\nWhen P = 1002.9434 , temperature gradient = 0.029817686147557237\nWhen P = 1002.3524 , temperature gradient = 0.029817686147557237\nWhen P = 1001.7685 , temperature gradient = 0.04259669449650926\nWhen P = 1000.6122 , temperature gradient = 0.03833702504685909\nWhen P = 1000.0319 , temperature gradient = 0.03407735559720892\nWhen P = 998.8713 , temperature gradient = 0.051116033395812624\nWhen P = 998.291 , temperature gradient = 0.04685636394616094\nWhen P = 997.711 , temperature gradient = 0.03407735559720892\nWhen P = 997.1311 , temperature gradient = 0.025558016697905556\nWhen P = 996.5512 , temperature gradient = 0.029817686147555724\nWhen P = 995.3936 , temperature gradient = 0.029817686147557237\nWhen P = 994.8185 , temperature gradient = 0.021298347248255387\nWhen P = 994.2434 , temperature gradient = 0.02555801669790707\nWhen P = 992.5253 , temperature gradient = 0.017038677798605215\nWhen P = 991.9564 , temperature gradient = -0.008519338899303366\nWhen P = 990.8186 , temperature gradient = -0.012779008348953534\nWhen P = 990.2497 , temperature gradient = -0.021298347248253875\nWhen P = 989.6808 , temperature gradient = -0.06389504174476617\nWhen P = 988.543 , temperature gradient = -0.06815471119441632\nWhen P = 987.9741 , temperature gradient = -0.04259669449650926\nWhen P = 987.4052 , temperature gradient = -0.07667405009371818\nWhen P = 986.2715 , temperature gradient = -0.1490884307377862\nWhen P = 985.1433 , temperature gradient = -0.14482876128813452\nWhen P = 984.5792 , temperature gradient = -0.11075140569092559\nWhen P = 984.0151 , temperature gradient = -0.11927074459022895\nWhen P = 983.451 , temperature gradient = -0.24280115863010807\nWhen P = 981.1947 , temperature gradient = -0.22576248083150438\nWhen P = 980.6306 , temperature gradient = -0.18316578633499359\nWhen P = 979.5024 , temperature gradient = -0.19594479468394713\nWhen P = 978.9383 , temperature gradient = -0.09371272789232339\nWhen P = 978.3742 , temperature gradient = -0.10649173624127542\nWhen P = 977.2461 , temperature gradient = -0.11501107514057726\nWhen P = 976.6839 , temperature gradient = -0.09371272789232188\nWhen P = 976.1262 , temperature gradient = -0.08945305844267172\nWhen P = 975.5685 , temperature gradient = -0.08093371954336986\nWhen P = 975.0108 , temperature gradient = -0.10223206679162374\nWhen P = 973.8953 , temperature gradient = -0.09371272789232188\nWhen P = 973.3376 , temperature gradient = -0.11501107514057726\nWhen P = 971.1068 , temperature gradient = -0.11927074459022895\nWhen P = 970.5491 , temperature gradient = -0.055375702845462796\nWhen P = 969.9914 , temperature gradient = -0.034077355597207405\nWhen P = 969.4336 , temperature gradient = -0.029817686147557237\nWhen P = 968.8759 , temperature gradient = -0.025558016697905556\nWhen P = 968.3182 , temperature gradient = -0.021298347248255387\nWhen P = 967.7605 , temperature gradient = -0.029817686147557237\nWhen P = 967.2028 , temperature gradient = -0.04685636394616094\nWhen P = 966.0954 , temperature gradient = -0.04685636394616094\nWhen P = 965.5427 , temperature gradient = -0.03407735559720892\nWhen P = 964.4375 , temperature gradient = -0.0383370250468606\nWhen P = 963.3322 , temperature gradient = -0.025558016697905556\nWhen P = 962.7796 , temperature gradient = -0.012779008348952021\nWhen P = 962.2269 , temperature gradient = -0.017038677798603703\nWhen P = 961.6743 , temperature gradient = -0.029817686147557237\nWhen P = 960.569 , temperature gradient = -0.02555801669790707\nWhen P = 960.0164 , temperature gradient = -0.008519338899301851\nWhen P = 959.4638 , temperature gradient = -0.012779008348952021\nWhen P = 958.3585 , temperature gradient = -0.012779008348953534\nWhen P = 957.8059 , temperature gradient = -0.008519338899301851\nWhen P = 957.2533 , temperature gradient = -0.008519338899301851\nWhen P = 956.7043 , temperature gradient = -0.012779008348953534\nWhen P = 954.5158 , temperature gradient = -0.008519338899301851\nWhen P = 953.9686 , temperature gradient = -0.0\nWhen P = 953.4215 , temperature gradient = -0.004259669449651683\nWhen P = 952.8744 , temperature gradient = -0.0\nWhen P = 951.7801 , temperature gradient = 0.004259669449651683\nWhen P = 951.233 , temperature gradient = -0.0\nWhen P = 950.6858 , temperature gradient = 0.004259669449650169\nWhen P = 949.5915 , temperature gradient = 0.008519338899301851\nWhen P = 948.4973 , temperature gradient = 0.008519338899303366\nWhen P = 947.9501 , temperature gradient = 0.004259669449651683\nWhen P = 947.403 , temperature gradient = 0.012779008348952021\nWhen P = 946.3202 , temperature gradient = 0.017038677798603703\nWhen P = 945.7802 , temperature gradient = 0.012779008348953534\nWhen P = 944.7002 , temperature gradient = 0.012779008348952021\nWhen P = 944.1602 , temperature gradient = 0.008519338899301851\nWhen P = 943.6202 , temperature gradient = 0.008519338899303366\nWhen P = 943.0801 , temperature gradient = 0.012779008348953534\nWhen P = 942.5401 , temperature gradient = 0.017038677798603703\nWhen P = 942.0001 , temperature gradient = 0.021298347248253875\nWhen P = 940.9201 , temperature gradient = 0.017038677798603703\nWhen P = 940.3801 , temperature gradient = 0.012779008348953534\nWhen P = 939.8401 , temperature gradient = 0.029817686147557237\nWhen P = 938.22 , temperature gradient = 0.042596694496510774\nWhen P = 937.14 , temperature gradient = 0.034077355597207405\nWhen P = 936.06 , temperature gradient = 0.021298347248255387\nWhen P = 935.52 , temperature gradient = 0.017038677798605215\nWhen P = 934.98 , temperature gradient = 0.012779008348952021\nWhen P = 934.4399 , temperature gradient = 0.017038677798603703\nWhen P = 933.8999 , temperature gradient = 0.02555801669790707\nWhen P = 933.3599 , temperature gradient = 0.021298347248255387\nWhen P = 932.8199 , temperature gradient = 0.021298347248253875\nWhen P = 932.281 , temperature gradient = 0.034077355597207405\nWhen P = 931.2151 , temperature gradient = 0.03407735559720892\nWhen P = 930.6822 , temperature gradient = 0.029817686147557237\nWhen P = 929.6163 , temperature gradient = 0.03833702504685909\nWhen P = 928.5503 , temperature gradient = 0.03833702504685909\nWhen P = 928.0174 , temperature gradient = 0.029817686147557237\nWhen P = 927.4844 , temperature gradient = 0.029817686147557237\nWhen P = 926.4185 , temperature gradient = 0.03833702504685909\nWhen P = 925.3526 , temperature gradient = 0.03407735559720892\nWhen P = 924.8197 , temperature gradient = 0.021298347248255387\nWhen P = 924.2867 , temperature gradient = 0.021298347248253875\nWhen P = 923.7538 , temperature gradient = 0.029817686147557237\nWhen P = 923.2208 , temperature gradient = 0.042596694496510774\nWhen P = 922.1549 , temperature gradient = 0.04259669449650926\nWhen P = 921.089 , temperature gradient = 0.025558016697905556\nWhen P = 920.5561 , temperature gradient = 0.02555801669790707\nWhen P = 920.0231 , temperature gradient = 0.059635372295114474\nWhen P = 918.4242 , temperature gradient = 0.05963537229511296\nWhen P = 917.3583 , temperature gradient = 0.02555801669790707\nWhen P = 916.8254 , temperature gradient = 0.02555801669790707\nWhen P = 916.2924 , temperature gradient = 0.029817686147555724\nWhen P = 915.7595 , temperature gradient = 0.04259669449650926\nWhen P = 914.6936 , temperature gradient = 0.04685636394616245\nWhen P = 914.1606 , temperature gradient = 0.029817686147557237\nWhen P = 913.6277 , temperature gradient = 0.034077355597207405\nWhen P = 912.5624 , temperature gradient = 0.04685636394616094\nWhen P = 911.5148 , temperature gradient = 0.059635372295114474\nWhen P = 910.4672 , temperature gradient = 0.04685636394616245\nWhen P = 909.9434 , temperature gradient = 0.025558016697905556\nWhen P = 909.4196 , temperature gradient = 0.021298347248253875\nWhen P = 908.8958 , temperature gradient = 0.042596694496510774\nWhen P = 907.8482 , temperature gradient = 0.04685636394616245\nWhen P = 907.3244 , temperature gradient = 0.029817686147557237\nWhen P = 906.8006 , temperature gradient = 0.029817686147555724\nWhen P = 906.2768 , temperature gradient = 0.029817686147557237\nWhen P = 905.753 , temperature gradient = 0.05537570284546431\nWhen P = 904.1816 , temperature gradient = 0.04685636394616094\nWhen P = 903.6578 , temperature gradient = 0.025558016697905556\nWhen P = 903.134 , temperature gradient = 0.029817686147557237\nWhen P = 902.6102 , temperature gradient = 0.025558016697905556\nWhen P = 902.0864 , temperature gradient = 0.055375702845462796\nWhen P = 900.515 , temperature gradient = 0.051116033395812624\nWhen P = 899.9912 , temperature gradient = 0.021298347248255387\nWhen P = 899.4674 , temperature gradient = 0.021298347248255387\nWhen P = 898.9436 , temperature gradient = 0.029817686147557237\nWhen P = 897.896 , temperature gradient = 0.03833702504685909\nWhen P = 897.3722 , temperature gradient = 0.029817686147557237\nWhen P = 896.8484 , temperature gradient = 0.03407735559720892\nWhen P = 895.8008 , temperature gradient = 0.034077355597207405\nWhen P = 895.277 , temperature gradient = 0.025558016697905556\nWhen P = 894.7532 , temperature gradient = 0.021298347248255387\nWhen P = 894.2294 , temperature gradient = 0.017038677798603703\nWhen P = 893.7056 , temperature gradient = 0.055375702845462796\nWhen P = 891.6313 , temperature gradient = 0.059635372295114474\nWhen P = 891.1165 , temperature gradient = 0.02555801669790707\nWhen P = 890.6017 , temperature gradient = 0.021298347248255387\nWhen P = 890.0869 , temperature gradient = 0.021298347248253875\nWhen P = 889.5721 , temperature gradient = 0.025558016697905556\nWhen P = 889.0572 , temperature gradient = 0.02555801669790707\nWhen P = 888.5424 , temperature gradient = 0.029817686147557237\nWhen P = 888.0276 , temperature gradient = 0.025558016697905556\nWhen P = 887.5128 , temperature gradient = 0.021298347248255387\nWhen P = 886.998 , temperature gradient = 0.02555801669790707\nWhen P = 886.4832 , temperature gradient = 0.025558016697905556\nWhen P = 885.9684 , temperature gradient = 0.021298347248253875\nWhen P = 885.4536 , temperature gradient = 0.017038677798603703\nWhen P = 884.9388 , temperature gradient = 0.04685636394616094\nWhen P = 883.9092 , temperature gradient = 0.06389504174476617\nWhen P = 882.8796 , temperature gradient = 0.03407735559720892\nWhen P = 882.3648 , temperature gradient = 0.04259669449650926\nWhen P = 881.3352 , temperature gradient = 0.042596694496510774\nWhen P = 880.8204 , temperature gradient = 0.02555801669790707\nWhen P = 880.3056 , temperature gradient = 0.05963537229511296\nWhen P = 879.2759 , temperature gradient = 0.051116033395812624\nWhen P = 878.7611 , temperature gradient = 0.021298347248255387\nWhen P = 878.2463 , temperature gradient = 0.025558016697905556\nWhen P = 877.7315 , temperature gradient = 0.021298347248255387\nWhen P = 877.2167 , temperature gradient = 0.06815471119441632\nWhen P = 875.6723 , temperature gradient = 0.08093371954336986\nWhen P = 874.6427 , temperature gradient = 0.03833702504685909\nWhen P = 874.1279 , temperature gradient = 0.034077355597207405\nWhen P = 873.6131 , temperature gradient = 0.029817686147557237\nWhen P = 873.0983 , temperature gradient = 0.021298347248255387\nWhen P = 872.5922 , temperature gradient = 0.025558016697905556\nWhen P = 872.0867 , temperature gradient = 0.055375702845462796\nWhen P = 871.0758 , temperature gradient = 0.04685636394616094\nWhen P = 870.5703 , temperature gradient = 0.021298347248255387\nWhen P = 870.0648 , temperature gradient = 0.021298347248255387\nWhen P = 869.5594 , temperature gradient = 0.025558016697905556\nWhen P = 869.0539 , temperature gradient = 0.042596694496510774\nWhen P = 868.043 , temperature gradient = 0.03833702504685909\nWhen P = 867.5375 , temperature gradient = 0.04685636394616094\nWhen P = 866.5265 , temperature gradient = 0.04685636394616245\nWhen P = 866.0211 , temperature gradient = 0.021298347248255387\nWhen P = 865.5156 , temperature gradient = 0.017038677798603703\nWhen P = 865.0101 , temperature gradient = 0.03833702504685909\nWhen P = 863.9992 , temperature gradient = 0.04685636394616094\nWhen P = 863.4937 , temperature gradient = 0.029817686147557237\nWhen P = 862.9882 , temperature gradient = 0.025558016697905556\nWhen P = 862.4828 , temperature gradient = 0.025558016697905556\nWhen P = 861.9773 , temperature gradient = 0.03833702504685909\nWhen P = 860.9664 , temperature gradient = 0.051116033395812624\nWhen P = 859.9554 , temperature gradient = 0.05537570284546431\nWhen P = 858.9445 , temperature gradient = 0.059635372295114474\nWhen P = 857.9335 , temperature gradient = 0.03833702504685909\nWhen P = 857.428 , temperature gradient = 0.025558016697905556\nWhen P = 856.9226 , temperature gradient = 0.04259669449650926\nWhen P = 855.9116 , temperature gradient = 0.051116033395812624\nWhen P = 854.9007 , temperature gradient = 0.042596694496510774\nWhen P = 854.3952 , temperature gradient = 0.03833702504685909\nWhen P = 853.3843 , temperature gradient = 0.029817686147557237\nWhen P = 852.8895 , temperature gradient = 0.021298347248253875\nWhen P = 852.3964 , temperature gradient = 0.025558016697905556\nWhen P = 851.9033 , temperature gradient = 0.029817686147557237\nWhen P = 850.9171 , temperature gradient = 0.029817686147557237\nWhen P = 850.424 , temperature gradient = 0.021298347248255387\nWhen P = 849.9309 , temperature gradient = 0.021298347248255387\nWhen P = 849.4378 , temperature gradient = 0.02555801669790707\nWhen P = 848.4516 , temperature gradient = 0.029817686147557237\nWhen P = 847.4654 , temperature gradient = 0.029817686147555724\nWhen P = 846.9723 , temperature gradient = 0.029817686147557237\nWhen P = 845.9861 , temperature gradient = 0.04685636394616245\nWhen P = 844.5068 , temperature gradient = 0.05111603339581111\nWhen P = 843.5206 , temperature gradient = 0.034077355597207405\nWhen P = 843.0275 , temperature gradient = 0.021298347248255387\nWhen P = 842.5344 , temperature gradient = 0.021298347248255387\nWhen P = 842.0413 , temperature gradient = 0.021298347248255387\nWhen P = 841.5482 , temperature gradient = 0.017038677798603703\nWhen P = 841.0551 , temperature gradient = 0.025558016697905556\nWhen P = 840.562 , temperature gradient = 0.029817686147557237\nWhen P = 840.069 , temperature gradient = 0.02555801669790707\nWhen P = 839.5759 , temperature gradient = 0.06389504174476464\nWhen P = 837.6035 , temperature gradient = 0.059635372295114474\nWhen P = 837.1104 , temperature gradient = 0.017038677798605215\nWhen P = 836.6173 , temperature gradient = 0.029817686147557237\nWhen P = 835.6311 , temperature gradient = 0.034077355597207405\nWhen P = 835.138 , temperature gradient = 0.021298347248253875\nWhen P = 834.6449 , temperature gradient = 0.017038677798603703\nWhen P = 834.1518 , temperature gradient = 0.021298347248255387\nWhen P = 833.1656 , temperature gradient = 0.017038677798605215\nWhen P = 832.6725 , temperature gradient = 0.008519338899301851\nWhen P = 832.1794 , temperature gradient = 0.008519338899301851\nWhen P = 831.6863 , temperature gradient = 0.008519338899301851\nWhen P = 831.1932 , temperature gradient = 0.008519338899301851\nWhen P = 830.207 , temperature gradient = 0.004259669449651683\nWhen P = 829.7139 , temperature gradient = -0.0\nWhen P = 828.7277 , temperature gradient = -0.0\nWhen P = 828.241 , temperature gradient = -0.0\nWhen P = 827.2696 , temperature gradient = -0.004259669449651683\nWhen P = 826.784 , temperature gradient = -0.004259669449651683\nWhen P = 826.2983 , temperature gradient = -0.0\nWhen P = 825.8126 , temperature gradient = -0.0\nWhen P = 825.3269 , temperature gradient = -0.0\nWhen P = 824.8413 , temperature gradient = -0.004259669449650169\nWhen P = 824.3556 , temperature gradient = -0.004259669449650169\nWhen P = 823.8699 , temperature gradient = -0.0\nWhen P = 823.3842 , temperature gradient = -0.0\nWhen P = 822.4129 , temperature gradient = -0.0\nWhen P = 821.9272 , temperature gradient = -0.0\nWhen P = 821.4415 , temperature gradient = -0.0\nWhen P = 820.9559 , temperature gradient = -0.0\nWhen P = 819.9845 , temperature gradient = -0.0\nWhen P = 819.0132 , temperature gradient = -0.0\nWhen P = 818.5275 , temperature gradient = 0.004259669449650169\nWhen P = 817.5561 , temperature gradient = 0.004259669449650169\nWhen P = 817.0705 , temperature gradient = 0.004259669449651683\nWhen P = 816.0991 , temperature gradient = 0.004259669449651683\nWhen P = 815.6134 , temperature gradient = -0.0\nWhen P = 815.1278 , temperature gradient = 0.004259669449650169\nWhen P = 814.6421 , temperature gradient = 0.004259669449650169\nWhen P = 814.1564 , temperature gradient = -0.0\nWhen P = 812.6994 , temperature gradient = 0.004259669449651683\nWhen P = 812.2137 , temperature gradient = 0.004259669449651683\nWhen P = 811.7281 , temperature gradient = -0.0\nWhen P = 811.2424 , temperature gradient = -0.0\nWhen P = 810.7567 , temperature gradient = -0.0\nWhen P = 810.271 , temperature gradient = -0.0\nWhen P = 809.2997 , temperature gradient = -0.0\nWhen P = 808.8165 , temperature gradient = -0.0\nWhen P = 807.8641 , temperature gradient = -0.0\nWhen P = 807.3879 , temperature gradient = -0.0\nWhen P = 806.9117 , temperature gradient = -0.0\nWhen P = 805.9594 , temperature gradient = -0.0\nWhen P = 805.4832 , temperature gradient = -0.0\nWhen P = 805.007 , temperature gradient = -0.0\nWhen P = 804.5308 , temperature gradient = -0.0\nWhen P = 804.0546 , temperature gradient = -0.0\nWhen P = 803.5784 , temperature gradient = -0.0\nWhen P = 803.1022 , temperature gradient = -0.0\nWhen P = 802.626 , temperature gradient = -0.0\nWhen P = 802.1498 , temperature gradient = 0.004259669449651683\nWhen P = 801.1975 , temperature gradient = 0.004259669449651683\nWhen P = 800.7213 , temperature gradient = 0.004259669449650169\nWhen P = 799.7689 , temperature gradient = 0.004259669449650169\nWhen P = 799.2927 , temperature gradient = 0.008519338899301851\nWhen P = 798.3479 , temperature gradient = 0.008519338899301851\nWhen P = 797.8766 , temperature gradient = 0.004259669449651683\nWhen P = 797.4053 , temperature gradient = 0.008519338899301851\nWhen P = 796.934 , temperature gradient = 0.008519338899301851\nWhen P = 796.4628 , temperature gradient = 0.008519338899303366\nWhen P = 795.9915 , temperature gradient = 0.008519338899301851\nWhen P = 795.5202 , temperature gradient = 0.012779008348952021\nWhen P = 795.0489 , temperature gradient = 0.021298347248255387\nWhen P = 794.1063 , temperature gradient = 0.017038677798603703\nWhen P = 793.635 , temperature gradient = 0.017038677798603703\nWhen P = 792.6924 , temperature gradient = 0.042596694496510774\nWhen P = 791.2786 , temperature gradient = 0.03833702504685909\nWhen P = 790.8073 , temperature gradient = 0.021298347248255387\nWhen P = 790.336 , temperature gradient = 0.01703867779860446\nWhen P = 789.8647 , temperature gradient = 0.012779008348952778\nWhen P = 789.3934 , temperature gradient = 0.017038677798603703\nWhen P = 788.9251 , temperature gradient = 0.021298347248255387\nWhen P = 788.4586 , temperature gradient = 0.046856363946161696\nWhen P = 787.0592 , temperature gradient = 0.06815471119441632\nWhen P = 785.6598 , temperature gradient = 0.04259669449651002\nWhen P = 785.1933 , temperature gradient = 0.025558016697905556\nWhen P = 784.7268 , temperature gradient = 0.029817686147557237\nWhen P = 784.2604 , temperature gradient = 0.025558016697906312\nWhen P = 783.7939 , temperature gradient = 0.025558016697905556\nWhen P = 783.3274 , temperature gradient = 0.021298347248255387\nWhen P = 782.8609 , temperature gradient = 0.046856363946161696\nWhen P = 781.4615 , temperature gradient = 0.04685636394616094\nWhen P = 780.9951 , temperature gradient = 0.04259669449651002\nWhen P = 780.0621 , temperature gradient = 0.04685636394616094\nWhen P = 779.5956 , temperature gradient = 0.02129834724825463\nWhen P = 779.1312 , temperature gradient = 0.01703867779860446\nWhen P = 778.6692 , temperature gradient = 0.025558016697906312\nWhen P = 778.2073 , temperature gradient = 0.029817686147557237\nWhen P = 777.7453 , temperature gradient = 0.021298347248255387\nWhen P = 777.2833 , temperature gradient = 0.05111603339581187\nWhen P = 775.8973 , temperature gradient = 0.05963537229511372\nWhen P = 775.4353 , temperature gradient = 0.03833702504685909\nWhen P = 774.5113 , temperature gradient = 0.042596694496510774\nWhen P = 773.5873 , temperature gradient = 0.03407735559720816\nWhen P = 773.1253 , temperature gradient = 0.04685636394616094\nWhen P = 772.2014 , temperature gradient = 0.04259669449651002\nWhen P = 771.7394 , temperature gradient = 0.017038677798603703\nWhen P = 771.2774 , temperature gradient = 0.01703867779860446\nWhen P = 770.8154 , temperature gradient = 0.038337025046859846\nWhen P = 769.8914 , temperature gradient = 0.04685636394616094\nWhen P = 769.4299 , temperature gradient = 0.02981768614755648\nWhen P = 768.9726 , temperature gradient = 0.029817686147557237\nWhen P = 768.5154 , temperature gradient = 0.03407735559720816\nWhen P = 768.0581 , temperature gradient = 0.025558016697906312\nWhen P = 767.6008 , temperature gradient = 0.021298347248255387\nWhen P = 767.1436 , temperature gradient = 0.02981768614755648\nWhen P = 766.6863 , temperature gradient = 0.05111603339581187\nWhen P = 765.7718 , temperature gradient = 0.051116033395812624\nWhen P = 765.3145 , temperature gradient = 0.03407735559720816\nWhen P = 764.8572 , temperature gradient = 0.03833702504685909\nWhen P = 764.4 , temperature gradient = 0.042596694496510774\nWhen P = 763.4854 , temperature gradient = 0.04259669449651002\nWhen P = 763.0282 , temperature gradient = 0.03833702504685909\nWhen P = 762.5709 , temperature gradient = 0.03833702504685909\nWhen P = 762.1136 , temperature gradient = 0.055375702845462796\nWhen P = 761.1991 , temperature gradient = 0.05537570284546355\nWhen P = 760.7419 , temperature gradient = 0.03407735559720816\nWhen P = 760.2846 , temperature gradient = 0.025558016697906312\nWhen P = 759.8273 , temperature gradient = 0.029817686147557237\nWhen P = 759.3725 , temperature gradient = 0.04259669449651002\nWhen P = 758.9199 , temperature gradient = 0.04259669449651002\nWhen P = 758.4673 , temperature gradient = 0.03833702504685909\nWhen P = 758.0148 , temperature gradient = 0.03833702504685909\nWhen P = 757.5622 , temperature gradient = 0.029817686147557237\nWhen P = 757.1096 , temperature gradient = 0.021298347248255387\nWhen P = 756.657 , temperature gradient = 0.04259669449651002\nWhen P = 755.7518 , temperature gradient = 0.04685636394616094\nWhen P = 755.2992 , temperature gradient = 0.029817686147557237\nWhen P = 754.8467 , temperature gradient = 0.051116033395812624\nWhen P = 753.4889 , temperature gradient = 0.04685636394616094\nWhen P = 753.0363 , temperature gradient = 0.025558016697905556\n</pre> <p>(b) Newton finite difference</p> In\u00a0[3]: Copied! <pre>def Newt(x, y, n, x_miss):\n    fdd = np.zeros((n, n))\n    fdd[0:n, 0] = y[0:n]\n    for j in range(1, n, 1):\n        for i in range(0, n-j, 1):\n            fdd[i, j] = (fdd[i+1, j-1] - fdd[i, j-1]) / (x[i+j] - x[i])\n    y_interp = y[0]\n    xterm = 1.0\n    for order in range(1, n):\n        xterm = xterm * (x_miss - x[order - 1])\n        y_interp = y_interp + fdd[0, order] * xterm\n    return y_interp\n\nT_975 = Newt(P, T, 1, 975.0)\nprint('At the level of 975hpa, the temperature =', T_975, '(Newton)')\n</pre> def Newt(x, y, n, x_miss):     fdd = np.zeros((n, n))     fdd[0:n, 0] = y[0:n]     for j in range(1, n, 1):         for i in range(0, n-j, 1):             fdd[i, j] = (fdd[i+1, j-1] - fdd[i, j-1]) / (x[i+j] - x[i])     y_interp = y[0]     xterm = 1.0     for order in range(1, n):         xterm = xterm * (x_miss - x[order - 1])         y_interp = y_interp + fdd[0, order] * xterm     return y_interp  T_975 = Newt(P, T, 1, 975.0) print('At the level of 975hpa, the temperature =', T_975, '(Newton)') <pre>At the level of 975hpa, the temperature = 19.56 (Newton)\n</pre> <p>(c)</p> In\u00a0[4]: Copied! <pre>from scipy.interpolate import CubicSpline\n\nP_inv = []\nT_inv = []\n#\u5c07P\u5f9e\u5c0f\u6392\u5230\u5927\nfor i in range(0, len(P)):\n    P_inv.append(P[len(P) - i - 1])\n    T_inv.append(T[len(P) - i - 1])\ncs = CubicSpline(P_inv, T_inv)  #cubic spline\nxs = np.arange(750, 1000, 0.1)\n\nfig, ax  = plt.subplots(figsize = (6.5, 4))\nplt.title('Cubic Spline')\nax.plot(T, P, 'o', label = 'data')\nax.plot(cs(xs), xs, label = \"S\")\nplt.gca().invert_yaxis()\nax.legend(loc = 'lower left', ncol = 2)\nplt.show()\n\nprint('At the level of 975hpa, the temperature =', cs(975.0), '(Cubic)')\n</pre> from scipy.interpolate import CubicSpline  P_inv = [] T_inv = [] #\u5c07P\u5f9e\u5c0f\u6392\u5230\u5927 for i in range(0, len(P)):     P_inv.append(P[len(P) - i - 1])     T_inv.append(T[len(P) - i - 1]) cs = CubicSpline(P_inv, T_inv)  #cubic spline xs = np.arange(750, 1000, 0.1)  fig, ax  = plt.subplots(figsize = (6.5, 4)) plt.title('Cubic Spline') ax.plot(T, P, 'o', label = 'data') ax.plot(cs(xs), xs, label = \"S\") plt.gca().invert_yaxis() ax.legend(loc = 'lower left', ncol = 2) plt.show()  print('At the level of 975hpa, the temperature =', cs(975.0), '(Cubic)') <pre>At the level of 975hpa, the temperature = 21.261616119949423 (Cubic)\n</pre> <p>(d) \u62c9\u683c\u6717\u65e5</p> In\u00a0[5]: Copied! <pre>def Lagrage(x, y, f, n, x_miss):\n  sum = 0.0\n  for i in range(f, n):\n    product = 1\n    for j in range(f, n):\n      if i != j:\n        product = product * (x_miss - x[j]) / (x[i] - x[j])\n    sum  = sum + product * y[i]\n  return sum\n\nfor cou in range(11, len(P)-10):\n    forw = Lagrage(P, T, cou-2, cou+9, (float(P[cou-2])+float(P[cou+10]))/2)\n    midd = Lagrage(P, T, cou-5, cou+6, (float(P[cou-5])+float(P[cou+5]))/2)\n    back = Lagrage(P, T, cou-8, cou+3, (float(P[cou-8])+float(P[cou+2]))/2)\n    if max(forw, midd, back) == midd or min(forw, midd, back) == midd:\n        print('The depth of inverse:', (float(P[cou-5])+float(P[cou+5]))/2)\n    \n\n#anssss =  Lagrage(P, T, 40, 46, 975.0)\n#print('test2',anssss)\n</pre> def Lagrage(x, y, f, n, x_miss):   sum = 0.0   for i in range(f, n):     product = 1     for j in range(f, n):       if i != j:         product = product * (x_miss - x[j]) / (x[i] - x[j])     sum  = sum + product * y[i]   return sum  for cou in range(11, len(P)-10):     forw = Lagrage(P, T, cou-2, cou+9, (float(P[cou-2])+float(P[cou+10]))/2)     midd = Lagrage(P, T, cou-5, cou+6, (float(P[cou-5])+float(P[cou+5]))/2)     back = Lagrage(P, T, cou-8, cou+3, (float(P[cou-8])+float(P[cou+2]))/2)     if max(forw, midd, back) == midd or min(forw, midd, back) == midd:         print('The depth of inverse:', (float(P[cou-5])+float(P[cou+5]))/2)       #anssss =  Lagrage(P, T, 40, 46, 975.0) #print('test2',anssss)  <pre>The depth of inverse: 993.6958999999999\nThe depth of inverse: 992.83705\nThe depth of inverse: 992.26265\nThe depth of inverse: 991.3994\nThe depth of inverse: 954.52215\nThe depth of inverse: 953.6986999999999\nThe depth of inverse: 952.8752999999999\nThe depth of inverse: 952.3272\nThe depth of inverse: 950.9594\nThe depth of inverse: 828.996\nThe depth of inverse: 828.0172500000001\nThe depth of inverse: 824.11275\nThe depth of inverse: 822.89855\nThe depth of inverse: 822.17005\nThe depth of inverse: 821.6844000000001\nThe depth of inverse: 820.4702\nThe depth of inverse: 819.01315\nThe depth of inverse: 815.6134500000001\nThe depth of inverse: 813.18505\nThe depth of inverse: 811.97215\nThe depth of inverse: 810.77215\nThe depth of inverse: 809.08655\nThe depth of inverse: 808.1247\nThe depth of inverse: 807.64375\nThe depth of inverse: 807.1628000000001\nThe depth of inverse: 806.43905\nThe depth of inverse: 805.24505\nThe depth of inverse: 803.34035\nThe depth of inverse: 802.14985\n</pre>"},{"location":"past_exam/2021_fall/21_fall_q1/#2021-fall-final-exam-question-1","title":"[2021 Fall] Final Exam - Question 1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2021_fall/21_fall_q2/","title":"[2021 Fall] Final Exam - Question 2","text":"In\u00a0[1]: Copied! <pre>from scipy import integrate\nfrom scipy.special import erf\nimport numpy as np\n</pre> from scipy import integrate from scipy.special import erf import numpy as np In\u00a0[2]: Copied! <pre>def q(z):\n    qz = -6.01 * (z**8) + 4.92 * (z**7) - 0.024 * (z**4) + 0.13 * (z**3) - 0.37 * (z**2) - 1.88 * z + 20.00\n    return qz\n</pre> def q(z):     qz = -6.01 * (z**8) + 4.92 * (z**7) - 0.024 * (z**4) + 0.13 * (z**3) - 0.37 * (z**2) - 1.88 * z + 20.00     return qz In\u00a0[3]: Copied! <pre>Pw = 1000 * 1000 * 1000 * 1000\ng = 9.8 * 0.001\npara = 1 / (Pw * g)\n\nx = np.array([\n    0.,1.,2.,\n    3., 4., 5., \n    6., 7., 8., \n    9., 10.]\n)\n# x = np.array([0.,1000.,2000.,3000., 4000., 5000., 6000., 7000., 8000., 9000., 10000.])\nfx = q(x)\ntrap = np.trapz(fx, dx=1)\nsimp = integrate.simps(fx,dx=1)\nromb = integrate.romberg(q, 0, 10)\nquad = float((integrate.quadrature(q, 0.0, 10.0))[0])\n</pre> Pw = 1000 * 1000 * 1000 * 1000 g = 9.8 * 0.001 para = 1 / (Pw * g)  x = np.array([     0.,1.,2.,     3., 4., 5.,      6., 7., 8.,      9., 10.] ) # x = np.array([0.,1000.,2000.,3000., 4000., 5000., 6000., 7000., 8000., 9000., 10000.]) fx = q(x) trap = np.trapz(fx, dx=1) simp = integrate.simps(fx,dx=1) romb = integrate.romberg(q, 0, 10) quad = float((integrate.quadrature(q, 0.0, 10.0))[0]) <p>(a)</p> In\u00a0[4]: Copied! <pre>print('Trapezoid:', para * trap, '\\nSimpson 1/3:', para * simp, '\\nRomberg:', para * romb)\n</pre> print('Trapezoid:', para * trap, '\\nSimpson 1/3:', para * simp, '\\nRomberg:', para * romb) <pre>Trapezoid: -0.06563365285938773 \nSimpson 1/3: -0.061971091222312896 \nRomberg: -0.06186509695011337\n</pre> <p>(b)</p> In\u00a0[5]: Copied! <pre>print('Gauss-quadrature:', para * quad)\n</pre> print('Gauss-quadrature:', para * quad) <pre>Gauss-quadrature: -0.061865096950113295\n</pre>"},{"location":"past_exam/2021_fall/21_fall_q2/#2021-fall-final-exam-question-2","title":"[2021 Fall] Final Exam - Question 2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2021_fall/21_fall_q3/","title":"[2021 Fall] Final Exam - Question 3","text":"In\u00a0[1]: Copied! <pre>from os.path import dirname, join as pjoin\nimport scipy.io as sio\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> from os.path import dirname, join as pjoin import scipy.io as sio import matplotlib.pyplot as plt import numpy as np <p>\u8b80\u8cc7\u6599</p> In\u00a0[2]: Copied! <pre>mat_contents = sio.loadmat(\"./data/cceqs.mat\")\nsorted(mat_contents.keys())\n#print(mat_contents)\nTc = mat_contents['Tc'][0]\ne = mat_contents['e'][0]\n</pre> mat_contents = sio.loadmat(\"./data/cceqs.mat\") sorted(mat_contents.keys()) #print(mat_contents) Tc = mat_contents['Tc'][0] e = mat_contents['e'][0] <p>\u78ba\u8a8d\u8cc7\u6599</p> In\u00a0[3]: Copied! <pre>plt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\nplt.show()\n</pre> plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\") plt.show() In\u00a0[4]: Copied! <pre>def sig_xn(inf, power, dat):\n    sig = 0\n    for i in range(0, dat):\n        sig = sig + inf[i]**power\n    return sig\n</pre> def sig_xn(inf, power, dat):     sig = 0     for i in range(0, dat):         sig = sig + inf[i]**power     return sig <p>\u56de\u50b3\u56de\u6b78\u76f4\u7dda\u4fc2\u6578\u7684\u77e9\u9663</p> In\u00a0[5]: Copied! <pre>def a(x, y, dat):\n    sig_y = 0\n    sig_yy = 0\n    sig_xy = 0\n    sig_xxy = 0\n    for i in range(0, dat):\n        sig_y = sig_y + y[i]\n        sig_yy = sig_yy + y[i]**2\n        sig_xy = sig_xy + x[i] * y[i]\n        sig_xxy = sig_xxy + x[i]*x[i]*y[i]\n    linear_A = np.array([[dat, sig_xn(x, 1, dat)],\n                         [sig_xn(x, 1, dat), sig_xn(x, 2, dat)]])\n    linear_B = np.array([[sig_y],\n                         [sig_xy]])\n\n    l = np.array([[linear_A[0, 0],linear_A[0, 1]],\n                  [linear_A[1, 0]-linear_A[0, 0]*(linear_A[1, 0]/linear_A[0, 0]),linear_A[1, 1]-linear_A[0, 1]*(linear_A[1, 0]/linear_A[0, 0])]])\n    \n    a1 = (linear_B[1, 0]-(linear_B[0, 0]*(linear_A[1, 0]/linear_A[0, 0]))) / l[1, 1]  \n    a0 = (linear_B[0, 0] - l[0, 1]*a1) / l[0, 0]\n    arr_a = np.array([[a0],\n                      [a1]])\n    return arr_a\n</pre> def a(x, y, dat):     sig_y = 0     sig_yy = 0     sig_xy = 0     sig_xxy = 0     for i in range(0, dat):         sig_y = sig_y + y[i]         sig_yy = sig_yy + y[i]**2         sig_xy = sig_xy + x[i] * y[i]         sig_xxy = sig_xxy + x[i]*x[i]*y[i]     linear_A = np.array([[dat, sig_xn(x, 1, dat)],                          [sig_xn(x, 1, dat), sig_xn(x, 2, dat)]])     linear_B = np.array([[sig_y],                          [sig_xy]])      l = np.array([[linear_A[0, 0],linear_A[0, 1]],                   [linear_A[1, 0]-linear_A[0, 0]*(linear_A[1, 0]/linear_A[0, 0]),linear_A[1, 1]-linear_A[0, 1]*(linear_A[1, 0]/linear_A[0, 0])]])          a1 = (linear_B[1, 0]-(linear_B[0, 0]*(linear_A[1, 0]/linear_A[0, 0]))) / l[1, 1]       a0 = (linear_B[0, 0] - l[0, 1]*a1) / l[0, 0]     arr_a = np.array([[a0],                       [a1]])     return arr_a <p>a_0 a_1 \u70ba\u56de\u6b78\u76f4\u7dda\u76842\u4fc2\u6578</p> In\u00a0[6]: Copied! <pre>def a_0(x, y, dat):\n    arr_l = a(x, y, dat)\n    return float(arr_l[0, 0])\ndef a_1(x, y, dat):\n    arr_l = a(x, y, dat)\n    return float(arr_l[1, 0])\n</pre> def a_0(x, y, dat):     arr_l = a(x, y, dat)     return float(arr_l[0, 0]) def a_1(x, y, dat):     arr_l = a(x, y, dat)     return float(arr_l[1, 0]) In\u00a0[7]: Copied! <pre>def linear(x):\n    a0_3 = a_0(Tc, e, len(Tc))\n    a1_3 = a_1(Tc, e, len(Tc))\n    return a0_3 + a1_3 * x\n</pre> def linear(x):     a0_3 = a_0(Tc, e, len(Tc))     a1_3 = a_1(Tc, e, len(Tc))     return a0_3 + a1_3 * x <p>(a) Vapor Pressure vs Temperature(Linear)</p> In\u00a0[8]: Copied! <pre>xs = np.arange(-30, 35, 0.1)\nplt.title('3.(a) Vapor Pressure vs Temperature(Linear)')\nplt.xlabel('Temperature (degree Celsius)')\nplt.ylabel('Vapor Pressure (Pa)')\nplt.plot(Tc, e, 'o', label = 'data')\nplt.plot(xs, linear(xs), label = \"Regression Line\\n(y=\" + str(a_0(Tc, e, len(Tc))) + \"+\" + str(a_1(Tc, e, len(Tc))) + \"*x)\")\nplt.grid(True)\nplt.legend()\nplt.show()\n</pre> xs = np.arange(-30, 35, 0.1) plt.title('3.(a) Vapor Pressure vs Temperature(Linear)') plt.xlabel('Temperature (degree Celsius)') plt.ylabel('Vapor Pressure (Pa)') plt.plot(Tc, e, 'o', label = 'data') plt.plot(xs, linear(xs), label = \"Regression Line\\n(y=\" + str(a_0(Tc, e, len(Tc))) + \"+\" + str(a_1(Tc, e, len(Tc))) + \"*x)\") plt.grid(True) plt.legend() plt.show() <p>(b) Vapor Pressure vs Temperature(exp)</p> In\u00a0[9]: Copied! <pre>e_ln = np.log(e)    #\u8f49\u70baln\n\ndef expolin(x):\n    a0_3 = a_0(Tc, e_ln, len(Tc))\n    a1_3 = a_1(Tc, e_ln, len(Tc))\n    return np.exp(a0_3 + a1_3 * x)  #\u8f49\u56dee\n\nplt.title('3.(b) Vapor Pressure vs Temperature(exp)')\nplt.xlabel('Temperature (degree Celsius)')\nplt.ylabel('Vapor Pressure (Pa)')\nplt.plot(Tc, e, 'o', label = 'data')\nplt.plot(xs, expolin(xs), label = \"Regression Line\\n(y=e**(\" + str(a_0(Tc, e_ln, len(Tc))) + \"+\" + str(a_1(Tc, e_ln, len(Tc))) + \"*x))\")\nplt.grid(True)\nplt.legend()\nplt.show()\n</pre> e_ln = np.log(e)    #\u8f49\u70baln  def expolin(x):     a0_3 = a_0(Tc, e_ln, len(Tc))     a1_3 = a_1(Tc, e_ln, len(Tc))     return np.exp(a0_3 + a1_3 * x)  #\u8f49\u56dee  plt.title('3.(b) Vapor Pressure vs Temperature(exp)') plt.xlabel('Temperature (degree Celsius)') plt.ylabel('Vapor Pressure (Pa)') plt.plot(Tc, e, 'o', label = 'data') plt.plot(xs, expolin(xs), label = \"Regression Line\\n(y=e**(\" + str(a_0(Tc, e_ln, len(Tc))) + \"+\" + str(a_1(Tc, e_ln, len(Tc))) + \"*x))\") plt.grid(True) plt.legend() plt.show()"},{"location":"past_exam/2021_fall/21_fall_q3/#2021-fall-final-exam-question-3","title":"[2021 Fall] Final Exam - Question 3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2021_fall/21_fall_q4/","title":"[2021 Fall] Final Exam - Question 4","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.fft import fft, fftfreq, ifft\n</pre> import numpy as np import matplotlib.pyplot as plt import pandas as pd from scipy.fft import fft, fftfreq, ifft <p>\u8b80\u6a94</p> In\u00a0[2]: Copied! <pre>df = pd.read_fwf('./data/test.dat.rtf',skiprows=8)\n</pre> df = pd.read_fwf('./data/test.dat.rtf',skiprows=8) In\u00a0[3]: Copied! <pre>time=df.iloc[:, 1]\ndata=df.iloc[:, 7]\n#print(df)\ndata=data.to_numpy()\n#print(time)\n#print(data)\nn=48 #data amount\nx = np.arange(0, n, 1)\n\nplt.plot(data)\nplt.title(\"zenith total delay\")\nplt.ylabel(\"zenith total delay\")\nplt.xlabel(\"Time (30min interval)\")\nplt.show()\n</pre> time=df.iloc[:, 1] data=df.iloc[:, 7] #print(df) data=data.to_numpy() #print(time) #print(data) n=48 #data amount x = np.arange(0, n, 1)  plt.plot(data) plt.title(\"zenith total delay\") plt.ylabel(\"zenith total delay\") plt.xlabel(\"Time (30min interval)\") plt.show() In\u00a0[4]: Copied! <pre>y1= np.zeros(n, dtype=complex)  #\u8f49\u5b8c\u7684\u8cc7\u6599\u70bacomplex\u5f62\u5f0f\nyf = fft(data)\n\nk=1                #\u665d\u3001\u591c\ny1[0]=yf[0]\ny1[1:1+k-1]=yf[1:1+k-1]\ny1[n-k:n]=yf[n-k:n]         \nyt = ifft(y1,n)          \n\nplt.title('Zenith total delay')\nplt.ylabel('Zenith total delay')\nplt.xlabel('Time (30min interval)')\n#plt.axis([0.0, 20.0, 0.0, 6.0])\nplt.plot(data, label = \"Origional\")\nplt.plot(yt, label = \"FFT\")\nplt.grid(True)\n#plt.xticks(range(0, 21, 1))\n#plt.yticks(range(0, 7, 1))\nplt.legend()\n#plt.savefig('Windspeed_High_Relation_fft.png')\nplt.show()\n</pre> y1= np.zeros(n, dtype=complex)  #\u8f49\u5b8c\u7684\u8cc7\u6599\u70bacomplex\u5f62\u5f0f yf = fft(data)  k=1                #\u665d\u3001\u591c y1[0]=yf[0] y1[1:1+k-1]=yf[1:1+k-1] y1[n-k:n]=yf[n-k:n]          yt = ifft(y1,n)            plt.title('Zenith total delay') plt.ylabel('Zenith total delay') plt.xlabel('Time (30min interval)') #plt.axis([0.0, 20.0, 0.0, 6.0]) plt.plot(data, label = \"Origional\") plt.plot(yt, label = \"FFT\") plt.grid(True) #plt.xticks(range(0, 21, 1)) #plt.yticks(range(0, 7, 1)) plt.legend() #plt.savefig('Windspeed_High_Relation_fft.png') plt.show() <pre>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1340: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre>"},{"location":"past_exam/2021_fall/21_fall_q4/#2021-fall-final-exam-question-4","title":"[2021 Fall] Final Exam - Question 4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2021_fall/read_file/","title":"[2021 Fall] Final Exam - Example of Reading Data","text":"<p>(1) \u4ee5\u4e0b\u70ba\u4e00\u63a2\u7a7a\u8cc7\u6599\uff0cT\u77e9\u9663\u662f\u6eab\u5ea6(\u651d\u6c0f)\uff0cP\u77e9\u9663\u662f\u6c23\u58d3\u5c64(hPa)\u3002</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n#\u8b80\u8cc7\u6599\nwith open(\"./data/obs_2021-03-18_12_00_00.sound\") as a:\n    for i in range(2):\n        head=a.readline()\n    data=a.readlines()\n    T,P=np.zeros((len(data)))*np.nan,np.zeros((len(data)))*np.nan\n    for i,tmp in enumerate(data):\n        T[i]=tmp.split()[3]\n        P[i]=tmp.split()[0]\n\n#\u78ba\u8a8d\u8cc7\u6599\nplt.figure(figsize=(3,9))      \n#plt.plot(x,y)  \nplt.scatter(T,P)\nplt.gca().invert_yaxis()\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Pressure (hPa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\n</pre> import numpy as np import matplotlib.pyplot as plt  #\u8b80\u8cc7\u6599 with open(\"./data/obs_2021-03-18_12_00_00.sound\") as a:     for i in range(2):         head=a.readline()     data=a.readlines()     T,P=np.zeros((len(data)))*np.nan,np.zeros((len(data)))*np.nan     for i,tmp in enumerate(data):         T[i]=tmp.split()[3]         P[i]=tmp.split()[0]  #\u78ba\u8a8d\u8cc7\u6599 plt.figure(figsize=(3,9))       #plt.plot(x,y)   plt.scatter(T,P) plt.gca().invert_yaxis() plt.title(\"Temperature Profile\") plt.ylabel(\"Pressure (hPa)\") plt.xlabel(\"Temperature (degree Celsius)\") Out[1]: <pre>Text(0.5, 0, 'Temperature (degree Celsius)')</pre> <p>(3)\u4ee5\u4e0b\u8cc7\u6599\u70ba\u6eab\u5ea6(Tc,\u651d\u6c0f)\u8207\u6c34\u6c23(e,Pa)\u7684\u8cc7\u6599</p> In\u00a0[2]: Copied! <pre>from os.path import dirname, join as pjoin\nimport scipy.io as sio\nimport matplotlib.pyplot as plt\n\n#\u8b80\u8cc7\u6599\nmat_contents = sio.loadmat(r\"./data/cceqs.mat\")\nsorted(mat_contents.keys())\n#print(mat_contents)\nTc = mat_contents['Tc'][0]\ne = mat_contents['e'][0]\n\n#\u78ba\u8a8d\u8cc7\u6599\n#plt.plot(Tc,e)\nplt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\n</pre> from os.path import dirname, join as pjoin import scipy.io as sio import matplotlib.pyplot as plt  #\u8b80\u8cc7\u6599 mat_contents = sio.loadmat(r\"./data/cceqs.mat\") sorted(mat_contents.keys()) #print(mat_contents) Tc = mat_contents['Tc'][0] e = mat_contents['e'][0]  #\u78ba\u8a8d\u8cc7\u6599 #plt.plot(Tc,e) plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\") Out[2]: <pre>Text(0.5, 0, 'Temperature (degree Celsius)')</pre> <p>(4)\u4ee5\u4e0b\u70ba\u4e00\u7d44GNSS zenith total delay\u7684\u8cc7\u6599\uff0cdata\u662fzenith total delay\uff0c time\u662f\u6642\u9593(string type)</p> In\u00a0[3]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.fft import fft, fftfreq, ifft\n\n#\u8b80\u6a94\ndf = pd.read_fwf(r'./data/test.dat.rtf',skiprows=8)\ntime=df.iloc[:, 1]\ndata=df.iloc[:, 7]\n#print(df)\ndata=data.to_numpy()\n#print(time)\n#print(data)\nn=48 #data amount\n\nplt.plot(data)\nplt.title(\"zenith total delay\")\nplt.ylabel(\"zenith total delay\")\nplt.xlabel(\"Time (30min interval)\")\n</pre> import numpy as np import matplotlib.pyplot as plt import pandas as pd from scipy.fft import fft, fftfreq, ifft  #\u8b80\u6a94 df = pd.read_fwf(r'./data/test.dat.rtf',skiprows=8) time=df.iloc[:, 1] data=df.iloc[:, 7] #print(df) data=data.to_numpy() #print(time) #print(data) n=48 #data amount  plt.plot(data) plt.title(\"zenith total delay\") plt.ylabel(\"zenith total delay\") plt.xlabel(\"Time (30min interval)\")   Out[3]: <pre>Text(0.5, 0, 'Time (30min interval)')</pre>"},{"location":"past_exam/2021_fall/read_file/#2021-fall-final-exam-example-of-reading-data","title":"[2021 Fall] Final Exam - Example of Reading Data\u00b6","text":"<p>This is the example code to read the data from TAs.</p>"},{"location":"past_exam/2022_fall/22_fall_q1/","title":"[2022 Fall] Final Exam - Question 1","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>radius, velocity = np.loadtxt(\"./data/TCVt.txt\",unpack=\"true\")\n\nprint(radius)\nprint(len(radius))\nprint(velocity)\nprint(len(velocity))\n</pre> radius, velocity = np.loadtxt(\"./data/TCVt.txt\",unpack=\"true\")  print(radius) print(len(radius)) print(velocity) print(len(velocity)) <pre>[  0.5   8.5  16.5  24.5  32.5  40.5  56.5  64.5  72.5  80.5  88.5  96.5\n 104.5 112.5 120.5 128.5 136.5 144.5 152.5 160.5 168.5 176.5 184.5 192.5]\n24\n[ 2.0233  8.6362 12.1303 14.8529 17.1661 19.6514 19.2963 18.4415 17.6843\n 17.0022 16.3786 15.8015 15.2619 14.7534 14.271  13.8111 13.3708 12.9481\n 12.5413 12.1492 11.7707 11.4049 11.0513 10.7091]\n24\n</pre> In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=(16,12))\nplt.plot(radius, velocity)\nplt.show()\n</pre> fig = plt.figure(figsize=(16,12)) plt.plot(radius, velocity) plt.show() In\u00a0[4]: Copied! <pre>def lagrange(x, y, f, n, x_miss):\n    ans = 0.0\n    for i in range(f, n+1):\n        product = y[i]\n        for j in range(f, n+1):\n            if i != j:\n                product = product * (x_miss - x[j]) / (x[i] - x[j])\n        ans = ans + product\n    return ans\n</pre> def lagrange(x, y, f, n, x_miss):     ans = 0.0     for i in range(f, n+1):         product = y[i]         for j in range(f, n+1):             if i != j:                 product = product * (x_miss - x[j]) / (x[i] - x[j])         ans = ans + product     return ans In\u00a0[5]: Copied! <pre>ans = lagrange(radius, velocity, 0, len(radius)-1, 50.)\nprint(\"Vt at 50km with Lagrange method:\", ans)\n</pre> ans = lagrange(radius, velocity, 0, len(radius)-1, 50.) print(\"Vt at 50km with Lagrange method:\", ans) <pre>Vt at 50km with Lagrange method: 19.944063474958146\n</pre> In\u00a0[6]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef cubic_inter(x0, x, y):\n\n    x = np.array(x)\n    y = np.array(y)\n\n    size = len(x)\n\n    x_diff = np.zeros(size - 1)\n    for i in range(0, 23):\n        x_diff[i] = x[i + 1] - x[i]\n\n    y_diff = np.zeros(size - 1)\n    for i in range(0, 23):\n        y_diff[i] = y[i + 1] - y[i]\n\n    # allocate buffer matrices\n    Li = np.zeros(size)\n    Li_1 = np.zeros(size-1)\n    z = np.zeros(size)\n\n    # fill diagonals Li and Li-1 and solve [L][y] = [B]\n    Li[0] = np.sqrt(2*x_diff[0])\n    Li_1[0] = 0.0\n    B0 = 0.0 # natural boundary\n    z[0] = B0 / Li[0]\n\n    for i in range(1, size-1, 1):\n        Li_1[i] = x_diff[i-1] / Li[i-1]\n        Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])\n        Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])\n        z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    i = size - 1\n    Li_1[i-1] = x_diff[-1] / Li[i-1]\n    Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])\n    Bi = 0.0 # natural boundary\n    z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    # solve [L.T][x] = [y]\n    i = size-1\n    z[i] = z[i] / Li[i]\n    for i in range(size-2, -1, -1):\n        z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]\n\n    # find index\n    count = 0\n\n    for i in range(0, len(x)):\n        if x0[0] &gt; x[i]:\n            count += 1\n        else:\n            break\n\n    xi1, xi0 = x[count], x[count - 1]\n    yi1, yi0 = y[count], y[count - 1]\n    zi1, zi0 = z[count], z[count - 1]\n    hi1 = xi1 - xi0\n\n    # calculate cubic\n    f0 = zi0/(6*hi1)*(xi1-x0)**3 \\\n        + zi1/(6*hi1)*(x0-xi0)**3 \\\n        + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) \\\n        + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)\n\n    return f0\n</pre> import numpy as np import matplotlib.pyplot as plt   def cubic_inter(x0, x, y):      x = np.array(x)     y = np.array(y)      size = len(x)      x_diff = np.zeros(size - 1)     for i in range(0, 23):         x_diff[i] = x[i + 1] - x[i]      y_diff = np.zeros(size - 1)     for i in range(0, 23):         y_diff[i] = y[i + 1] - y[i]      # allocate buffer matrices     Li = np.zeros(size)     Li_1 = np.zeros(size-1)     z = np.zeros(size)      # fill diagonals Li and Li-1 and solve [L][y] = [B]     Li[0] = np.sqrt(2*x_diff[0])     Li_1[0] = 0.0     B0 = 0.0 # natural boundary     z[0] = B0 / Li[0]      for i in range(1, size-1, 1):         Li_1[i] = x_diff[i-1] / Li[i-1]         Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])         Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])         z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      i = size - 1     Li_1[i-1] = x_diff[-1] / Li[i-1]     Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])     Bi = 0.0 # natural boundary     z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      # solve [L.T][x] = [y]     i = size-1     z[i] = z[i] / Li[i]     for i in range(size-2, -1, -1):         z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]      # find index     count = 0      for i in range(0, len(x)):         if x0[0] &gt; x[i]:             count += 1         else:             break      xi1, xi0 = x[count], x[count - 1]     yi1, yi0 = y[count], y[count - 1]     zi1, zi0 = z[count], z[count - 1]     hi1 = xi1 - xi0      # calculate cubic     f0 = zi0/(6*hi1)*(xi1-x0)**3 \\         + zi1/(6*hi1)*(x0-xi0)**3 \\         + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) \\         + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)      return f0 In\u00a0[7]: Copied! <pre>print('Vt at 50 km by the Cubic spline =',cubic_inter([50], radius, velocity)[0])\n</pre> print('Vt at 50 km by the Cubic spline =',cubic_inter([50], radius, velocity)[0]) <pre>Vt at 50 km by the Cubic spline = 20.117322677684125\n</pre> In\u00a0[8]: Copied! <pre>def central_diff(radius_arr, wind_arr, data_size):\n\n    # The first and the last need to be special progress.\n\n    temp_grad_arr = []\n\n\n    for i in range(0, data_size):\n\n        if i == 0:\n            pressure_div = float(radius_arr[i + 1] - radius_arr[i])\n            temp_div = float(wind_arr[i + 1] - wind_arr[i])\n            temp_grad =  temp_div / pressure_div\n        elif i == data_size - 1:\n            pressure_div = float(radius_arr[i] - radius_arr[i - 1])\n            temp_div = float(wind_arr[i] - wind_arr[i - 1])\n            temp_grad =  temp_div / pressure_div\n        else:\n            pressure_div = float(radius_arr[i + 1] - radius_arr[i - 1])\n            temp_div = float(wind_arr[i + 1] - wind_arr[i - 1])\n            temp_grad =  temp_div / pressure_div\n\n        temp_grad_arr.append(temp_grad)\n\n    return temp_grad_arr\n</pre> def central_diff(radius_arr, wind_arr, data_size):      # The first and the last need to be special progress.      temp_grad_arr = []       for i in range(0, data_size):          if i == 0:             pressure_div = float(radius_arr[i + 1] - radius_arr[i])             temp_div = float(wind_arr[i + 1] - wind_arr[i])             temp_grad =  temp_div / pressure_div         elif i == data_size - 1:             pressure_div = float(radius_arr[i] - radius_arr[i - 1])             temp_div = float(wind_arr[i] - wind_arr[i - 1])             temp_grad =  temp_div / pressure_div         else:             pressure_div = float(radius_arr[i + 1] - radius_arr[i - 1])             temp_div = float(wind_arr[i + 1] - wind_arr[i - 1])             temp_grad =  temp_div / pressure_div          temp_grad_arr.append(temp_grad)      return temp_grad_arr In\u00a0[9]: Copied! <pre>radius_arr = np.linspace(0.5, 192.5, 8)\nwind_arr = cubic_inter(radius_arr, radius, velocity)\ndata_size = len(radius_arr)\nwing_grad_arr = central_diff(radius_arr, wind_arr, data_size)\nwind_grad_max = max(wing_grad_arr)\nprint(\"The maximum of the wind gradient:\", wind_grad_max)\n</pre> radius_arr = np.linspace(0.5, 192.5, 8) wind_arr = cubic_inter(radius_arr, radius, velocity) data_size = len(radius_arr) wing_grad_arr = central_diff(radius_arr, wind_arr, data_size) wind_grad_max = max(wing_grad_arr) print(\"The maximum of the wind gradient:\", wind_grad_max) <pre>The maximum of the wind gradient: 0.877404910990909\n</pre> In\u00a0[10]: Copied! <pre>data_size = len(radius)\nwing_grad_arr2 = central_diff(radius, velocity, data_size)\nwind_grad_max2 = max(wing_grad_arr2)\nprint(\"The maximum of the wind gradient with the central difference method:\", wind_grad_max2)\n</pre> data_size = len(radius) wing_grad_arr2 = central_diff(radius, velocity, data_size) wind_grad_max2 = max(wing_grad_arr2) print(\"The maximum of the wind gradient with the central difference method:\", wind_grad_max2) <pre>The maximum of the wind gradient with the central difference method: 0.8266125000000001\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q1/#2022-fall-final-exam-question-1","title":"[2022 Fall] Final Exam - Question 1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q1/","title":"\u98b1\u98a8\u534a\u5f91\u548c\u98a8\u901f\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/","title":"\u756b\u500b\u5716\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#a-determine-vt-at-50km-with-the-lagrange-method","title":"a. Determine Vt at 50km with the Lagrange method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#b-please-determine-vt-at-50-km-by-the-cubi-spline-method","title":"b. Please determine Vt at 50 km, by the cubi spline method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#c-determine-the-location-of-the-maximum-of-the-wind-gradient-based-on-b","title":"c. Determine the location of the maximum of the wind gradient based on (b).\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#d-determine-the-maximum-of-the-wind-gradient-with-the-central-difference-method","title":"d. Determine the maximum of the wind gradient with the central difference method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q2/","title":"[2022 Fall] Final Exam - Question 2","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre># T : Parcel virtual temperature\n# Tv : Environment virtual temperature\n# Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level)\nHeight, T, Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")\n\nprint(Height)\nprint(len(Height))\n\nprint(T)\nprint(len(T))\n\nprint(Tv)\nprint(len(Tv))\n</pre> # T : Parcel virtual temperature # Tv : Environment virtual temperature # Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level) Height, T, Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")  print(Height) print(len(Height))  print(T) print(len(T))  print(Tv) print(len(Tv)) <pre>[   0.  500. 1000. 1500. 2000. 2500. 3000. 3500. 4000. 4500. 5000. 5500.\n 6000. 6500. 7000. 7500.]\n16\n[302.641015 301.414936 300.052387 299.219994 297.945706 297.839665\n 296.395461 295.957622 294.836952 294.042834 293.178223 292.128172\n 291.41732  290.846195 289.566794 288.568096]\n16\n[308.45302  304.161056 299.426643 296.55262  292.179701 291.817268\n 286.903579 285.422136 281.647781 278.988442 276.107374 272.628489\n 270.285908 268.411115 264.234983 260.997853]\n16\n</pre> In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=(16,12))\nplt.plot(T, Height)\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Height\")\nplt.xlabel(\"Temperature (K)\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16,12)) plt.plot(T, Height) plt.title(\"Temperature Profile\") plt.ylabel(\"Height\") plt.xlabel(\"Temperature (K)\")  plt.show() In\u00a0[4]: Copied! <pre>g = 9.8\npara = (T - Tv) / Tv\n</pre> g = 9.8 para = (T - Tv) / Tv In\u00a0[5]: Copied! <pre>def trapezoid_method(f, h, n):\n\n    total = f[0]\n    for i in range(1, n):\n        total = total + 2 * f[i]\n    total = total + f[n]\n\n    ans = h * total / 2\n    \n    return ans\n</pre> def trapezoid_method(f, h, n):      total = f[0]     for i in range(1, n):         total = total + 2 * f[i]     total = total + f[n]      ans = h * total / 2          return ans In\u00a0[6]: Copied! <pre>trapezoid_method_result = g * trapezoid_method(para, (7500.) / (len(T) - 1), len(T) - 1)\nprint(\"Trapezoid:\", trapezoid_method_result)\n</pre> trapezoid_method_result = g * trapezoid_method(para, (7500.) / (len(T) - 1), len(T) - 1) print(\"Trapezoid:\", trapezoid_method_result) <pre>Trapezoid: 3173.2169619851093\n</pre> In\u00a0[7]: Copied! <pre>def simpson_13_method(f, h, n):\n\n    total = f[0]\n    for i in range(1, n, 2):\n        total = total + 4 * f[i]\n    for j in range(2, n-1, 2):\n        total = total + 2 * f[j]\n    total = total + f[n]\n\n    ans = h * total / 3\n    \n    return ans\n</pre> def simpson_13_method(f, h, n):      total = f[0]     for i in range(1, n, 2):         total = total + 4 * f[i]     for j in range(2, n-1, 2):         total = total + 2 * f[j]     total = total + f[n]      ans = h * total / 3          return ans In\u00a0[8]: Copied! <pre>simpson_13_method_result = g * simpson_13_method(para, (7500.) / (len(T) - 1), len(T) - 1)\nprint(\"Simpson 1/3:\", simpson_13_method_result)\n</pre> simpson_13_method_result = g * simpson_13_method(para, (7500.) / (len(T) - 1), len(T) - 1) print(\"Simpson 1/3:\", simpson_13_method_result) <pre>Simpson 1/3: 2673.154315758109\n</pre> In\u00a0[9]: Copied! <pre>def cubic_inter(x0, x, y):\n\n    x = np.array(x)\n    y = np.array(y)\n    # remove non finite values\n    # indexes = np.isfinite(x)\n    # check if sorted\n    if np.any(np.diff(x) &lt; 0):\n        indexes = np.argsort(x)\n        x = x[indexes]\n        y = y[indexes]\n\n    size = len(x)\n    # print(size)\n    x_diff = np.zeros(size - 1)\n    for i in range(0, 15):\n        x_diff[i] = x[i + 1] - x[i]\n\n    y_diff = np.zeros(size - 1)\n    for i in range(0, 15):\n        y_diff[i] = y[i + 1] - y[i]\n\n    # allocate buffer matrices\n    Li = np.zeros(size)\n    Li_1 = np.zeros(size-1)\n    z = np.zeros(size)\n\n    # fill diagonals Li and Li-1 and solve [L][y] = [B]\n    Li[0] = np.sqrt(2*x_diff[0])\n    Li_1[0] = 0.0\n    B0 = 0.0 # natural boundary\n    z[0] = B0 / Li[0]\n\n    for i in range(1, size-1, 1):\n        Li_1[i] = x_diff[i-1] / Li[i-1]\n        Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])\n        Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])\n        z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    i = size - 1\n    Li_1[i-1] = x_diff[-1] / Li[i-1]\n    Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])\n    Bi = 0.0 # natural boundary\n    z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    # solve [L.T][x] = [y]\n    i = size-1\n    z[i] = z[i] / Li[i]\n    for i in range(size-2, -1, -1):\n        z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]\n\n    # find index\n    count = 0\n\n    for i in range(0, len(x)):\n        if x0[0] &gt; x[i]:\n            count += 1\n        else:\n            break\n\n    xi1, xi0 = x[count], x[count - 1]\n    yi1, yi0 = y[count], y[count - 1]\n    zi1, zi0 = z[count], z[count - 1]\n    hi1 = xi1 - xi0\n\n    # calculate cubic\n    f0 = zi0/(6*hi1)*(xi1-x0)**3 + zi1/(6*hi1)*(x0-xi0)**3 + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)\n    \n    return f0\n</pre> def cubic_inter(x0, x, y):      x = np.array(x)     y = np.array(y)     # remove non finite values     # indexes = np.isfinite(x)     # check if sorted     if np.any(np.diff(x) &lt; 0):         indexes = np.argsort(x)         x = x[indexes]         y = y[indexes]      size = len(x)     # print(size)     x_diff = np.zeros(size - 1)     for i in range(0, 15):         x_diff[i] = x[i + 1] - x[i]      y_diff = np.zeros(size - 1)     for i in range(0, 15):         y_diff[i] = y[i + 1] - y[i]      # allocate buffer matrices     Li = np.zeros(size)     Li_1 = np.zeros(size-1)     z = np.zeros(size)      # fill diagonals Li and Li-1 and solve [L][y] = [B]     Li[0] = np.sqrt(2*x_diff[0])     Li_1[0] = 0.0     B0 = 0.0 # natural boundary     z[0] = B0 / Li[0]      for i in range(1, size-1, 1):         Li_1[i] = x_diff[i-1] / Li[i-1]         Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])         Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])         z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      i = size - 1     Li_1[i-1] = x_diff[-1] / Li[i-1]     Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])     Bi = 0.0 # natural boundary     z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      # solve [L.T][x] = [y]     i = size-1     z[i] = z[i] / Li[i]     for i in range(size-2, -1, -1):         z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]      # find index     count = 0      for i in range(0, len(x)):         if x0[0] &gt; x[i]:             count += 1         else:             break      xi1, xi0 = x[count], x[count - 1]     yi1, yi0 = y[count], y[count - 1]     zi1, zi0 = z[count], z[count - 1]     hi1 = xi1 - xi0      # calculate cubic     f0 = zi0/(6*hi1)*(xi1-x0)**3 + zi1/(6*hi1)*(x0-xi0)**3 + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)          return f0 In\u00a0[10]: Copied! <pre>def trap_eq(a, b, n):\n\n    h = (b - a) / n\n    x = a\n    sum_tra = cubic_inter([x], Height, para)[0] \n\n    for i in range(1, n):\n        x = x + h\n        sum_tra = sum_tra + 2 * cubic_inter([x], Height, para)[0]\n\n    sum_tra = sum_tra + cubic_inter([b], Height, para)[0]\n    Trap = (b - a) * sum_tra / (2 * n)\n    \n    return Trap\n</pre> def trap_eq(a, b, n):      h = (b - a) / n     x = a     sum_tra = cubic_inter([x], Height, para)[0]       for i in range(1, n):         x = x + h         sum_tra = sum_tra + 2 * cubic_inter([x], Height, para)[0]      sum_tra = sum_tra + cubic_inter([b], Height, para)[0]     Trap = (b - a) * sum_tra / (2 * n)          return Trap In\u00a0[11]: Copied! <pre>def I(j, k, a, b):\n\n    if k == 1:\n        n = 2 ** (j - 1)\n\n        return trap_eq(a, b, n)\n    else:\n        i_jk = ((4 ** (k-1)) * I(j + 1, k - 1, a, b) - I(j, k - 1, a, b)) / ((4 ** (k - 1)) - 1)\n\n        return i_jk\n</pre> def I(j, k, a, b):      if k == 1:         n = 2 ** (j - 1)          return trap_eq(a, b, n)     else:         i_jk = ((4 ** (k-1)) * I(j + 1, k - 1, a, b) - I(j, k - 1, a, b)) / ((4 ** (k - 1)) - 1)          return i_jk In\u00a0[12]: Copied! <pre>def romberg_method(a, b, es):\n    i_ter = 0\n    while True:\n        i_ter = i_ter + 1\n\n        for k in range(2, i_ter + 2):\n            j = 2 + i_ter - k\n\n        ea = abs((I(1, i_ter + 1, a, b) - I(2, i_ter, a, b)) / I(1, i_ter + 1, a, b)) * 100\n        if ea &lt; es:\n            break\n\n    return I(1, i_ter + 1, a, b)\n</pre> def romberg_method(a, b, es):     i_ter = 0     while True:         i_ter = i_ter + 1          for k in range(2, i_ter + 2):             j = 2 + i_ter - k          ea = abs((I(1, i_ter + 1, a, b) - I(2, i_ter, a, b)) / I(1, i_ter + 1, a, b)) * 100         if ea &lt; es:             break      return I(1, i_ter + 1, a, b) In\u00a0[13]: Copied! <pre>romberg_method_result = g * romberg_method(0., 7500., 0.005) \nprint(\"Romberg:\", romberg_method_result)\n</pre> romberg_method_result = g * romberg_method(0., 7500., 0.005)  print(\"Romberg:\", romberg_method_result) <pre>Romberg: 3169.6285635767013\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q2/#2022-fall-final-exam-question-2","title":"[2022 Fall] Final Exam - Question 2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q2/#trapezoid-method","title":"Trapezoid Method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q2/#simpson-13-method","title":"Simpson 1/3 Method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q2/#romberg-method","title":"Romberg Method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/","title":"[2022 Fall] Final Exam - Question 3","text":"In\u00a0[1]: Copied! <pre>import scipy.io as sio\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import scipy.io as sio import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>mat_contents = sio.loadmat(\"./data/cceqs.mat\")\nsorted(mat_contents.keys())\nTc = mat_contents['Tc'][0]\ne = mat_contents['e'][0]\n\nprint(len(Tc))\nprint(Tc)\n\nprint()\n\nprint(len(e))\nprint(e)\n</pre> mat_contents = sio.loadmat(\"./data/cceqs.mat\") sorted(mat_contents.keys()) Tc = mat_contents['Tc'][0] e = mat_contents['e'][0]  print(len(Tc)) print(Tc)  print()  print(len(e)) print(e) <pre>66\n[-30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14 -13\n -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5\n   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23\n  24  25  26  27  28  29  30  31  32  33  34  35]\n\n66\n[ 103.03784717  110.21840143  117.82566779  125.88035082  134.40391071\n  143.41857998  152.94738016  163.01413849  173.64350459  184.86096706\n  196.69287011  209.16643007  222.30975185  236.15184532  250.72264164\n  266.05300947  282.17477102  299.12071809  316.92462788  335.62127874\n  355.2464657   375.83701593  397.43080395  420.06676672  443.78491852\n  468.62636565  494.63332089  521.84911783  550.31822489  580.08625916\n  611.2         643.7074024   677.65761005  713.10096823  750.08903635\n  788.67460026  828.91168427  870.8555629   914.56277234  960.09112156\n 1007.49970316 1056.84890395 1108.2004151  1161.6172421  1217.1637143\n 1274.90549418 1334.90958622 1397.24434553 1461.97948606 1529.18608847\n 1598.93660769 1671.30488011 1746.36613043 1824.19697809 1904.87544344\n 1988.48095349 2075.09434726 2164.79788088 2257.67523221 2353.81150513\n 2453.29323352 2556.20838475 2662.64636294 2772.69801171 2886.45561668\n 3004.01290756]\n</pre> In\u00a0[3]: Copied! <pre>plt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\n\nplt.show()\n</pre> plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\")  plt.show() In\u00a0[4]: Copied! <pre>def regression(x, y, n):\n\n    sum_x = 0   # the sum of the x\n    sum_y = 0   # the sum of the y\n\n    sum_xy = 0  # the sum of the x * y\n    sum_x2 = 0  # the sum of the x ^ 2\n\n    st = 0      \n    sr = 0      \n\n    for i in range(0, n):\n        sum_x += x[i]\n        sum_y += y[i]\n\n        sum_xy += x[i] * y[i]\n        sum_x2 += x[i] * x[i]\n\n    x_mean = sum_x / n\n    y_mean = sum_y / n\n\n    a1 = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)\n    a0 = y_mean - a1 * x_mean\n\n    for i in range(0, n):\n        st += (y[i] - y_mean) ** 2\n        sr += (y[i] - a0 - a1 * x[i]) ** 2\n\n    std_estimate_error = (sr - (n - 2)) ** 0.5\n    r2 = (st - sr) / st\n    r = ((st - sr) / st) ** 0.5\n\n    return a0, a1, std_estimate_error, r2, r\n</pre> def regression(x, y, n):      sum_x = 0   # the sum of the x     sum_y = 0   # the sum of the y      sum_xy = 0  # the sum of the x * y     sum_x2 = 0  # the sum of the x ^ 2      st = 0           sr = 0            for i in range(0, n):         sum_x += x[i]         sum_y += y[i]          sum_xy += x[i] * y[i]         sum_x2 += x[i] * x[i]      x_mean = sum_x / n     y_mean = sum_y / n      a1 = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)     a0 = y_mean - a1 * x_mean      for i in range(0, n):         st += (y[i] - y_mean) ** 2         sr += (y[i] - a0 - a1 * x[i]) ** 2      std_estimate_error = (sr - (n - 2)) ** 0.5     r2 = (st - sr) / st     r = ((st - sr) / st) ** 0.5      return a0, a1, std_estimate_error, r2, r In\u00a0[5]: Copied! <pre>data_size = len(Tc)\na0, a1, std_estimate_error, r2, r = regression(Tc, e, data_size)\n\nprint(\"After the LINEAR regression:\\n\")\nprint(\"a0:                              \", a0)\nprint(\"a1:                              \", a1)\nprint(\"std_estimate_error:              \", std_estimate_error)\nprint(\"Coefficient of the determination:\", r2)\nprint(\"Coefficient of the correlation:  \", r)\n</pre> data_size = len(Tc) a0, a1, std_estimate_error, r2, r = regression(Tc, e, data_size)  print(\"After the LINEAR regression:\\n\") print(\"a0:                              \", a0) print(\"a1:                              \", a1) print(\"std_estimate_error:              \", std_estimate_error) print(\"Coefficient of the determination:\", r2) print(\"Coefficient of the correlation:  \", r) <pre>After the LINEAR regression:\n\na0:                               879.9865701296675\na1:                               41.10433052361058\nstd_estimate_error:               2160.6155885448184\nCoefficient of the determination: 0.8965758428578144\nCoefficient of the correlation:   0.9468768889659386\n</pre> In\u00a0[6]: Copied! <pre>xs = np.arange(-30, 35, 0.1)\nys = a1 * xs + a0\nplt.plot(xs, ys, 'r')\nplt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\nplt.legend([\"regression:\\ny = 879.9865701296675x + 41.10433052361058\", \"input data\"])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(-30, 35, 0.1) ys = a1 * xs + a0 plt.plot(xs, ys, 'r') plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\") plt.legend([\"regression:\\ny = 879.9865701296675x + 41.10433052361058\", \"input data\"]) plt.grid()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q3/#2022-fall-final-exam-question-3","title":"[2022 Fall] Final Exam - Question 3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q3/","title":"\u8b80\u8cc7\u6599\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/","title":"\u78ba\u8a8d\u8cc7\u6599\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#a-please-construct-the-c-c-equation-using-the-linear-regression","title":"a. Please construct the C-C equation using the LINEAR regression\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#define-the-linear-regression","title":"Define the LINEAR regression\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#data-with-the-linear-regression","title":"Data with the LINEAR regression\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#plot-the-linear-regression-to-the-figure","title":"Plot the LINEAR regression to the figure.\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#b-please-determine-the-goodness-of-fitting","title":"b. Please determine the goodness of fitting\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#turn-to-the-ln","title":"Turn to the $ln$\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/","title":"[2022 Fall] Final Exam - Question 4","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>stnno,yyyymmddhh,Pressure,Rain,Temp,Wind = np.loadtxt(\"./data/ground_station_data.txt\",unpack=\"true\")\n</pre> stnno,yyyymmddhh,Pressure,Rain,Temp,Wind = np.loadtxt(\"./data/ground_station_data.txt\",unpack=\"true\") In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=(16,12))\nplt.plot(Temp)\nplt.title(\"Month Temperature\")\nplt.ylabel(\"Temperature\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original'])\nplt.grid()\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16,12)) plt.plot(Temp) plt.title(\"Month Temperature\") plt.ylabel(\"Temperature\") plt.xlabel(\"Data_perhour\") plt.legend(['Original']) plt.grid()  plt.show() In\u00a0[4]: Copied! <pre>from scipy.fft import fft, fftfreq, ifft\n</pre> from scipy.fft import fft, fftfreq, ifft In\u00a0[5]: Copied! <pre>xs = np.arange(0, 672, 0.1)\nY = np.fft.fft(Temp)\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(Temp)\nplt.plot(Y)\nplt.title(\"Month Temperature\")\nplt.ylabel(\"Temperature\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 0.1) Y = np.fft.fft(Temp)  fig = plt.figure(figsize=(16,12)) plt.plot(Temp) plt.plot(Y) plt.title(\"Month Temperature\") plt.ylabel(\"Temperature\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() <pre>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1340: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> In\u00a0[6]: Copied! <pre>xs = np.arange(0, 672, 1)\nys = Pressure[xs]\nY = np.fft.fft((ys))\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(xs, ys)\nplt.plot(Y)\nplt.title(\"Month Pressure\")\nplt.ylabel(\"Pressure\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 1) ys = Pressure[xs] Y = np.fft.fft((ys))  fig = plt.figure(figsize=(16,12)) plt.plot(xs, ys) plt.plot(Y) plt.title(\"Month Pressure\") plt.ylabel(\"Pressure\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() In\u00a0[7]: Copied! <pre>xs = np.arange(0, 672, 1)\nys = Rain[xs]\nY = np.fft.fft((ys))\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(xs, ys)\nplt.plot(Y)\nplt.title(\"Month Rain\")\nplt.ylabel(\"Rain\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 1) ys = Rain[xs] Y = np.fft.fft((ys))  fig = plt.figure(figsize=(16,12)) plt.plot(xs, ys) plt.plot(Y) plt.title(\"Month Rain\") plt.ylabel(\"Rain\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() In\u00a0[8]: Copied! <pre>xs = np.arange(0, 672, 1)\nys = Wind[xs]\nY = np.fft.fft((ys))\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(xs, ys)\nplt.plot(Y)\nplt.title(\"Month Wind\")\nplt.ylabel(\"Wind\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 1) ys = Wind[xs] Y = np.fft.fft((ys))  fig = plt.figure(figsize=(16,12)) plt.plot(xs, ys) plt.plot(Y) plt.title(\"Month Wind\") plt.ylabel(\"Wind\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q4/#2022-fall-final-exam-question-4","title":"[2022 Fall] Final Exam - Question 4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q4/#the-given-data-is-the-hourly-surface-data-of-february-2019-please-apply-fft-to-remove-the-diurnal-component-of-this-data-set","title":"The given data is the hourly surface data of February 2019. Please apply FFT to remove the diurnal component of this data set.\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#temperature","title":"Temperature\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#pressure","title":"Pressure\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#rain","title":"Rain\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#wind","title":"Wind\u00b6","text":""},{"location":"past_exam/2022_fall/example/","title":"[2022 Fall] Final Exam - Example Code","text":"In\u00a0[1]: Copied! <pre>from scipy import integrate\nfrom scipy.special import erf\nimport numpy as np\ngaussian = lambda x: ((2*x) + (3/x))**2\nresult = integrate.romberg(gaussian, 1, 2, show=True)\n</pre> from scipy import integrate from scipy.special import erf import numpy as np gaussian = lambda x: ((2*x) + (3/x))**2 result = integrate.romberg(gaussian, 1, 2, show=True) <pre>Romberg integration of &lt;function vectorize1.&lt;locals&gt;.vfunc at 0x7eff1f94fc70&gt; from [1, 2]\n\n Steps  StepSize   Results\n     1  1.000000 27.625000 \n     2  0.500000 26.312500 25.875000 \n     4  0.250000 25.955944 25.837092 25.834565 \n     8  0.125000 25.864188 25.833602 25.833370 25.833351 \n    16  0.062500 25.841060 25.833351 25.833334 25.833333 25.833333 \n    32  0.031250 25.835266 25.833334 25.833333 25.833333 25.833333 25.833333 \n\nThe final result is 25.833333333536203 after 33 function evaluations.\n</pre> In\u00a0[2]: Copied! <pre>x=np.array([0,1,2,3])\nfx=(x**2)*(np.exp(x))\nnp.trapz(fx, dx=1)\n</pre> x=np.array([0,1,2,3]) fx=(x**2)*(np.exp(x)) np.trapz(fx, dx=1) Out[2]: <pre>122.65942237852616</pre> In\u00a0[3]: Copied! <pre>integrate.simps(fx,dx=1)\n</pre> integrate.simps(fx,dx=1) Out[3]: <pre>108.27484014325017</pre> In\u00a0[4]: Copied! <pre>from scipy import integrate\n\nf = lambda x: 1/(1+x**2)\nintegrate.quadrature(f, -3.0, 3.0)\n</pre> from scipy import integrate  f = lambda x: 1/(1+x**2) integrate.quadrature(f, -3.0, 3.0) Out[4]: <pre>(2.498091551681014, 2.0135777933916188e-08)</pre> In\u00a0[5]: Copied! <pre>import numpy as np\n\ndef f(x): \n    return np.cos(x)\n\ndef fp(x): \n    return np.sin(x)\n\nfp(np.pi/4)\n\ndef phi(x,h): \n    return (f(x+h)-f(x-h))/(2*h)\n\n# d = [phi(1,h) for h in [2**(-n) for n in range(5)]]\nd = [phi(np.pi/4,h) for h in [np.pi/3,np.pi/6]]\n</pre> import numpy as np  def f(x):      return np.cos(x)  def fp(x):      return np.sin(x)  fp(np.pi/4)  def phi(x,h):      return (f(x+h)-f(x-h))/(2*h)  # d = [phi(1,h) for h in [2**(-n) for n in range(5)]] d = [phi(np.pi/4,h) for h in [np.pi/3,np.pi/6]] In\u00a0[6]: Copied! <pre>d\n</pre> d Out[6]: <pre>[-0.5847726009252571, -0.6752372371178295]</pre> In\u00a0[7]: Copied! <pre>N = len(d)\nD = np.zeros((N,N))\nD[:,0] = d\nfor m in range(1,N):\n    for n in range(m,N):\n        D[n,m] = (4**m*D[n,m-1]-D[n-1,m-1])/(4**m-1)\n</pre> N = len(d) D = np.zeros((N,N)) D[:,0] = d for m in range(1,N):     for n in range(m,N):         D[n,m] = (4**m*D[n,m-1]-D[n-1,m-1])/(4**m-1) In\u00a0[8]: Copied! <pre>D\n</pre> D Out[8]: <pre>array([[-0.5847726 ,  0.        ],\n       [-0.67523724, -0.70539212]])</pre>"},{"location":"past_exam/2022_fall/example/#2022-fall-final-exam-example-code","title":"[2022 Fall] Final Exam - Example Code\u00b6","text":"<p>This is the example code from TAs.</p>"},{"location":"past_exam/2022_fall/example/#romberg-intergration-example","title":"Romberg Intergration Example\u00b6","text":""},{"location":"past_exam/2022_fall/example/#trapeziodal-rule-example","title":"Trapeziodal Rule Example\u00b6","text":""},{"location":"past_exam/2022_fall/example/#simpson-rule-example-composite-simpson-13","title":"Simpson Rule Example (composite simpson (1/3))\u00b6","text":""},{"location":"past_exam/2022_fall/example/#gauss-quadrature-example","title":"Gauss Quadrature Example\u00b6","text":""},{"location":"past_exam/2022_fall/example/#richardson-extropolation","title":"Richardson Extropolation\u00b6","text":""},{"location":"past_exam/2022_fall/read_file/","title":"[2022 Fall] Final Exam - Example of Reading Data","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\n### \u98b1\u98a8\u534a\u5f91\u548c\u98a8\u901f\nradius, velocity = np.loadtxt(\"./data/TCVt.txt\", unpack=\"true\")\n\n## \u756b\u500b\u5716\nfig = plt.figure(figsize=(16, 12))\nplt.plot(radius, velocity)\n\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  ### \u98b1\u98a8\u534a\u5f91\u548c\u98a8\u901f radius, velocity = np.loadtxt(\"./data/TCVt.txt\", unpack=\"true\")  ## \u756b\u500b\u5716 fig = plt.figure(figsize=(16, 12)) plt.plot(radius, velocity)  plt.show() In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\n# T : environment virtual temperature\n# Tv : virtual temperature\n# Height : m\nHeight,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")\n\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(T,Height)\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Height\")\nplt.xlabel(\"Temperature (K)\")\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  # T : environment virtual temperature # Tv : virtual temperature # Height : m Height,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")   fig = plt.figure(figsize=(16,12)) plt.plot(T,Height) plt.title(\"Temperature Profile\") plt.ylabel(\"Height\") plt.xlabel(\"Temperature (K)\") plt.show() In\u00a0[3]: Copied! <pre>import scipy.io as sio\nimport matplotlib.pyplot as plt\n\n#\u8b80\u8cc7\u6599\nmat_contents = sio.loadmat(\"./data/cceqs.mat\")\nsorted(mat_contents.keys())\nTc = mat_contents['Tc'][0]\ne = mat_contents['e'][0]\n\n#\u78ba\u8a8d\u8cc7\u6599\nplt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\n</pre> import scipy.io as sio import matplotlib.pyplot as plt  #\u8b80\u8cc7\u6599 mat_contents = sio.loadmat(\"./data/cceqs.mat\") sorted(mat_contents.keys()) Tc = mat_contents['Tc'][0] e = mat_contents['e'][0]  #\u78ba\u8a8d\u8cc7\u6599 plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\") Out[3]: <pre>Text(0.5, 0, 'Temperature (degree Celsius)')</pre> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\n# T : Parcel virtual temperature\n# Tv : Environment virtual temperature\n# Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level)\nHeight,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")\n\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(T,Height)\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Height\")\nplt.xlabel(\"Temperature (K)\")\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  # T : Parcel virtual temperature # Tv : Environment virtual temperature # Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level) Height,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")   fig = plt.figure(figsize=(16,12)) plt.plot(T,Height) plt.title(\"Temperature Profile\") plt.ylabel(\"Height\") plt.xlabel(\"Temperature (K)\") plt.show()"},{"location":"past_exam/2022_fall/read_file/#2022-fall-final-exam-example-of-reading-data","title":"[2022 Fall] Final Exam - Example of Reading Data\u00b6","text":"<p>This is the example code to read the data from TAs.</p>"}]}