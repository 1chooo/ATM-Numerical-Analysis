{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Numerical Analysis","text":"<p>The Numerical Analysis Method I have learned in \"Numerical Analysis\" 2022 Fall | Prof. Shu-chih Yang (\u694a \u8212\u829d)</p> <p>\u8072\u660e\uff1a\u6b64 repo \u7d55\u5c0d\u4e0d\u6703\u76c8\u5229\uff0c\u90fd\u662f\u8ab2\u7a0b\u4e0a\u6240\u5b78\u5230\u7684\uff0c\u4e5f\u4e0d\u6703\u60e1\u610f\u50b3\u64ad\uff0c\u4e00\u5207\u90fd\u6703\u4ee5\u6559\u6388\u6307\u5c0e\u70ba\u539f\u5247\u3002</p>"},{"location":"assignment/a1/","title":"A1","text":"In\u00a0[1]: Copied! <pre>print('Hello World')\n</pre> print('Hello World') <pre>Hello World\n</pre>"},{"location":"assignment/a1/q1/","title":"Q1","text":""},{"location":"course_note/Week01/","title":"Week01","text":"<p>numerical and analytical are close \u2192 approximation \u2192 we need to consider the error bar</p> <p>through different way;however, we want the same answer.</p> <p>we have to consider how meaningful about analytical sol. \u2192 errors</p> <ul> <li>round off error<ul> <li>finite digits</li> </ul> </li> <li>truncation error<ul> <li>decide the stopping point</li> </ul> </li> </ul> <p>certain digits + estimated digit(half of the smallest scale)</p> <p>accuracy v.s. precision</p> <p>error definition \u2192 percent relative error</p> <p>$0.5 * 10 ^ {(2 - n)}$ (n is the runTimes)</p>"},{"location":"course_note/Week02/","title":"Week02","text":"<p>\u503c\u8d8a\u5927\u8aa4\u5dee\u8d8a\u5927</p> <p>\u8981\u5b58\u53d6\u8f03\u5927\u7684\u503c\uff0cexponent \u4e5f\u8981\u8ddf\u8457\u8b8a\u5927\uff0c\u4e0d\u904e\u4f4d\u5143\u6578\u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u6e96\u78ba\u5ea6\u6703\u964d\u4f4e</p> <p>chopping rounding</p> <p>Note:\u00a0In the interest of making this somewhat self-contained, I am using terminology from the most recent versions of the IEEE-754 standard. Prior to 2008, \"subnormal numbers\" were called \"denormal numbers\", and \"binary32\" was called \"single precision\". Some textbooks/papers/etc may use the old terms.</p> <p>The representation that you are talking about here is called, in IEEE-754, normal numbers. A normal number is one which has a single nonzero digit on the left-hand side of the radix point (i.e. decimal point or binary point) of its mantissa.</p> <p>The representation for zero uses a slightly different representation, namely, subnormal numbers.</p>"},{"location":"course_note/Week03/","title":"Week03","text":""},{"location":"course_note/Week03/#chapter-four","title":"Chapter Four","text":"<p>Step size \u2192 large: error less; small error more and accumulate.   </p> <p>$partial(f(x)) / partial(h) = 0$ \u2192 to get the minimal error.</p> <p>There are three inseting ways to find the error; however, this class we intro the middle way. And we need calculus to find the error.</p> <p>We have to consider round-off error and truncation error to let the numerical error minimize.</p> <p>blunders \u2192 what stupid people did, formulation errors \u2192 there are still some phenomanon that we haven\u2019t certained, data uncertainty</p> <p>How will you improve the accuracy of the divergence? </p> <ul> <li> <p>HW</p> <p>4.3</p> <p>4.8</p> <p>4.23</p> </li> </ul>"},{"location":"course_note/Week03/#chapter-five","title":"Chapter Five","text":"<p>if we meet the complex polynomial \u2192 through graphic method to find the point interect with x-axis.</p> <ul> <li>Bisection:<ul> <li>divided into 2, we can count the truth steps of getting the value what we want.</li> <li>True error never exceeds delta(x) / 2</li> <li>more times</li> </ul> </li> <li>False position:<ul> <li>linear interpolation</li> <li>less times</li> </ul> </li> </ul>"},{"location":"course_note/Week03/#chapter-six","title":"Chapter Six","text":"<ul> <li>Simple fixed-point iteration:<ul> <li>rewrite the funciton \u2192 left-side = right-side</li> </ul> </li> </ul>"},{"location":"course_note/Week04/","title":"Week04","text":""},{"location":"course_note/Week04/#chapter-six","title":"Chapter Six","text":"<ul> <li> <p>Simple fixed-point iteration:</p> <ul> <li>rewrite the funciton \u2192 left-side = right-side</li> </ul> </li> <li> <p>Newton-Raphson</p> </li> <li>review the textbook </li> <li>poor convergence</li> <li> <p>depends on nature of the function and the accuracy of the initial guess -&gt; initial guess is important.</p> </li> <li> <p>Secant method</p> </li> <li>required two initial guess</li> </ul>"},{"location":"course_note/Week05/","title":"Week05","text":""},{"location":"course_note/Week05/#plot","title":"plot","text":""},{"location":"course_note/Week05/#cramers-rule","title":"Cramer's rule","text":""},{"location":"course_note/Week05/#naive-gauss","title":"Naive Gauss","text":"<pre><code>do k = 1, n - 1\ndo i = k + 1, n\nfactor = a(i, k) / a(k, k)\ndo j = k + 1, n\na(i, j) = a(i, j) - factor * a(k, j)\nenddo\nb(i) = b(i) - factor * b(k)\nenddo\nenddo\n</code></pre> <ul> <li>ill-conditioned systems</li> <li>small change in coefficients results in large scale.</li> <li>wide range of the answers.</li> <li> <p>determinant close to zero.</p> </li> <li> <p>condition number</p> </li> <li> <p>standardlize -&gt; pick up the maximum element.</p> </li> <li> <p>Improve</p> </li> <li>use more significant figures</li> <li>pick up the great pivot<ul> <li>avoid divide zero and round-off error</li> </ul> </li> <li>scaling<ul> <li>we not include scaling into the system.</li> </ul> </li> </ul>"},{"location":"course_note/Week05/#flops","title":"Flops","text":""},{"location":"course_note/Week06/","title":"Week06","text":""},{"location":"course_note/Week06/#lu-decomposition","title":"LU Decomposition","text":""},{"location":"course_note/Week06/#choleshy-factorization","title":"Choleshy factorization","text":""},{"location":"course_note/Week06/#matrix-inverse","title":"Matrix inverse","text":""},{"location":"course_note/Week07/","title":"Week07","text":"<p>jacobi -&gt; gauss seidel \u5c0d\u89d2\u7dda\u4e3b\u5c0e</p>"},{"location":"course_note/Week08/","title":"Week08","text":"<p>find the maximum and minimum</p>"},{"location":"course_note/Week09/","title":"Week09","text":"<p>conjugate gradient solver residual</p>"},{"location":"course_note/Week11/","title":"Week11","text":"<p>\u7dda\u6027\u8f49\u63db</p>"},{"location":"course_note/Week12/","title":"Week12","text":"<p>auxilary</p>"},{"location":"past_exam/2022_fall/22_fall_q1/","title":"[2022 Fall] Final Exam - Question 1","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>radius, velocity = np.loadtxt(\"./data/TCVt.txt\",unpack=\"true\")\n\nprint(radius)\nprint(len(radius))\nprint(velocity)\nprint(len(velocity))\n</pre> radius, velocity = np.loadtxt(\"./data/TCVt.txt\",unpack=\"true\")  print(radius) print(len(radius)) print(velocity) print(len(velocity)) <pre>[  0.5   8.5  16.5  24.5  32.5  40.5  56.5  64.5  72.5  80.5  88.5  96.5\n 104.5 112.5 120.5 128.5 136.5 144.5 152.5 160.5 168.5 176.5 184.5 192.5]\n24\n[ 2.0233  8.6362 12.1303 14.8529 17.1661 19.6514 19.2963 18.4415 17.6843\n 17.0022 16.3786 15.8015 15.2619 14.7534 14.271  13.8111 13.3708 12.9481\n 12.5413 12.1492 11.7707 11.4049 11.0513 10.7091]\n24\n</pre> In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=(16,12))\nplt.plot(radius, velocity)\nplt.show()\n</pre> fig = plt.figure(figsize=(16,12)) plt.plot(radius, velocity) plt.show() In\u00a0[4]: Copied! <pre>def lagrange(x, y, f, n, x_miss):\n    ans = 0.0\n    for i in range(f, n+1):\n        product = y[i]\n        for j in range(f, n+1):\n            if i != j:\n                product = product * (x_miss - x[j]) / (x[i] - x[j])\n        ans = ans + product\n    return ans\n</pre> def lagrange(x, y, f, n, x_miss):     ans = 0.0     for i in range(f, n+1):         product = y[i]         for j in range(f, n+1):             if i != j:                 product = product * (x_miss - x[j]) / (x[i] - x[j])         ans = ans + product     return ans In\u00a0[5]: Copied! <pre>ans = lagrange(radius, velocity, 0, len(radius)-1, 50.)\nprint(\"Vt at 50km with Lagrange method:\", ans)\n</pre> ans = lagrange(radius, velocity, 0, len(radius)-1, 50.) print(\"Vt at 50km with Lagrange method:\", ans) <pre>Vt at 50km with Lagrange method: 19.944063474958146\n</pre> In\u00a0[6]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef cubic_inter(x0, x, y):\n\n    x = np.array(x)\n    y = np.array(y)\n\n    size = len(x)\n\n    x_diff = np.zeros(size - 1)\n    for i in range(0, 23):\n        x_diff[i] = x[i + 1] - x[i]\n\n    y_diff = np.zeros(size - 1)\n    for i in range(0, 23):\n        y_diff[i] = y[i + 1] - y[i]\n\n    # allocate buffer matrices\n    Li = np.zeros(size)\n    Li_1 = np.zeros(size-1)\n    z = np.zeros(size)\n\n    # fill diagonals Li and Li-1 and solve [L][y] = [B]\n    Li[0] = np.sqrt(2*x_diff[0])\n    Li_1[0] = 0.0\n    B0 = 0.0 # natural boundary\n    z[0] = B0 / Li[0]\n\n    for i in range(1, size-1, 1):\n        Li_1[i] = x_diff[i-1] / Li[i-1]\n        Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])\n        Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])\n        z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    i = size - 1\n    Li_1[i-1] = x_diff[-1] / Li[i-1]\n    Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])\n    Bi = 0.0 # natural boundary\n    z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    # solve [L.T][x] = [y]\n    i = size-1\n    z[i] = z[i] / Li[i]\n    for i in range(size-2, -1, -1):\n        z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]\n\n    # find index\n    count = 0\n\n    for i in range(0, len(x)):\n        if x0[0] &gt; x[i]:\n            count += 1\n        else:\n            break\n\n    xi1, xi0 = x[count], x[count - 1]\n    yi1, yi0 = y[count], y[count - 1]\n    zi1, zi0 = z[count], z[count - 1]\n    hi1 = xi1 - xi0\n\n    # calculate cubic\n    f0 = zi0/(6*hi1)*(xi1-x0)**3 \\\n        + zi1/(6*hi1)*(x0-xi0)**3 \\\n        + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) \\\n        + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)\n\n    return f0\n</pre> import numpy as np import matplotlib.pyplot as plt   def cubic_inter(x0, x, y):      x = np.array(x)     y = np.array(y)      size = len(x)      x_diff = np.zeros(size - 1)     for i in range(0, 23):         x_diff[i] = x[i + 1] - x[i]      y_diff = np.zeros(size - 1)     for i in range(0, 23):         y_diff[i] = y[i + 1] - y[i]      # allocate buffer matrices     Li = np.zeros(size)     Li_1 = np.zeros(size-1)     z = np.zeros(size)      # fill diagonals Li and Li-1 and solve [L][y] = [B]     Li[0] = np.sqrt(2*x_diff[0])     Li_1[0] = 0.0     B0 = 0.0 # natural boundary     z[0] = B0 / Li[0]      for i in range(1, size-1, 1):         Li_1[i] = x_diff[i-1] / Li[i-1]         Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])         Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])         z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      i = size - 1     Li_1[i-1] = x_diff[-1] / Li[i-1]     Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])     Bi = 0.0 # natural boundary     z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      # solve [L.T][x] = [y]     i = size-1     z[i] = z[i] / Li[i]     for i in range(size-2, -1, -1):         z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]      # find index     count = 0      for i in range(0, len(x)):         if x0[0] &gt; x[i]:             count += 1         else:             break      xi1, xi0 = x[count], x[count - 1]     yi1, yi0 = y[count], y[count - 1]     zi1, zi0 = z[count], z[count - 1]     hi1 = xi1 - xi0      # calculate cubic     f0 = zi0/(6*hi1)*(xi1-x0)**3 \\         + zi1/(6*hi1)*(x0-xi0)**3 \\         + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) \\         + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)      return f0 In\u00a0[7]: Copied! <pre>print('Vt at 50 km by the Cubic spline =',cubic_inter([50], radius, velocity)[0])\n</pre> print('Vt at 50 km by the Cubic spline =',cubic_inter([50], radius, velocity)[0]) <pre>Vt at 50 km by the Cubic spline = 20.117322677684125\n</pre> In\u00a0[8]: Copied! <pre>def central_diff(radius_arr, wind_arr, data_size):\n\n    # The first and the last need to be special progress.\n\n    temp_grad_arr = []\n\n\n    for i in range(0, data_size):\n\n        if i == 0:\n            pressure_div = float(radius_arr[i + 1] - radius_arr[i])\n            temp_div = float(wind_arr[i + 1] - wind_arr[i])\n            temp_grad =  temp_div / pressure_div\n        elif i == data_size - 1:\n            pressure_div = float(radius_arr[i] - radius_arr[i - 1])\n            temp_div = float(wind_arr[i] - wind_arr[i - 1])\n            temp_grad =  temp_div / pressure_div\n        else:\n            pressure_div = float(radius_arr[i + 1] - radius_arr[i - 1])\n            temp_div = float(wind_arr[i + 1] - wind_arr[i - 1])\n            temp_grad =  temp_div / pressure_div\n\n        temp_grad_arr.append(temp_grad)\n\n    return temp_grad_arr\n</pre> def central_diff(radius_arr, wind_arr, data_size):      # The first and the last need to be special progress.      temp_grad_arr = []       for i in range(0, data_size):          if i == 0:             pressure_div = float(radius_arr[i + 1] - radius_arr[i])             temp_div = float(wind_arr[i + 1] - wind_arr[i])             temp_grad =  temp_div / pressure_div         elif i == data_size - 1:             pressure_div = float(radius_arr[i] - radius_arr[i - 1])             temp_div = float(wind_arr[i] - wind_arr[i - 1])             temp_grad =  temp_div / pressure_div         else:             pressure_div = float(radius_arr[i + 1] - radius_arr[i - 1])             temp_div = float(wind_arr[i + 1] - wind_arr[i - 1])             temp_grad =  temp_div / pressure_div          temp_grad_arr.append(temp_grad)      return temp_grad_arr In\u00a0[9]: Copied! <pre>radius_arr = np.linspace(0.5, 192.5, 8)\nwind_arr = cubic_inter(radius_arr, radius, velocity)\ndata_size = len(radius_arr)\nwing_grad_arr = central_diff(radius_arr, wind_arr, data_size)\nwind_grad_max = max(wing_grad_arr)\nprint(\"The maximum of the wind gradient:\", wind_grad_max)\n</pre> radius_arr = np.linspace(0.5, 192.5, 8) wind_arr = cubic_inter(radius_arr, radius, velocity) data_size = len(radius_arr) wing_grad_arr = central_diff(radius_arr, wind_arr, data_size) wind_grad_max = max(wing_grad_arr) print(\"The maximum of the wind gradient:\", wind_grad_max) <pre>The maximum of the wind gradient: 0.877404910990909\n</pre> In\u00a0[10]: Copied! <pre>data_size = len(radius)\nwing_grad_arr2 = central_diff(radius, velocity, data_size)\nwind_grad_max2 = max(wing_grad_arr2)\nprint(\"The maximum of the wind gradient with the central difference method:\", wind_grad_max2)\n</pre> data_size = len(radius) wing_grad_arr2 = central_diff(radius, velocity, data_size) wind_grad_max2 = max(wing_grad_arr2) print(\"The maximum of the wind gradient with the central difference method:\", wind_grad_max2) <pre>The maximum of the wind gradient with the central difference method: 0.8266125000000001\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q1/#2022-fall-final-exam-question-1","title":"[2022 Fall] Final Exam - Question 1\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q1/","title":"\u98b1\u98a8\u534a\u5f91\u548c\u98a8\u901f\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/","title":"\u756b\u500b\u5716\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#a-determine-vt-at-50km-with-the-lagrange-method","title":"a. Determine Vt at 50km with the Lagrange method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#b-please-determine-vt-at-50-km-by-the-cubi-spline-method","title":"b. Please determine Vt at 50 km, by the cubi spline method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#c-determine-the-location-of-the-maximum-of-the-wind-gradient-based-on-b","title":"c. Determine the location of the maximum of the wind gradient based on (b).\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q1/#d-determine-the-maximum-of-the-wind-gradient-with-the-central-difference-method","title":"d. Determine the maximum of the wind gradient with the central difference method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q2/","title":"[2022 Fall] Final Exam - Question 2","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre># T : Parcel virtual temperature\n# Tv : Environment virtual temperature\n# Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level)\nHeight, T, Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")\n\nprint(Height)\nprint(len(Height))\n\nprint(T)\nprint(len(T))\n\nprint(Tv)\nprint(len(Tv))\n</pre> # T : Parcel virtual temperature # Tv : Environment virtual temperature # Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level) Height, T, Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")  print(Height) print(len(Height))  print(T) print(len(T))  print(Tv) print(len(Tv)) <pre>[   0.  500. 1000. 1500. 2000. 2500. 3000. 3500. 4000. 4500. 5000. 5500.\n 6000. 6500. 7000. 7500.]\n16\n[302.641015 301.414936 300.052387 299.219994 297.945706 297.839665\n 296.395461 295.957622 294.836952 294.042834 293.178223 292.128172\n 291.41732  290.846195 289.566794 288.568096]\n16\n[308.45302  304.161056 299.426643 296.55262  292.179701 291.817268\n 286.903579 285.422136 281.647781 278.988442 276.107374 272.628489\n 270.285908 268.411115 264.234983 260.997853]\n16\n</pre> In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=(16,12))\nplt.plot(T, Height)\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Height\")\nplt.xlabel(\"Temperature (K)\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16,12)) plt.plot(T, Height) plt.title(\"Temperature Profile\") plt.ylabel(\"Height\") plt.xlabel(\"Temperature (K)\")  plt.show() In\u00a0[4]: Copied! <pre>g = 9.8\npara = (T - Tv) / Tv\n</pre> g = 9.8 para = (T - Tv) / Tv In\u00a0[5]: Copied! <pre>def trapezoid_method(f, h, n):\n\n    total = f[0]\n    for i in range(1, n):\n        total = total + 2 * f[i]\n    total = total + f[n]\n\n    ans = h * total / 2\n    \n    return ans\n</pre> def trapezoid_method(f, h, n):      total = f[0]     for i in range(1, n):         total = total + 2 * f[i]     total = total + f[n]      ans = h * total / 2          return ans In\u00a0[6]: Copied! <pre>trapezoid_method_result = g * trapezoid_method(para, (7500.) / (len(T) - 1), len(T) - 1)\nprint(\"Trapezoid:\", trapezoid_method_result)\n</pre> trapezoid_method_result = g * trapezoid_method(para, (7500.) / (len(T) - 1), len(T) - 1) print(\"Trapezoid:\", trapezoid_method_result) <pre>Trapezoid: 3173.2169619851093\n</pre> In\u00a0[7]: Copied! <pre>def simpson_13_method(f, h, n):\n\n    total = f[0]\n    for i in range(1, n, 2):\n        total = total + 4 * f[i]\n    for j in range(2, n-1, 2):\n        total = total + 2 * f[j]\n    total = total + f[n]\n\n    ans = h * total / 3\n    \n    return ans\n</pre> def simpson_13_method(f, h, n):      total = f[0]     for i in range(1, n, 2):         total = total + 4 * f[i]     for j in range(2, n-1, 2):         total = total + 2 * f[j]     total = total + f[n]      ans = h * total / 3          return ans In\u00a0[8]: Copied! <pre>simpson_13_method_result = g * simpson_13_method(para, (7500.) / (len(T) - 1), len(T) - 1)\nprint(\"Simpson 1/3:\", simpson_13_method_result)\n</pre> simpson_13_method_result = g * simpson_13_method(para, (7500.) / (len(T) - 1), len(T) - 1) print(\"Simpson 1/3:\", simpson_13_method_result) <pre>Simpson 1/3: 2673.154315758109\n</pre> In\u00a0[9]: Copied! <pre>def cubic_inter(x0, x, y):\n\n    x = np.array(x)\n    y = np.array(y)\n    # remove non finite values\n    # indexes = np.isfinite(x)\n    # check if sorted\n    if np.any(np.diff(x) &lt; 0):\n        indexes = np.argsort(x)\n        x = x[indexes]\n        y = y[indexes]\n\n    size = len(x)\n    # print(size)\n    x_diff = np.zeros(size - 1)\n    for i in range(0, 15):\n        x_diff[i] = x[i + 1] - x[i]\n\n    y_diff = np.zeros(size - 1)\n    for i in range(0, 15):\n        y_diff[i] = y[i + 1] - y[i]\n\n    # allocate buffer matrices\n    Li = np.zeros(size)\n    Li_1 = np.zeros(size-1)\n    z = np.zeros(size)\n\n    # fill diagonals Li and Li-1 and solve [L][y] = [B]\n    Li[0] = np.sqrt(2*x_diff[0])\n    Li_1[0] = 0.0\n    B0 = 0.0 # natural boundary\n    z[0] = B0 / Li[0]\n\n    for i in range(1, size-1, 1):\n        Li_1[i] = x_diff[i-1] / Li[i-1]\n        Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])\n        Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])\n        z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    i = size - 1\n    Li_1[i-1] = x_diff[-1] / Li[i-1]\n    Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])\n    Bi = 0.0 # natural boundary\n    z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]\n\n    # solve [L.T][x] = [y]\n    i = size-1\n    z[i] = z[i] / Li[i]\n    for i in range(size-2, -1, -1):\n        z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]\n\n    # find index\n    count = 0\n\n    for i in range(0, len(x)):\n        if x0[0] &gt; x[i]:\n            count += 1\n        else:\n            break\n\n    xi1, xi0 = x[count], x[count - 1]\n    yi1, yi0 = y[count], y[count - 1]\n    zi1, zi0 = z[count], z[count - 1]\n    hi1 = xi1 - xi0\n\n    # calculate cubic\n    f0 = zi0/(6*hi1)*(xi1-x0)**3 + zi1/(6*hi1)*(x0-xi0)**3 + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)\n    \n    return f0\n</pre> def cubic_inter(x0, x, y):      x = np.array(x)     y = np.array(y)     # remove non finite values     # indexes = np.isfinite(x)     # check if sorted     if np.any(np.diff(x) &lt; 0):         indexes = np.argsort(x)         x = x[indexes]         y = y[indexes]      size = len(x)     # print(size)     x_diff = np.zeros(size - 1)     for i in range(0, 15):         x_diff[i] = x[i + 1] - x[i]      y_diff = np.zeros(size - 1)     for i in range(0, 15):         y_diff[i] = y[i + 1] - y[i]      # allocate buffer matrices     Li = np.zeros(size)     Li_1 = np.zeros(size-1)     z = np.zeros(size)      # fill diagonals Li and Li-1 and solve [L][y] = [B]     Li[0] = np.sqrt(2*x_diff[0])     Li_1[0] = 0.0     B0 = 0.0 # natural boundary     z[0] = B0 / Li[0]      for i in range(1, size-1, 1):         Li_1[i] = x_diff[i-1] / Li[i-1]         Li[i] = np.sqrt(2*(x_diff[i-1]+x_diff[i]) - Li_1[i-1] * Li_1[i-1])         Bi = 6*(y_diff[i]/x_diff[i] - y_diff[i-1]/x_diff[i-1])         z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      i = size - 1     Li_1[i-1] = x_diff[-1] / Li[i-1]     Li[i] = np.sqrt(2*x_diff[-1] - Li_1[i-1] * Li_1[i-1])     Bi = 0.0 # natural boundary     z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]      # solve [L.T][x] = [y]     i = size-1     z[i] = z[i] / Li[i]     for i in range(size-2, -1, -1):         z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]      # find index     count = 0      for i in range(0, len(x)):         if x0[0] &gt; x[i]:             count += 1         else:             break      xi1, xi0 = x[count], x[count - 1]     yi1, yi0 = y[count], y[count - 1]     zi1, zi0 = z[count], z[count - 1]     hi1 = xi1 - xi0      # calculate cubic     f0 = zi0/(6*hi1)*(xi1-x0)**3 + zi1/(6*hi1)*(x0-xi0)**3 + (yi1/hi1 - zi1*hi1/6)*(x0-xi0) + (yi0/hi1 - zi0*hi1/6)*(xi1-x0)          return f0 In\u00a0[10]: Copied! <pre>def trap_eq(a, b, n):\n\n    h = (b - a) / n\n    x = a\n    sum_tra = cubic_inter([x], Height, para)[0] \n\n    for i in range(1, n):\n        x = x + h\n        sum_tra = sum_tra + 2 * cubic_inter([x], Height, para)[0]\n\n    sum_tra = sum_tra + cubic_inter([b], Height, para)[0]\n    Trap = (b - a) * sum_tra / (2 * n)\n    \n    return Trap\n</pre> def trap_eq(a, b, n):      h = (b - a) / n     x = a     sum_tra = cubic_inter([x], Height, para)[0]       for i in range(1, n):         x = x + h         sum_tra = sum_tra + 2 * cubic_inter([x], Height, para)[0]      sum_tra = sum_tra + cubic_inter([b], Height, para)[0]     Trap = (b - a) * sum_tra / (2 * n)          return Trap In\u00a0[11]: Copied! <pre>def I(j, k, a, b):\n\n    if k == 1:\n        n = 2 ** (j - 1)\n\n        return trap_eq(a, b, n)\n    else:\n        i_jk = ((4 ** (k-1)) * I(j + 1, k - 1, a, b) - I(j, k - 1, a, b)) / ((4 ** (k - 1)) - 1)\n\n        return i_jk\n</pre> def I(j, k, a, b):      if k == 1:         n = 2 ** (j - 1)          return trap_eq(a, b, n)     else:         i_jk = ((4 ** (k-1)) * I(j + 1, k - 1, a, b) - I(j, k - 1, a, b)) / ((4 ** (k - 1)) - 1)          return i_jk In\u00a0[12]: Copied! <pre>def romberg_method(a, b, es):\n    i_ter = 0\n    while True:\n        i_ter = i_ter + 1\n\n        for k in range(2, i_ter + 2):\n            j = 2 + i_ter - k\n\n        ea = abs((I(1, i_ter + 1, a, b) - I(2, i_ter, a, b)) / I(1, i_ter + 1, a, b)) * 100\n        if ea &lt; es:\n            break\n\n    return I(1, i_ter + 1, a, b)\n</pre> def romberg_method(a, b, es):     i_ter = 0     while True:         i_ter = i_ter + 1          for k in range(2, i_ter + 2):             j = 2 + i_ter - k          ea = abs((I(1, i_ter + 1, a, b) - I(2, i_ter, a, b)) / I(1, i_ter + 1, a, b)) * 100         if ea &lt; es:             break      return I(1, i_ter + 1, a, b) In\u00a0[13]: Copied! <pre>romberg_method_result = g * romberg_method(0., 7500., 0.005) \nprint(\"Romberg:\", romberg_method_result)\n</pre> romberg_method_result = g * romberg_method(0., 7500., 0.005)  print(\"Romberg:\", romberg_method_result) <pre>Romberg: 3169.6285635767013\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q2/#2022-fall-final-exam-question-2","title":"[2022 Fall] Final Exam - Question 2\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q2/#trapezoid-method","title":"Trapezoid Method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q2/#simpson-13-method","title":"Simpson 1/3 Method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q2/#romberg-method","title":"Romberg Method\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/","title":"[2022 Fall] Final Exam - Question 3","text":"In\u00a0[1]: Copied! <pre>import scipy.io as sio\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import scipy.io as sio import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>mat_contents = sio.loadmat(\"./data/cceqs.mat\")\nsorted(mat_contents.keys())\nTc = mat_contents['Tc'][0]\ne = mat_contents['e'][0]\n\nprint(len(Tc))\nprint(Tc)\n\nprint()\n\nprint(len(e))\nprint(e)\n</pre> mat_contents = sio.loadmat(\"./data/cceqs.mat\") sorted(mat_contents.keys()) Tc = mat_contents['Tc'][0] e = mat_contents['e'][0]  print(len(Tc)) print(Tc)  print()  print(len(e)) print(e) <pre>66\n[-30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14 -13\n -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5\n   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23\n  24  25  26  27  28  29  30  31  32  33  34  35]\n\n66\n[ 103.03784717  110.21840143  117.82566779  125.88035082  134.40391071\n  143.41857998  152.94738016  163.01413849  173.64350459  184.86096706\n  196.69287011  209.16643007  222.30975185  236.15184532  250.72264164\n  266.05300947  282.17477102  299.12071809  316.92462788  335.62127874\n  355.2464657   375.83701593  397.43080395  420.06676672  443.78491852\n  468.62636565  494.63332089  521.84911783  550.31822489  580.08625916\n  611.2         643.7074024   677.65761005  713.10096823  750.08903635\n  788.67460026  828.91168427  870.8555629   914.56277234  960.09112156\n 1007.49970316 1056.84890395 1108.2004151  1161.6172421  1217.1637143\n 1274.90549418 1334.90958622 1397.24434553 1461.97948606 1529.18608847\n 1598.93660769 1671.30488011 1746.36613043 1824.19697809 1904.87544344\n 1988.48095349 2075.09434726 2164.79788088 2257.67523221 2353.81150513\n 2453.29323352 2556.20838475 2662.64636294 2772.69801171 2886.45561668\n 3004.01290756]\n</pre> In\u00a0[3]: Copied! <pre>plt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\n\nplt.show()\n</pre> plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\")  plt.show() In\u00a0[4]: Copied! <pre>def regression(x, y, n):\n\n    sum_x = 0   # the sum of the x\n    sum_y = 0   # the sum of the y\n\n    sum_xy = 0  # the sum of the x * y\n    sum_x2 = 0  # the sum of the x ^ 2\n\n    st = 0      \n    sr = 0      \n\n    for i in range(0, n):\n        sum_x += x[i]\n        sum_y += y[i]\n\n        sum_xy += x[i] * y[i]\n        sum_x2 += x[i] * x[i]\n\n    x_mean = sum_x / n\n    y_mean = sum_y / n\n\n    a1 = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)\n    a0 = y_mean - a1 * x_mean\n\n    for i in range(0, n):\n        st += (y[i] - y_mean) ** 2\n        sr += (y[i] - a0 - a1 * x[i]) ** 2\n\n    std_estimate_error = (sr - (n - 2)) ** 0.5\n    r2 = (st - sr) / st\n    r = ((st - sr) / st) ** 0.5\n\n    return a0, a1, std_estimate_error, r2, r\n</pre> def regression(x, y, n):      sum_x = 0   # the sum of the x     sum_y = 0   # the sum of the y      sum_xy = 0  # the sum of the x * y     sum_x2 = 0  # the sum of the x ^ 2      st = 0           sr = 0            for i in range(0, n):         sum_x += x[i]         sum_y += y[i]          sum_xy += x[i] * y[i]         sum_x2 += x[i] * x[i]      x_mean = sum_x / n     y_mean = sum_y / n      a1 = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)     a0 = y_mean - a1 * x_mean      for i in range(0, n):         st += (y[i] - y_mean) ** 2         sr += (y[i] - a0 - a1 * x[i]) ** 2      std_estimate_error = (sr - (n - 2)) ** 0.5     r2 = (st - sr) / st     r = ((st - sr) / st) ** 0.5      return a0, a1, std_estimate_error, r2, r In\u00a0[5]: Copied! <pre>data_size = len(Tc)\na0, a1, std_estimate_error, r2, r = regression(Tc, e, data_size)\n\nprint(\"After the LINEAR regression:\\n\")\nprint(\"a0:                              \", a0)\nprint(\"a1:                              \", a1)\nprint(\"std_estimate_error:              \", std_estimate_error)\nprint(\"Coefficient of the determination:\", r2)\nprint(\"Coefficient of the correlation:  \", r)\n</pre> data_size = len(Tc) a0, a1, std_estimate_error, r2, r = regression(Tc, e, data_size)  print(\"After the LINEAR regression:\\n\") print(\"a0:                              \", a0) print(\"a1:                              \", a1) print(\"std_estimate_error:              \", std_estimate_error) print(\"Coefficient of the determination:\", r2) print(\"Coefficient of the correlation:  \", r) <pre>After the LINEAR regression:\n\na0:                               879.9865701296675\na1:                               41.10433052361058\nstd_estimate_error:               2160.6155885448184\nCoefficient of the determination: 0.8965758428578144\nCoefficient of the correlation:   0.9468768889659386\n</pre> In\u00a0[6]: Copied! <pre>xs = np.arange(-30, 35, 0.1)\nys = a1 * xs + a0\nplt.plot(xs, ys, 'r')\nplt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\nplt.legend([\"regression:\\ny = 879.9865701296675x + 41.10433052361058\", \"input data\"])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(-30, 35, 0.1) ys = a1 * xs + a0 plt.plot(xs, ys, 'r') plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\") plt.legend([\"regression:\\ny = 879.9865701296675x + 41.10433052361058\", \"input data\"]) plt.grid()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q3/#2022-fall-final-exam-question-3","title":"[2022 Fall] Final Exam - Question 3\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q3/","title":"\u8b80\u8cc7\u6599\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/","title":"\u78ba\u8a8d\u8cc7\u6599\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#a-please-construct-the-c-c-equation-using-the-linear-regression","title":"a. Please construct the C-C equation using the LINEAR regression\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#define-the-linear-regression","title":"Define the LINEAR regression\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#data-with-the-linear-regression","title":"Data with the LINEAR regression\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#plot-the-linear-regression-to-the-figure","title":"Plot the LINEAR regression to the figure.\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#b-please-determine-the-goodness-of-fitting","title":"b. Please determine the goodness of fitting\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q3/#turn-to-the-ln","title":"Turn to the $ln$\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/","title":"[2022 Fall] Final Exam - Question 4","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>stnno,yyyymmddhh,Pressure,Rain,Temp,Wind = np.loadtxt(\"./data/ground_station_data.txt\",unpack=\"true\")\n</pre> stnno,yyyymmddhh,Pressure,Rain,Temp,Wind = np.loadtxt(\"./data/ground_station_data.txt\",unpack=\"true\") In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=(16,12))\nplt.plot(Temp)\nplt.title(\"Month Temperature\")\nplt.ylabel(\"Temperature\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original'])\nplt.grid()\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16,12)) plt.plot(Temp) plt.title(\"Month Temperature\") plt.ylabel(\"Temperature\") plt.xlabel(\"Data_perhour\") plt.legend(['Original']) plt.grid()  plt.show() In\u00a0[4]: Copied! <pre>from scipy.fft import fft, fftfreq, ifft\n</pre> from scipy.fft import fft, fftfreq, ifft In\u00a0[5]: Copied! <pre>xs = np.arange(0, 672, 0.1)\nY = np.fft.fft(Temp)\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(Temp)\nplt.plot(Y)\nplt.title(\"Month Temperature\")\nplt.ylabel(\"Temperature\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 0.1) Y = np.fft.fft(Temp)  fig = plt.figure(figsize=(16,12)) plt.plot(Temp) plt.plot(Y) plt.title(\"Month Temperature\") plt.ylabel(\"Temperature\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() <pre>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1335: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> In\u00a0[6]: Copied! <pre>xs = np.arange(0, 672, 1)\nys = Pressure[xs]\nY = np.fft.fft((ys))\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(xs, ys)\nplt.plot(Y)\nplt.title(\"Month Pressure\")\nplt.ylabel(\"Pressure\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 1) ys = Pressure[xs] Y = np.fft.fft((ys))  fig = plt.figure(figsize=(16,12)) plt.plot(xs, ys) plt.plot(Y) plt.title(\"Month Pressure\") plt.ylabel(\"Pressure\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() In\u00a0[7]: Copied! <pre>xs = np.arange(0, 672, 1)\nys = Rain[xs]\nY = np.fft.fft((ys))\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(xs, ys)\nplt.plot(Y)\nplt.title(\"Month Rain\")\nplt.ylabel(\"Rain\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 1) ys = Rain[xs] Y = np.fft.fft((ys))  fig = plt.figure(figsize=(16,12)) plt.plot(xs, ys) plt.plot(Y) plt.title(\"Month Rain\") plt.ylabel(\"Rain\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() In\u00a0[8]: Copied! <pre>xs = np.arange(0, 672, 1)\nys = Wind[xs]\nY = np.fft.fft((ys))\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(xs, ys)\nplt.plot(Y)\nplt.title(\"Month Wind\")\nplt.ylabel(\"Wind\")\nplt.xlabel(\"Data_perhour\")\nplt.legend(['Original', 'with FFT'])\nplt.grid()\n\nplt.show()\n</pre> xs = np.arange(0, 672, 1) ys = Wind[xs] Y = np.fft.fft((ys))  fig = plt.figure(figsize=(16,12)) plt.plot(xs, ys) plt.plot(Y) plt.title(\"Month Wind\") plt.ylabel(\"Wind\") plt.xlabel(\"Data_perhour\") plt.legend(['Original', 'with FFT']) plt.grid()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"past_exam/2022_fall/22_fall_q4/#2022-fall-final-exam-question-4","title":"[2022 Fall] Final Exam - Question 4\u00b6","text":"<p>Course: AP3021</p>"},{"location":"past_exam/2022_fall/22_fall_q4/#the-given-data-is-the-hourly-surface-data-of-february-2019-please-apply-fft-to-remove-the-diurnal-component-of-this-data-set","title":"The given data is the hourly surface data of February 2019. Please apply FFT to remove the diurnal component of this data set.\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#temperature","title":"Temperature\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#pressure","title":"Pressure\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#rain","title":"Rain\u00b6","text":""},{"location":"past_exam/2022_fall/22_fall_q4/#wind","title":"Wind\u00b6","text":""},{"location":"past_exam/2022_fall/read_file/","title":"Example of Reading Data","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\n### \u98b1\u98a8\u534a\u5f91\u548c\u98a8\u901f\nradius, velocity = np.loadtxt(\"./data/TCVt.txt\", unpack=\"true\")\n\n## \u756b\u500b\u5716\nfig = plt.figure(figsize=(16, 12))\nplt.plot(radius, velocity)\n\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  ### \u98b1\u98a8\u534a\u5f91\u548c\u98a8\u901f radius, velocity = np.loadtxt(\"./data/TCVt.txt\", unpack=\"true\")  ## \u756b\u500b\u5716 fig = plt.figure(figsize=(16, 12)) plt.plot(radius, velocity)  plt.show() In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\n# T : environment virtual temperature\n# Tv : virtual temperature\n# Height : m\nHeight,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")\n\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(T,Height)\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Height\")\nplt.xlabel(\"Temperature (K)\")\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  # T : environment virtual temperature # Tv : virtual temperature # Height : m Height,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")   fig = plt.figure(figsize=(16,12)) plt.plot(T,Height) plt.title(\"Temperature Profile\") plt.ylabel(\"Height\") plt.xlabel(\"Temperature (K)\") plt.show() In\u00a0[3]: Copied! <pre>import scipy.io as sio\nimport matplotlib.pyplot as plt\n\n#\u8b80\u8cc7\u6599\nmat_contents = sio.loadmat(\"./data/cceqs.mat\")\nsorted(mat_contents.keys())\nTc = mat_contents['Tc'][0]\ne = mat_contents['e'][0]\n\n#\u78ba\u8a8d\u8cc7\u6599\nplt.scatter(Tc,e)\nplt.title(\"Vapor Pressure vs Temperature\")\nplt.ylabel(\"Vapor Pressure (Pa)\")\nplt.xlabel(\"Temperature (degree Celsius)\")\n</pre> import scipy.io as sio import matplotlib.pyplot as plt  #\u8b80\u8cc7\u6599 mat_contents = sio.loadmat(\"./data/cceqs.mat\") sorted(mat_contents.keys()) Tc = mat_contents['Tc'][0] e = mat_contents['e'][0]  #\u78ba\u8a8d\u8cc7\u6599 plt.scatter(Tc,e) plt.title(\"Vapor Pressure vs Temperature\") plt.ylabel(\"Vapor Pressure (Pa)\") plt.xlabel(\"Temperature (degree Celsius)\") Out[3]: <pre>Text(0.5, 0, 'Temperature (degree Celsius)')</pre> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\n# T : Parcel virtual temperature\n# Tv : Environment virtual temperature\n# Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level)\nHeight,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")\n\n\nfig = plt.figure(figsize=(16,12))\nplt.plot(T,Height)\nplt.title(\"Temperature Profile\")\nplt.ylabel(\"Height\")\nplt.xlabel(\"Temperature (K)\")\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np  # T : Parcel virtual temperature # Tv : Environment virtual temperature # Height : 0--LFC(Level of free convection)  top--EL(Equilibrium level) Height,T,Tv = np.loadtxt(\"./data/Sounding_data.txt\",unpack=\"true\")   fig = plt.figure(figsize=(16,12)) plt.plot(T,Height) plt.title(\"Temperature Profile\") plt.ylabel(\"Height\") plt.xlabel(\"Temperature (K)\") plt.show()"},{"location":"past_exam/2022_fall/read_file/#example-of-reading-data","title":"Example of Reading Data\u00b6","text":"<p>This is the example code to read the data from TAs.</p>"}]}